<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[用 Spring Boot 编写 RESTful API]]></title>
    <url>%2F2018%2F12%2F23%2F%E7%94%A8SpringBoot%E7%BC%96%E5%86%99RESTfulAPI%2F</url>
    <content type="text"><![CDATA[课程课程 开始一个最简单的RESTFul API项目RESTful APIRepresentational State Transfer 所有的东西都是资源，所有的操作都是通过对资源的增删改查（CRUD）实现 对资源的增删改查对应对URL的操作（POST,DELETE,PUT,GET） 无状态的 Spring Boot大量使用注解，减少配置，无需配置XML自带嵌入式web服务器 Mavenpom.xml文件是Maven项目的配置文件几个常用的Maven命令（在pom.xml同级目录下运行）mvn test 编译并运行测试用例mvn spring-boot:run 运行spring-boot项目mvn package 打包项目mvn clean 可以和其它命令一起使用，例如mvn clean package 日期型转JSON格式可以在属性上增加1@JsonFormat(timezone=&quot;GMT+8&quot;, pattern=&quot;yyyy-MM-dd&quot;) 或 1@JsonFormat（shape=JsonFormat.Shape.NUMBER） 全局修改可以在application.yml 123456spring: jackson: date-format: yyyy-MM-dd #如果使用字符串表示，用这行设置格式 timezone: GMT+8 serialization: write-dates-as-timestamps: true #使用数值timestamp表示日期 RestController详解热部署（Hot Swapping）pom中加入devtools 12345678&lt;dependencies&gt; ... &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 记录日志Commons-logging or SLF4j 12private static final Log log = LogFactory.getLog(Xxx.class);private static final Logger log = LoggerFactory.getLogger(Xxx.class); 日志级别：TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATALapplication.yml配置日志12345logging: file: target/app.log level: ROOT: WARN cn.devmgr: TRACE 命令行工具CURL测试工具postman 在RestController中获取各种相关信息的方法 内容 获取方法 URL中路径的一部分 首先需要在RequestMapping做映射，之后在方法中可以通过注解使用映射的变量。可以写多个，@PutMapping(“/{id}/characters/{cId}”)，还可以使用正则表达式限制类型（不符合要求会返回4xx的错误信息，表示请求参数有问题）此例子表示id必须是数字：@PutMapping(“/{id:\\d+}”) POST方法传递过来的JSON 给参数前增加@RequestBody注解，Spring会自动把POST的Request Body部分的JSON转换成方法声明的类。如果转化失败会返回4xx错误，表示请求参数有问题。 POST方法传递的是表单数据 首先声明传入的是application/x-wwww-form-urlencoded的格式，可在RequestMapping增加consumes参数，@PostMapping(value=”/tvseries”, consumes=MediaType.APPLICATION_FORM_URLENCODED_VALUE)，在方法上增加参数，参数使用@RequestParam注解即可，public Object insert(@RequestParam(value=”name”, required=false) String name)，凡是可以通过HttpServletRequest.getParameter(String)方法取到的值，含表单提交的、QueryString附带的，都可以使用@RequestParam注解得到。默认是request=true。 QueryString的参数 使用@RequestParam注解，通过参数获得,例如：public Object query(@RequestParam(value=”page”, required=false) Integer page) Request Header 可以使用@Requestheader注解获取Request的头信息,例如public ResultJSON editCompany(@RequestHeader(“user-agent”) String userAgent) 注意：@RequestHeader后面的头名字不区分大小写，但RequestParam, PathVariable等是区分的。如果RequestHeader后面不写参数，会用后面的变量名替代。 获取cookie值 使用cookieValue注解，和其它类似，除非为了兼容老现有客户端，新API里不建议用cookie。 获取当前的Request Response 直接写参数，例如：public Object doSomething(HttpServletRequest request, HttpServletResponse response) 获取当前用户 直接在方法上增加参数，类型为org.springframework.security.core.Authentication, 例如：public TvSeries deleteOne(Authentication auth)，参数auth内会存储有当前的用户信息。 文件上传 首先要设置consumes为multipart/form-data，@PostMapping(value=”/files”, consumes=MediaType.MULTIPART_FORM_DATA_VALUE),在方法中写参数 public Map&lt;String, Object&gt; uploadFile(@RequestParam(“file”) MultipartFile file)。在方法中可以直接使用MultipartFile中的流保存文件了。 对客户端传入数据的校验原则：不要相信前端传过来的数据；尽量要前端少传递数据 Bean Validation: JSR303, Hibernate Validator Bean Validation 注解：@Null@NotNull@Min@Max@Size@Past 验证Date@Future@AssertTrue 验证Boolean@AssertFalse@Valid 级联验证注解 类型 注解 任何类型 NULL, NotNull 布尔型 AssertTrue, AssertFalse 字符串 NotBlank, Pattern, Size, Email, DecimalMin, Digits 数值 DecimalMax, DecimalMin, Digits, Max, Min, NegativeOrZero, Positive, PositiveOrZero 集合、Map、List NotEmpty, Size 日期 Future, Past, FutureOrPresent, PastOrPresent 以上注解都指Bean Validation 2.0 定义的注解，在javax.validation.constraints包下。Hibernate有些非JSR标准注解和上面的同名但package不同，功能会和上面这些有些细微差异。 约束规则对子类依旧有效groups参数 每个约束用注解都有一个groups参数 可接收多个class类型（必须是接口） 不声明groups参数是默认组javax.validation.groups.Default 声明了groups参数的会从Default组移除，如需加入Default组需要显示声明，例如@Null(groups={Default.class, Step1.class}) @Valid vs @Validated @Valid是JSR标准定义的注解，只验证Default组的约束 @Validated是Spring定义的注解，可以通过参数来指定验证的组，例如：@Validation({Step1.class,Default.class})表示验证Step1和Default两个组的约束 @Valid可用在成员变量上，进行级联验证；@Validated只能用在参数上，表示这个参数需要验证 参数中只用@Validated，通不过校验的参数，不会执行这个方法，加上BindingResult result ，参数通不过校验也会进入方法执行，校验结果会通过result参数传递进来。 手动验证 12345// 装载验证器@Autowired Validator validator;// 验证某个类，下面是执行默认的验证组，如果需要指定验证组，多传一个class参数Set&lt;ConstraintViolation&lt;?&gt;&gt; result = validator.validate(obj);// 通不过校验result的集合会有值，可以通过size()判断 在Spring Boot项目中使用Mybatis程序的层次结构Web前端、App、小程序、其它系统等Web控制层：@RestController @Controller业务逻辑层：@Service数据访问层：@Repository@Component数据库 PBF: Package by Feature 按功能划分PBL: Package by Layer 按层次划分 相邻层次的数据传输 PO：Persistant Object 持久对象 DTO：Data Transfer Object 数据传输对象 VO：Value Object 或 View Object POJO：Pure Old Java Object 或 Plain Ordinary Java Object DO：Domain Object BO：Business Object 处理业务逻辑 DAO：Data Access Object JavaBean: 有一个public的无参构造方法 属性private，且可以通过get、set、is（可以替代get，用在布尔型属性上）方法或遵循特定命名规范的其它方法访问 可序列化，实现Serializable接口 POJO vs JavaBean: POJO比javabean更简单。POJO严格的遵守简单对象的概念，而一些JavaBean中往往会封装一些简单逻辑。 POJO主要用于数据的临时传递，它只能装载数据，作为数据存储的载体，不具有业务逻辑处理能力。 JavaBean虽然数据的获取与POJO一样，但是javabean当中可以有其他方法。 几种简化方案： 一种POJO从web控制层到数据访问层 用JavaBean代替POJO POJO的get,set写起来也麻烦，用public的field代替 添加Mybatis支持步骤 修改pom.xml，添加mybatis支持 修改application.yml添加数据库连接 修改启动类，增加@MappingScan(“package-of-mapping”)注解 添加Mybatis Mapping接口 添加Mapping对应的XML（可选） pom.xml中添加 123456789&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.postgresql&lt;/groupId&gt; &lt;artifactId&gt;postgresql&lt;/artifactId&gt;&lt;/dependency&gt; application.yml中添加 1234567spring: datasource: dbcp2.validation-query: select 1 driverClassName: org.postgresql.Driver url: jdbc:postgresql://127.0.0.1:5432/thedb?stringtype=unspecified username: password: Spring Boot 项目的单元测试Assert-JUnit的断言 判断某条件是否为真 Assert.assertTrue(条件表达式)； 判断某条件是否为假 Assert.assertFalse(条件表达式)； 判断两个变量值是否相同 Assert.assertEquals(val1, val2); 判断两个变量值是否不相同 Assert.assertNotEquals(val1, val2); 判断两个数组是否相同 Assert.assertArrayEquals(数组1, 数组2)； 直接测试失败 Assert.fail() Assert.fail(message) Assert vs assert Assert是JUnit的断言类，全名是org.junit.Assert Assert提供了很多静态方法，例如… assert是java关键字，使用方法有两种，表达式为false时，jvm会退出； assert关键字内表达式是否被检查成立依赖jvm的参数，默认是关闭的 Java命令行参数：-ea (enableassertions) -da (disableassertions 默认) 概念 驱动模块 被测模块 桩模块 使用场景：替代尚未开发完毕的子模块；替代对环境依赖较大的子模块（例如数据访问层）； mockito12345&lt;dependency&gt; &lt;groupId&gt;org.mockito&lt;/groupId&gt; &lt;artifactId&gt;mockito-core&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; TDD Test Driven Development (测试驱动开发) 先写测试用例，后写实现代码 重构现有代码时特别好用 RDD: Resume Driven Development 在 Spring 中管理数据库事务@Transactional name 当在配置文件中有多个TransactionManager,可以用该属性指定选择哪个事务管理器。 propagation 事务的传播行为，默认值为REQUIRED。 isolation 事务的隔离度，默认采用DEFAULT。 timeout 事务的超时时间，默认值为-1,。如果超过该时间限制但事务还没有完成，则自动回滚事务。 readOnly 指定事务是否为只读事务，默认值为false；为了忽略那些不需要事务的方法，比如读取数据，可以设置readOnly为true。 rollbackFor 指定能够触发事务回滚的异常类型。 noRollbackFor 指定的异常类型，不回滚事务 1.noRollbackFor或子类；2.rollbackFor或子类；3.throws定义的异常或子类；4.其它异常；5.无异常 @Transactional(propagation=xx) propagation.REQUIRED 如果有事务，那么加入事务，没有的话新建一个（默认） propagation.NOT_SUPPORTED 容器不为这个方法开启事务 propagation.REQUIRED_NEW 不管是否存在事务，都创建一个新的事务，原来的挂起，新的执行完毕，继续执行老的事务 propagation.MANDATORY 必须在一个已有的事务中执行，否则抛出异常 propagation.NEVER 必须在一个没有的事务中执行，否则抛出异常（与propagation.MANDATORY相反） propagation.SUPPORTS 如果其它bean调用这个方法，在其它bean中声明事务，那就用事务，如果其它bean没有声明事务那就不用事务 propagation.NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与propagation.REQUIRED类似的操作 @Transactional(isolation=xx) Isolation.READ_UNCOMMITTED 读未提交数据 （脏读、不可重复读、幻读） Isolation.READ_COMMITTED 读已提交数据（不可重复读、幻读） Isolation.REPEATABLE_READ 可重复读 （幻读） Isolation.SERIALIZATION 串行化 Isolation.DEFAULT 使用数据库默认 Isolation vs Lock 两个不同的东西，隔离不是靠锁实现的，是靠对数据的监控实现的。 锁：表加好锁了，除非出现死锁等特殊情况，事务是不会被数据库主动回滚的。 隔离：如果发现数据不符合数据库隔离级别，当前事务会出错并回滚。相比锁被回滚可能性较大，需要程序有出错重试的步骤。 @Transactional注解的timeout参数 timeout事务的超时时间，默认值为-1,。如果超过该时间限制但事务还没有完成，则自动回滚事务。 方法抛出异常，事务被回滚，可能是SQL执行时间过长的异常，也可能是TransactionTimedOutException 从方法执行开始计算，每个SQL执行前检查一次是否超时，方法全部执行完毕后不检查是否超时 Mybatis进阶复杂类的ORMapping和主子表的同时数据插入#{}可转义 ${} 不可转义（可能导致sql注入） 使用TypeHandler处理枚举、数组、JSON等特殊类型EnumTypeHandler vs EnumOrdinalTypeHandler EnumTypeHandler存储的是对应类的名字，可以存储成一个字符串 EnumOrdinalTypeHandler存储的是枚举类型的顺序 ArrayTypeHandler自定义JsonTypeHandler Spring Security安全控制的层级 基于URL的控制 基于方法的控制 程序内 配置Spring Security12345678910111213141516171819@Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled = true, jsr250Enabled = false)public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; private final static Log log = LogFactory.getLog(WebSecurityConfig.class); @Override protected void configure(HttpSecurity httpSecurity) throws Exception &#123; if (log.isTraceEnabled()) &#123; log.trace(&quot;configure httpSecurity...&quot;); &#125; //默认的spring-security配置会让所有的请求都必须在已登录的状况下访问；下面这段代码禁止了这种操作。 httpSecurity.csrf().disable() .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and() .authorizeRequests().anyRequest().permitAll(); &#125;&#125; Spring Security 注解@EnableGlobalMethodSecurity(prePostEnable=true, securedEnable=true, jsr250Enabled=true)prePostEnable=true: @PreAuthorize @PostAuthorize @PreFilter @PostFiltersecuredEnable=true: @Securedjsr250Enable: @RolesRequied (JSR250) @PreAuthorize @PostAuthorize 中常用的表达式 hasRole(‘user’, ‘admin’) hasAnyRole(‘user’, ‘admin’) hasAuthority(‘query’, ‘update’) hasAnyAuthority(‘query’, ‘update’) permitAll denyAll principal, authentication 当前用户 Role vs Authorization ROLE_开头则是role JSR250 RolesAllowed全部要求是role Spring EL中hasRole也要求是role hasAuthority则不用ROLE_开头 Controller内获取当前用户12345public Object doSomething(Authentication auth)&#123; User u = (User) auth.getPrincipal();&#125;或 Authentication auth = SecurityContextHolder.getContext().getAuthentication(); 启用Spring Security1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; OpenId 提供用户追踪方式 无需使用用户名密码登录 协议2.0版提供属性交换功能 目前已经很少使用 OAuth开放授权 目前是OAuth2.0 2.0不兼容1.0 密码无需告诉第三方 为用户提供一个令牌，允许通过令牌访问资源 OAuth 2.0 Grant Types 授权码模式 Authorization Code 简化模式 Implicit 密码模式 Password 客户端模式 Client Credentials Refresh Token JWT JSON Web Token 三部分：Header、Playload、Verify Signature Header：头部信息，声明类型和加密算法 Playload：载荷 Verify Signature：签名，用于验证头部和载荷部分是否被修改过 JWT的加密方式 HMAC 共用一个秘钥 SHA256 公钥私钥分开 生成JWT和验证JWT的jar12345&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt; 网站：https://github.com/auth0/java-jwt Spring Async, Scheduling &amp; CacheSpring Async 异步执行配置：@EnableAsync (@SpringBootApplication 那里)使用：@Async （方法上）@Async方法返回值： void Future 其他类型一律返回null；遇到int/double/float/boolean基本类型，执行时会抛出异常：AopInvocationException; Spring Scheduling使用： @EnableScheduling 注解启用Scheduling 方法上加@Scheduled注解，方法会按照参数定期执行@Scheduled 参数： cron 值为字符串 zone 设置时区 fixedDelay (单位毫秒)，每次方法执行完毕后，休息固定时间后再次启动 fixedRate (单位毫秒)按照固定频率启动执行-initialDelay (单位毫秒)，和上面三个参数搭配使用，首次执行延时 集群/负载均衡环境 独立出来一个application运行scheduling task 使用：Quartz Scheduler Spring Cache缓存： 利用java程序中的变量（简单；集群环境中多个实例无法同步） 缓存服务器（Memcached，Redis）Spring中通过注解使用缓存 @EnableCaching启用缓存注解 @Cacheable @CacheEvict @CachePut @CacheConfig 使用 Redis 缓存服务POM中加入依赖 1234&lt;dependecy&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; application.yml 中加入配置 1234567891011spring: cache: redis: time-to-live: 3306 redis: host: localhost port: 6379 pool: max-active: 5 max-idle: 10 max-wait: 10000 Websocket &amp; JMSWebsocket 全双工通道，数据双向传输 浏览器和服务器之间的持久性的连接 比轮询/长轮询大幅节省资源 使用80/443等HTTP端口 ws://example.com/wsapi wss://secure.example.com/ IE10以上浏览器支持 JMS Java Message Service – Java消息服务 在两个应用程序或者分布式服务之间提供异步消息通讯 应用间解耦 企业应用集成中应用较多 消息服务器很多，Apache ActiveMQ是比较常见的一个 JMS消息模式 点对点（P2P）：每个消息有一个生产者一个消费者 发布者/订阅者（Pub/Sub）:每个消息一个生产者、多个消费者 安装ActiveMQ 配置pom文件 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;&lt;/dependency&gt; 配置application.yml 123spring: activemq: broker-url: tcp://127.0.0.1:61616 @EnableJms 注解 部署Spring Boot项目Spring Profile 和配置日志记录框架 可以设置不同的配置参数 可以设置不同的bean的装载 Active Profile 同时可以有多个被激活的profile 有active和default两个概念 如果没有设置active，则spring使用设置的default，如果没有声明default，则使用那些无显示指定的作为default 生产环境架构性能调优 前端：数据缓存；加载顺序；显示顺序；预先加载； NGINX: 设置客户端缓存；数据压缩传输；HTTP2.0 应用：优化算法；优化SQL（慢SQL）；避免N+1查询；异步操作；使用缓存；不常修改数据的静态化；集群； 数据库：索引和统计信息；优化表结构；冗余列和计算列；表拆分；分区表；统计慢SQL（提供程序）；SQL优化建议；升级硬件； 以服务程序运行（ubuntu）杂项在 Spring Boot 项目中使用Servlet,Filter,Listener等Servlet 1234@WebServlet(name=&quot;QrcodeServlet&quot;, urlPatterns=&quot;/servlet/qrcode&quot;)public class QrcodeServlet extends HttpServlet implements Serializable&#123; &#125; Filter 1234@WebFilterpublic class LogFilter implements Filter &#123; &#125; @ServletComponentScan 注解@ComponentScan Autowired 的加载规则@Autowired 查找被注解的变量类型，找到所有此类型的构建或此类型子类的构建。 如果一个也没有找到，看required参数，false则用null，true则失败（默认）。 如果仅找到一个，则装载这个构件。 如果找到多个，且只有一个有@Primary注解，使用Primary的。 如果不符合上述条件，失败。 @Autowired @Qualifier 如果属性既有Autowired注解又有Qualifier注解 在构件中查找名字为Qualifier中指定的名字的注解。 在构件上指定名字的方法有两个，@Service(“这里写名字”)，@Qualifier(“这里写名字”)。 API 的版本客户端传递版本信息方式 URL RequestHeader URL 部署，通过修改NGINX配置，不同域名，不同前缀。 修改application.yml中的contextPath，server.servlet.contextPath:/tutorial-v2 修改@RequestMapping中的参数，例如，@RequestMapping(“/v1/tvseries”) 增加request的参数，例如：/tvseries?version=2 Request Header 自定义request header，例如：Version:2 使用Accept Accept:application/vnd.tutorial.v2 + json 自定义 RequestMappingHandlerMapping 自定义ApiVersion注解 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping 定制Spring REST的错误返回信息Controller中单独处理 把返回值改成ResponseEntity T为要返回的内容 通过ResponseEntity来设置返回的HttpResponse状态码 全局的异常处理 12345678@RestControllerAdvicepublic class ExceptionHandler &#123; @ExceptionHandler(Throwable.class) @ResponseBody ResponseEntity&lt;Object&gt; handleControllerException(Throwable ex, WebRequest request) &#123; //处理异常，并设置给客户端反馈的信息 &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[赠药山高僧惟俨二首]]></title>
    <url>%2F2018%2F12%2F23%2F%E8%B5%A0%E8%8D%AF%E5%B1%B1%E9%AB%98%E5%83%A7%E6%83%9F%E4%BF%A8%E4%BA%8C%E9%A6%96%2F</url>
    <content type="text"><![CDATA[练得身形如鹤形，千株松下两函经。我来问道无馀说，云在青霄水在瓶。 选得幽居惬野情，终年无送亦无迎。有时直上孤峰顶，月下披云啸一声。]]></content>
      <categories>
        <category>Tao</category>
      </categories>
      <tags>
        <tag>Tao</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
