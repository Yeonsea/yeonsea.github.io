<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Đinh Giang</title>
  
  <subtitle>人生は意味が、唯一の生活をすることができますが见つかりました楽しいこと、 のような花が见つかる、あなた様と私が见つかりました</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yeonsea.club/"/>
  <updated>2019-08-25T10:42:32.070Z</updated>
  <id>http://yeonsea.club/</id>
  
  <author>
    <name>J</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于分布式系统的稳定性</title>
    <link href="http://yeonsea.club/2019/08/25/%E5%85%B3%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    <id>http://yeonsea.club/2019/08/25/关于分布式系统的稳定性/</id>
    <published>2019-08-25T10:40:48.000Z</published>
    <updated>2019-08-25T10:42:32.070Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="系统稳定性"><a href="#系统稳定性" class="headerlink" title="系统稳定性"></a>系统稳定性</h1><h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><p>信息</p><ul><li>堆栈信息</li><li>访问用户 IP、请求 URL、应用响应时间</li><li>内存回收信息</li><li><p>自定义信息</p></li><li><p>通过异常堆栈，可以定位到谁宕机了</p></li><li>产生问题的程序行，对异常进行修复</li><li>访问 IP 和请求参数，排查是否遭到攻击，以及攻击的形式</li><li>应用的响应时间、垃圾回收以及系统 load 来判断系统负载，是否要增加机器</li><li>线程 dump，判断是否死锁及线程阻塞的原因</li><li>应用的 GC 日志，对系统代码和 JVM 内存参数进行优化，减少 GC 次数与 stop the world 时间，优化应用响应时间</li></ul><h2 id="集群监控"><a href="#集群监控" class="headerlink" title="集群监控"></a>集群监控</h2><p>木通原理</p><h3 id="监控指标"><a href="#监控指标" class="headerlink" title="监控指标"></a>监控指标</h3><ul><li>load：linux 中，可以通过 top,uptime来查看系统load值，系统load定义为特定时间间隔内运行队列中的平均线程数。</li><li>cpu 利用率</li><li>磁盘剩余空间</li><li>网络 traffic</li><li>磁盘 IO</li><li>内存使用</li><li>qps    query per second</li><li>rt    response time</li><li>select/ps</li><li>update/ps、delete/ps</li><li>GC    JVM 虚拟机开发团队一直致力于消除或者减少工作线程因内存回收而导致的停顿，用户线程的停顿时间在不断地缩短，但是仍然没办法完全消除</li></ul><h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><blockquote><p>对于自治的分布式系统而言，一般都有一整套的集群心跳检测机制，能够实时地移除掉宕机的 Slave，避免路由规则将任务分配给已宕机的机器来处理。<br>而如果是 Master 宕机，集群能够自动地进行 Master 的选举，从而避免由 Master 宕机而导致整个集群不能提供服务的情况发生，这一类系统，如 ZooKeeper，便是一个很好的典范。也有一部分系统可以通过外部干预，使备份机器 stand by，或者是双机互为备份，以实现故障切换，如 MySQL、Nginx等，以避免单点故障的发生。</p></blockquote><ul><li>ping</li><li>应用层检测    curl 定时访问应用中预留的自检 url</li><li>业务检测    可在 response 的 header 中约定一个值，来标识返回的结果是否正常</li></ul><h3 id="容量评估及应用水位"><a href="#容量评估及应用水位" class="headerlink" title="容量评估及应用水位"></a>容量评估及应用水位</h3><p>当前水位 = 当前总 qps / （单台机器极限 x 机器数）x 100%</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><h3 id="流量控制实施"><a href="#流量控制实施" class="headerlink" title="流量控制实施"></a>流量控制实施</h3><p>多个维度</p><ul><li>对系统的总并发请求数进行限制 - 可以很好地控制系统的负载，避免出现流量突增将系统压垮的情况</li><li>限制单位时间内的请求次数（如限制qps） - 限制调用频次，防止某个外部调用的流量突增影响到服务本身的稳定性</li><li>通过白名单机制来限制每一个接入系统调用的频率等</li></ul><p>超载的部分流量</p><ul><li>直接返回，现实系统繁忙</li><li>通过单机内存队列来进行有限的等待</li><li>通过分布式消息队列来将用户的请求异步化</li></ul><h3 id="服务稳定性"><a href="#服务稳定性" class="headerlink" title="服务稳定性"></a>服务稳定性</h3><h4 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h4><p>服务消费日志</p><h4 id="优雅降级"><a href="#优雅降级" class="headerlink" title="优雅降级"></a>优雅降级</h4><blockquote><p>对于调用超时的非核心服务，可以设定一个阈值，如果调用超时的次数超过这个阈值，便自动将该服务降级。此时服务调用者跳过对该服务的调用，并指定一个休眠的时间点，当时间点过了以后，再次对该服务进行重试，如果服务恢复，则取消降级，否则继续保持该服务的降级状态，直到所依赖的服务故障恢复。</p></blockquote><h4 id="服务分级"><a href="#服务分级" class="headerlink" title="服务分级"></a>服务分级</h4><h4 id="开关"><a href="#开关" class="headerlink" title="开关"></a>开关</h4><blockquote><p>当系统负载较高，即将突破警戒水位时，如何通过实时地屏蔽一些非核心链路的调用来降低系统的负载呢？这时需要系统预先定义一些开关控制程序的服务提供策略。开关通过修改一些预先定义好的全局变量，来控制系统的关键路径和逻辑。</p></blockquote><h4 id="应急预案"><a href="#应急预案" class="headerlink" title="应急预案"></a>应急预案</h4><h3 id="高并发系统设计"><a href="#高并发系统设计" class="headerlink" title="高并发系统设计"></a>高并发系统设计</h3><blockquote><p>高并发系统与普通系统设计的区别在于，既要保障系统的可用性和可扩展性，又要兼顾数据的一致性，还要处理多线程同步的问题。<br><em>任何细微问题，都有可能在高并发环境下被无限地放大，直至系统宕机</em></p></blockquote><h4 id="操作原子性"><a href="#操作原子性" class="headerlink" title="操作原子性"></a>操作原子性</h4><blockquote><p>原子操作指的是不可分割的操作，它要么执行成功，要么执行失败，不会产生中间状态。<br>原子操作也是一些常见的多线程程序bug的源头。<br>并发相关的问题对于测试来说，并不是每次都能重现，因此处理起来十分棘手。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="调优" scheme="http://yeonsea.club/tags/%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>Writing &amp; Publishing your First NPM Package</title>
    <link href="http://yeonsea.club/2019/08/23/Writing&amp;Publishing_your_First_NPM_Package/"/>
    <id>http://yeonsea.club/2019/08/23/Writing&amp;Publishing_your_First_NPM_Package/</id>
    <published>2019-08-23T05:54:11.000Z</published>
    <updated>2019-08-24T12:16:00.779Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Just-do-it"><a href="#Just-do-it" class="headerlink" title="Just do it"></a>Just do it</h1><h2 id="NPM-account"><a href="#NPM-account" class="headerlink" title="NPM account"></a>NPM account</h2><ol><li><p>Create an NPM account if you don’t yet have one<br><a href="https://www.npmjs.com/" title="npm js" target="_blank" rel="noopener">npm js</a>. </p></li><li><p>Open terminal and …</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm adduser</span><br></pre></td></tr></table></figure></li></ol><p>** If you use taobao mirror, it will show 403 Forbidden. Then …<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry # show the current login source</span><br><span class="line">npm config set registry=http://registry.npmjs.org # change to the npmjs</span><br><span class="line">npm login # relogin</span><br></pre></td></tr></table></figure></p><h2 id="Create-a-component"><a href="#Create-a-component" class="headerlink" title="Create a component"></a>Create a component</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.exports.*** = ***</span><br></pre></td></tr></table></figure><h2 id="Create-a-new-repository-on-GitHub"><a href="#Create-a-new-repository-on-GitHub" class="headerlink" title="Create a new repository on GitHub"></a>Create a new repository on GitHub</h2><h2 id="Init-and-publish"><a href="#Init-and-publish" class="headerlink" title="Init and publish"></a>Init and publish</h2><p>Under the component, open the terminal</p><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">code .</span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin https://github.com/***/***.git</span><br><span class="line">git push -u origin master</span><br><span class="line">sudo git push -u origin master</span><br></pre></td></tr></table></figure><h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure><h2 id="Use-it"><a href="#Use-it" class="headerlink" title="Use it!"></a>Use it!</h2><p>create a new project<br>import<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i ** --save</span><br><span class="line">parser index.html</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Front-end" scheme="http://yeonsea.club/tags/Front-end/"/>
    
  </entry>
  
  <entry>
    <title>西尔维斯特-矩阵</title>
    <link href="http://yeonsea.club/2019/08/19/%E8%A5%BF%E5%B0%94%E7%BB%B4%E6%96%AF%E7%89%B9-%E7%9F%A9%E9%98%B5/"/>
    <id>http://yeonsea.club/2019/08/19/西尔维斯特-矩阵/</id>
    <published>2019-08-19T09:56:10.000Z</published>
    <updated>2019-08-20T09:38:57.123Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>西尔维斯特（James Joseph Sylvester, 1814~1897）</p><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>数量可以用二维数据表格来展示  </p><p>打猎得到的各种猎物和税金之间的关系可以用两个二维数据表格来表示  </p><table><thead><tr><th>00</th><th>兔子</th><th>鹿</th><th>野猪</th></tr></thead><tbody><tr><td>西尔维斯特</td><td>5只</td><td>1只</td><td>0只</td></tr><tr><td>东健</td><td>2只</td><td>0只</td><td>1只</td></tr><tr><td>小彬</td><td>0只</td><td>0只</td><td>2只</td></tr></tbody></table><table><thead><tr><th>猎物</th><th>税金</th></tr></thead><tbody><tr><td>兔子</td><td>20韩元</td></tr><tr><td>鹿</td><td>50韩元</td></tr><tr><td>野猪</td><td>100韩元</td></tr></tbody></table><p>运动器械和自行车的价格与需要购买的数量之间的关系可以用两个二维数据表格来表示  </p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>把数字或字母在括号内排列成二维数据表格就叫作矩阵。矩阵的各个数字或字母叫作元素。横向叫作行，纵向叫作列。  </p><p>矩阵的行数为m，列数为n时，矩阵的大小为m*n，行数和列数数目相等的矩阵叫作方块矩阵。  </p><p>元素都为0的矩阵叫作零矩阵；主对角线元素都为1，其余元素都是0的矩阵叫作单位矩阵。  </p><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>把方程组变成矩阵来解，可以进行一下运算：  </p><ol><li>某一行可以乘以一个常数：相当于一个方程的两边同时乘以一个常数。</li><li>某一行乘以一个常数后可以与另一行相加：相当于一个方程的两边同时乘以一个常数后再与另一个方程相加。</li><li>行与行可以对调：方程的顺序对调后，解不变。</li></ol><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>方程组<br>$$<br>\begin{cases}<br>   ax+by=p \\<br>   cx+dy=q<br>\end{cases}<br>$$<br>用矩阵表达式如下<br>$$<br>\begin{pmatrix}<br>   a &amp; b \\<br>   c &amp; d<br>\end{pmatrix}<br>\begin{pmatrix}<br>   x \\<br>   y<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>   p \\<br>   q<br>\end{pmatrix}<br>$$<br>可以简单表示为<br>$$<br>\begin{pmatrix}<br>   a &amp; b &amp;: &amp;p  \\<br>   c &amp; d &amp;: &amp;q<br>\end{pmatrix}<br>$$</p><hr><p>矩阵的某一行乘以一个常数后形成的新矩阵，求出的解是同一个方程组的解。  </p><p>矩阵的某一行乘以一个常数后与另一行相加形成的新矩阵，求出的解是同一个方程组的解。  </p><p>方程组构成的矩阵，行与行可以对调，对调后方程组的解不变。  </p><h1 id="5"><a href="#5" class="headerlink" title="5"></a>5</h1><p>可以将下面的三元一次方程组变成矩阵来解<br>$$<br>\begin{cases}<br>   a_{11}x+a_{12}y+a_{13}z=p \\<br>   a_{21}x+a_{22}y+a_{23}z=q \\<br>   a_{31}x+a_{32}y+a_{33}z=r<br>\end{cases}<br>$$</p><p>$$<br>\begin{pmatrix}<br>   a_{11} &amp; a_{12} &amp; a_{13} &amp;: &amp;p  \\<br>   a_{21} &amp; a_{22} &amp; a_{23} &amp;: &amp;q  \\<br>   a_{31} &amp; a_{32} &amp; a_{33} &amp;: &amp;r<br>\end{pmatrix}<br>$$</p><h1 id="6"><a href="#6" class="headerlink" title="6"></a>6</h1><p>两个矩阵相等是指两个矩阵中所有的元素对应相等。  </p><p>两个矩阵之间对应的元素相加，可以实现两个矩阵之间的加法运算。</p><p>一个矩阵的各元素可以乘以某个常数。  </p><p>两个矩阵之间对应的元素相减，可以实现两个矩阵之间的减法运算。</p><h1 id="7"><a href="#7" class="headerlink" title="7"></a>7</h1><p>两个矩阵相乘，前面矩阵的列数要与后面矩阵的行数相等。这时乘积的大小由前面矩阵的行数和后面矩阵的列数决定。即<br>$$<br>A_{m×n}B_{n×t}=C_{m×t}<br>$$</p><hr><p>前面矩阵的第i行和后面矩阵的第j列的各对应元素的乘积之和，构成乘积矩阵中的(i, j)元素。  </p><p>寻找日常生活中可以用矩阵乘积表示的问题。</p><h1 id="8"><a href="#8" class="headerlink" title="8"></a>8</h1><p>可求出方块矩阵<br>$$<br>\begin{pmatrix}<br>   a &amp; b \\<br>   c &amp; d<br>\end{pmatrix}<br>$$<br>的逆矩阵  </p><p>$$<br>{\begin{pmatrix}<br>   a &amp; b \\<br>   c &amp; d<br>\end{pmatrix}}^{-1}<br>= {1 \over ad - bc}<br>\begin{pmatrix}<br>   d &amp; -b \\<br>   -c &amp; a<br>\end{pmatrix}<br>(ad-bc \ne 0)<br>$$</p><hr><p>利用逆矩阵求二元一次方程组<br>$$<br>\begin{cases}<br>   ax+by=p \\<br>   cx+dy=q<br>\end{cases}<br>$$<br>的解。首先像下面这样用矩阵表示方程：<br>$$<br>\begin{pmatrix}<br>   a &amp; b \\<br>   c &amp; d<br>\end{pmatrix}<br>\begin{pmatrix}<br>   x \\<br>   y<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>   p \\<br>   q<br>\end{pmatrix}<br>$$<br>然后式子两边靠左的位置写上<br>$$<br>\begin{pmatrix}<br>   a &amp; b \\<br>   c &amp; d<br>\end{pmatrix}<br>$$<br>的逆矩阵，再做乘法运算。<br>$$<br>\begin{pmatrix}<br>   x \\<br>   y<br>\end{pmatrix}<br>=<br>{\begin{pmatrix}<br>   a &amp; b \\<br>   c &amp; d<br>\end{pmatrix}}^{-1}<br>\begin{pmatrix}<br>   p \\<br>   q<br>\end{pmatrix}<br>$$<br>--</p><p>$$<br>\begin{pmatrix}<br>   x \\<br>   y<br>\end{pmatrix}<br>=<br>{1 \over ad - bc}<br>\begin{pmatrix}<br>   d &amp; -b \\<br>   -c &amp; a<br>\end{pmatrix}<br>\begin{pmatrix}<br>   p \\<br>   q<br>\end{pmatrix}<br>=<br>{1 \over ad - bc}<br>\begin{pmatrix}<br>   dp-bq \\<br>   -cp+aq<br>\end{pmatrix}<br>(ad-bc \ne 0)<br>$$<br>--</p><p>$$<br>x={dp-bq \over ad-bc}, y={-cp+aq \over ad-bc}<br>$$</p><h1 id="9"><a href="#9" class="headerlink" title="9"></a>9</h1><p>研究是否可以用矩阵表示身边的实际问题。思考如何确定一个矩阵的各个元素。  </p><p>利用矩阵解决问题，预测未来</p><p><strong>各列元素的和等于1的矩阵用俄国数学家马尔可夫的名字命名为马尔可夫转移矩阵。</strong><br>这个矩阵经常用来表示某种变化的概率，某个地区的人口变化、市场经济的版图变化等，我们周围的各种变化都可以用这样的矩阵表示，帮助我们有效地解决问题。  </p><p>老鼠房间概率<br>城市邻接矩阵  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Math" scheme="http://yeonsea.club/categories/Math/"/>
    
    
      <category term="Basic" scheme="http://yeonsea.club/tags/Basic/"/>
    
  </entry>
  
  <entry>
    <title>布隆过滤器</title>
    <link href="http://yeonsea.club/2019/03/12/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>http://yeonsea.club/2019/03/12/布隆过滤器/</id>
    <published>2019-03-12T01:17:12.000Z</published>
    <updated>2019-08-20T10:11:51.564Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><h2 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器"></a>什么是布隆过滤器</h2><p>布隆过滤器是一种基于概率进行验重的数据结构。它的基本原理是：小概率事件不容易同时发生。</p><p>布隆过滤器使用多个哈希函数把同一个字符串转换成多个不同的哈希值，并记录这些哈希值的特征。下次再面对一个字符串时，布隆过滤器再次使用这些哈希函数把这个字符串转换为多个哈希值。如果这个哈希值全部符合原先那个字符串对应的各个哈希值的特征，则认为这两个字符串是相同的。</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希算法不是一种加密算法，而是一种不可逆的摘要算法。<br>不同的哈希函数可实现不同的哈希算法。<br>使用同一个哈希算法，能够把同一个字符串转成同一个哈希值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">code = <span class="string">'hello'</span></span><br><span class="line">result = hashlib.sha256(code.encode()).hexdigest()</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>结果是一个十六进制的_数_</p><h2 id="布隆过滤器的原理"><a href="#布隆过滤器的原理" class="headerlink" title="布隆过滤器的原理"></a>布隆过滤器的原理</h2><ol><li>假设K个哈希函数，对同一个字符串计算哈希值，得到K个完全不同的哈希值。</li><li>让这K个哈希值同时除以一个数M，就可以得到K个余数。</li><li>对于一个新的字符串，重复这个过程，如果新字符串获得的K个余数与原来的字符串对应的K个余数完全相同，那么就可以说，这两个字符串”很有可能”是同一个字符串。</li></ol><p>$$<br>1-(1-e^{\frac{-KN}{M}})^{K}<br>$$</p><h2 id="如何压缩数据容量"><a href="#如何压缩数据容量" class="headerlink" title="如何压缩数据容量"></a>如何压缩数据容量</h2><p>采用二进制保存数字</p><h2 id="布隆过滤器与Redis结合"><a href="#布隆过滤器与Redis结合" class="headerlink" title="布隆过滤器与Redis结合"></a>布隆过滤器与Redis结合</h2><p>使用Redis字符串的位操作，记录K个余数的位置即可。</p><h2 id="布隆过滤器的弊端"><a href="#布隆过滤器的弊端" class="headerlink" title="布隆过滤器的弊端"></a>布隆过滤器的弊端</h2><p>布隆过滤器只能单向验证重复。<br>随着Redis字符串对应的二进制位越来越多的为被设置为1，布隆过滤器误报的概率越来越大，因为可能其它多个字符串对应的二进制位中越来越多的位被设置为1，其中K个值刚好和一个新来的字符串的K个余数重合。<br>提前规划好数据规模与容忍的误报率。  </p><blockquote><p>最多需要对 n 个字符串进行验证重复操作，能够容忍的最大误报率为 p，那么，布隆过滤器将会使用到的二进制位的数量为：</p></blockquote><p>$$<br>m = -\frac{n\ln{p}}{\ln{2}^{2}}<br>$$</p><blockquote><p>哈希函数的个数为：</p></blockquote><p>$$<br>k = \frac{m}{n}\ln{2}<br>$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Web" scheme="http://yeonsea.club/categories/Web/"/>
    
    
      <category term="Web" scheme="http://yeonsea.club/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>用 Spring Boot 编写 RESTful API</title>
    <link href="http://yeonsea.club/2018/12/23/%E7%94%A8SpringBoot%E7%BC%96%E5%86%99RESTfulAPI/"/>
    <id>http://yeonsea.club/2018/12/23/用SpringBoot编写RESTfulAPI/</id>
    <published>2018-12-23T12:17:58.000Z</published>
    <updated>2018-12-23T12:31:19.484Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2018/12/23/用SpringBoot编写RESTfulAPI/../用SpringBoot编写RESTfulAPI/spring-boot-project-logo.png"></p><h2 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h2><p><a href="https://study.163.com/course/courseMain.htm?courseId=1005213034" target="_blank" rel="noopener">课程</a></p><h2 id="开始一个最简单的RESTFul-API项目"><a href="#开始一个最简单的RESTFul-API项目" class="headerlink" title="开始一个最简单的RESTFul API项目"></a>开始一个最简单的RESTFul API项目</h2><h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><p>Representational State Transfer</p><p>所有的东西都是资源，所有的操作都是通过对资源的增删改查（CRUD）实现</p><p>对资源的增删改查对应对URL的操作（POST,DELETE,PUT,GET）</p><p>无状态的</p><h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><p>大量使用注解，减少配置，无需配置XML<br>自带嵌入式web服务器</p><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><p>pom.xml文件是Maven项目的配置文件<br>几个常用的Maven命令（在pom.xml同级目录下运行）<br>mvn test 编译并运行测试用例<br>mvn spring-boot:run 运行spring-boot项目<br>mvn package 打包项目<br>mvn clean 可以和其它命令一起使用，例如mvn clean package</p><h3 id="日期型转JSON格式"><a href="#日期型转JSON格式" class="headerlink" title="日期型转JSON格式"></a>日期型转JSON格式</h3><p>可以在属性上增加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@JsonFormat(timezone=&quot;GMT+8&quot;, pattern=&quot;yyyy-MM-dd&quot;)</span><br></pre></td></tr></table></figure></p><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@JsonFormat（shape=JsonFormat.Shape.NUMBER）</span><br></pre></td></tr></table></figure><p>全局修改可以在application.yml  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:  </span><br><span class="line">  jackson:  </span><br><span class="line">    date-format: yyyy-MM-dd #如果使用字符串表示，用这行设置格式  </span><br><span class="line">    timezone: GMT+8  </span><br><span class="line">    serialization:   </span><br><span class="line">      write-dates-as-timestamps: true #使用数值timestamp表示日期</span><br></pre></td></tr></table></figure><h2 id="RestController详解"><a href="#RestController详解" class="headerlink" title="RestController详解"></a>RestController详解</h2><h3 id="热部署（Hot-Swapping）"><a href="#热部署（Hot-Swapping）" class="headerlink" title="热部署（Hot Swapping）"></a>热部署（Hot Swapping）</h3><p>pom中加入devtools</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h3><p>Commons-logging or SLF4j</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private static final Log log = LogFactory.getLog(Xxx.class);</span><br><span class="line">private static final Logger log = LoggerFactory.getLogger(Xxx.class);</span><br></pre></td></tr></table></figure><p>日志级别：TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL<br>application.yml配置日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  file: target/app.log</span><br><span class="line">  level: </span><br><span class="line">    ROOT: WARN</span><br><span class="line">    cn.devmgr: TRACE</span><br></pre></td></tr></table></figure></p><h3 id="命令行工具CURL"><a href="#命令行工具CURL" class="headerlink" title="命令行工具CURL"></a>命令行工具CURL</h3><p>测试工具<br><a href="https://www.getpostman.com/" target="_blank" rel="noopener">postman</a></p><h3 id="在RestController中获取各种相关信息的方法"><a href="#在RestController中获取各种相关信息的方法" class="headerlink" title="在RestController中获取各种相关信息的方法"></a>在RestController中获取各种相关信息的方法</h3><table><thead><tr><th>内容</th><th>获取方法</th></tr></thead><tbody><tr><td>URL中路径的一部分</td><td>首先需要在RequestMapping做映射，之后在方法中可以通过注解使用映射的变量。可以写多个，@PutMapping(“/{id}/characters/{cId}”)，还可以使用正则表达式限制类型（不符合要求会返回4xx的错误信息，表示请求参数有问题）此例子表示id必须是数字：@PutMapping(“/{id:\\d+}”)</td></tr><tr><td>POST方法传递过来的JSON</td><td>给参数前增加@RequestBody注解，Spring会自动把POST的Request Body部分的JSON转换成方法声明的类。如果转化失败会返回4xx错误，表示请求参数有问题。</td></tr><tr><td>POST方法传递的是表单数据</td><td>首先声明传入的是application/x-wwww-form-urlencoded的格式，可在RequestMapping增加consumes参数，@PostMapping(value=”/tvseries”, consumes=MediaType.APPLICATION_FORM_URLENCODED_VALUE)，在方法上增加参数，参数使用@RequestParam注解即可，public Object insert(@RequestParam(value=”name”, required=false) String name)，凡是可以通过HttpServletRequest.getParameter(String)方法取到的值，含表单提交的、QueryString附带的，都可以使用@RequestParam注解得到。默认是request=true。</td></tr><tr><td>QueryString的参数</td><td>使用@RequestParam注解，通过参数获得,例如：public Object query(@RequestParam(value=”page”, required=false) Integer page)</td></tr><tr><td>Request Header</td><td>可以使用@Requestheader注解获取Request的头信息,例如public ResultJSON editCompany(@RequestHeader(“user-agent”) String userAgent) 注意：@RequestHeader后面的头名字不区分大小写，但RequestParam, PathVariable等是区分的。如果RequestHeader后面不写参数，会用后面的变量名替代。</td></tr><tr><td>获取cookie值</td><td>使用cookieValue注解，和其它类似，除非为了兼容老现有客户端，新API里不建议用cookie。</td></tr><tr><td>获取当前的Request Response</td><td>直接写参数，例如：public Object doSomething(HttpServletRequest request, HttpServletResponse response)</td></tr><tr><td>获取当前用户</td><td>直接在方法上增加参数，类型为org.springframework.security.core.Authentication, 例如：public TvSeries deleteOne(Authentication auth)，参数auth内会存储有当前的用户信息。</td></tr><tr><td>文件上传</td><td>首先要设置consumes为multipart/form-data，@PostMapping(value=”/files”, consumes=MediaType.MULTIPART_FORM_DATA_VALUE),在方法中写参数 public Map&lt;String, Object&gt; uploadFile(@RequestParam(“file”) MultipartFile file)。在方法中可以直接使用MultipartFile中的流保存文件了。</td></tr></tbody></table><h3 id="对客户端传入数据的校验"><a href="#对客户端传入数据的校验" class="headerlink" title="对客户端传入数据的校验"></a>对客户端传入数据的校验</h3><p>原则：不要相信前端传过来的数据；尽量要前端少传递数据</p><p>Bean Validation: JSR303, Hibernate Validator</p><p>Bean Validation 注解：<br>@Null<br>@NotNull<br>@Min<br>@Max<br>@Size<br>@Past  验证Date<br>@Future<br>@AssertTrue  验证Boolean<br>@AssertFalse<br>@Valid 级联验证注解</p><table><thead><tr><th>类型</th><th>注解</th></tr></thead><tbody><tr><td>任何类型</td><td>NULL, NotNull</td></tr><tr><td>布尔型</td><td>AssertTrue, AssertFalse</td></tr><tr><td>字符串</td><td>NotBlank, Pattern, Size, Email, DecimalMin, Digits</td></tr><tr><td>数值</td><td>DecimalMax, DecimalMin, Digits, Max, Min, NegativeOrZero, Positive, PositiveOrZero</td></tr><tr><td>集合、Map、List</td><td>NotEmpty, Size</td></tr><tr><td>日期</td><td>Future, Past, FutureOrPresent, PastOrPresent</td></tr></tbody></table><blockquote><p>以上注解都指Bean Validation 2.0 定义的注解，在javax.validation.constraints包下。Hibernate有些非JSR标准注解和上面的同名但package不同，功能会和上面这些有些细微差异。</p></blockquote><p>约束规则对子类依旧有效<br>groups参数  </p><ul><li>每个约束用注解都有一个groups参数</li><li>可接收多个class类型（必须是接口）</li><li>不声明groups参数是默认组javax.validation.groups.Default</li><li>声明了groups参数的会从Default组移除，如需加入Default组需要显示声明，例如@Null(groups={Default.class, Step1.class})</li></ul><p>@Valid vs @Validated</p><ul><li>@Valid是JSR标准定义的注解，只验证Default组的约束</li><li>@Validated是Spring定义的注解，可以通过参数来指定验证的组，例如：@Validation({Step1.class,Default.class})表示验证Step1和Default两个组的约束</li><li>@Valid可用在成员变量上，进行级联验证；@Validated只能用在参数上，表示这个参数需要验证<blockquote><p>参数中只用@Validated，通不过校验的参数，不会执行这个方法，加上BindingResult result ，参数通不过校验也会进入方法执行，校验结果会通过result参数传递进来。</p></blockquote></li></ul><p>手动验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 装载验证器</span><br><span class="line">@Autowired Validator validator;</span><br><span class="line">// 验证某个类，下面是执行默认的验证组，如果需要指定验证组，多传一个class参数</span><br><span class="line">Set&lt;ConstraintViolation&lt;?&gt;&gt; result = validator.validate(obj);</span><br><span class="line">// 通不过校验result的集合会有值，可以通过size()判断</span><br></pre></td></tr></table></figure><h2 id="在Spring-Boot项目中使用Mybatis"><a href="#在Spring-Boot项目中使用Mybatis" class="headerlink" title="在Spring Boot项目中使用Mybatis"></a>在Spring Boot项目中使用Mybatis</h2><h3 id="程序的层次结构"><a href="#程序的层次结构" class="headerlink" title="程序的层次结构"></a>程序的层次结构</h3><p>Web前端、App、小程序、其它系统等<br>Web控制层：@RestController @Controller<br>业务逻辑层：@Service<br>数据访问层：@Repository<br>@Component<br>数据库</p><p>PBF: Package by Feature 按功能划分<br>PBL: Package by Layer 按层次划分  </p><h3 id="相邻层次的数据传输"><a href="#相邻层次的数据传输" class="headerlink" title="相邻层次的数据传输"></a>相邻层次的数据传输</h3><ul><li>PO：Persistant Object 持久对象</li><li>DTO：Data Transfer Object 数据传输对象</li><li>VO：Value Object 或 View Object</li><li>POJO：Pure Old Java Object 或 Plain Ordinary Java Object</li><li>DO：Domain Object</li><li>BO：Business Object 处理业务逻辑</li><li>DAO：Data Access Object</li></ul><p>JavaBean:  </p><ul><li>有一个public的无参构造方法</li><li>属性private，且可以通过get、set、is（可以替代get，用在布尔型属性上）方法或遵循特定命名规范的其它方法访问</li><li>可序列化，实现Serializable接口</li></ul><p>POJO vs JavaBean:</p><ul><li>POJO比javabean更简单。POJO严格的遵守简单对象的概念，而一些JavaBean中往往会封装一些简单逻辑。</li><li>POJO主要用于数据的临时传递，它只能装载数据，作为数据存储的载体，不具有业务逻辑处理能力。</li><li>JavaBean虽然数据的获取与POJO一样，但是javabean当中可以有其他方法。</li></ul><p>几种简化方案：  </p><ul><li>一种POJO从web控制层到数据访问层</li><li>用JavaBean代替POJO</li><li>POJO的get,set写起来也麻烦，用public的field代替</li></ul><h3 id="添加Mybatis支持步骤"><a href="#添加Mybatis支持步骤" class="headerlink" title="添加Mybatis支持步骤"></a>添加Mybatis支持步骤</h3><ol><li>修改pom.xml，添加mybatis支持</li><li>修改application.yml添加数据库连接</li><li>修改启动类，增加@MappingScan(“package-of-mapping”)注解</li><li>添加Mybatis Mapping接口</li><li>添加Mapping对应的XML（可选）</li></ol><p>pom.xml中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.postgresql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>application.yml中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    dbcp2.validation-query: select 1</span><br><span class="line">    driverClassName: org.postgresql.Driver</span><br><span class="line">    url: jdbc:postgresql://127.0.0.1:5432/thedb?stringtype=unspecified</span><br><span class="line">    username: </span><br><span class="line">    password:</span><br></pre></td></tr></table></figure><h2 id="Spring-Boot-项目的单元测试"><a href="#Spring-Boot-项目的单元测试" class="headerlink" title="Spring Boot 项目的单元测试"></a>Spring Boot 项目的单元测试</h2><h3 id="Assert-JUnit的断言"><a href="#Assert-JUnit的断言" class="headerlink" title="Assert-JUnit的断言"></a>Assert-JUnit的断言</h3><ul><li>判断某条件是否为真 Assert.assertTrue(条件表达式)；</li><li>判断某条件是否为假 Assert.assertFalse(条件表达式)；</li><li>判断两个变量值是否相同 Assert.assertEquals(val1, val2);</li><li>判断两个变量值是否不相同 Assert.assertNotEquals(val1, val2);</li><li>判断两个数组是否相同 Assert.assertArrayEquals(数组1, 数组2)；</li><li>直接测试失败 Assert.fail()  Assert.fail(message)</li></ul><h3 id="Assert-vs-assert"><a href="#Assert-vs-assert" class="headerlink" title="Assert vs assert"></a>Assert vs assert</h3><ul><li>Assert是JUnit的断言类，全名是org.junit.Assert</li><li>Assert提供了很多静态方法，例如…</li><li>assert是java关键字，使用方法有两种，表达式为false时，jvm会退出；</li><li>assert关键字内表达式是否被检查成立依赖jvm的参数，默认是关闭的<blockquote><p>Java命令行参数：-ea (enableassertions)  -da (disableassertions 默认)</p></blockquote></li></ul><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>驱动模块</li><li>被测模块</li><li>桩模块 使用场景：替代尚未开发完毕的子模块；替代对环境依赖较大的子模块（例如数据访问层）；</li></ul><h3 id="mockito"><a href="#mockito" class="headerlink" title="mockito"></a>mockito</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mockito&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mockito-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="TDD"><a href="#TDD" class="headerlink" title="TDD"></a>TDD</h3><ul><li>Test Driven Development (测试驱动开发)</li><li>先写测试用例，后写实现代码</li><li>重构现有代码时特别好用<blockquote><p>RDD: Resume Driven Development</p></blockquote></li></ul><h2 id="在-Spring-中管理数据库事务"><a href="#在-Spring-中管理数据库事务" class="headerlink" title="在 Spring 中管理数据库事务"></a>在 Spring 中管理数据库事务</h2><h3 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h3><ul><li>name 当在配置文件中有多个TransactionManager,可以用该属性指定选择哪个事务管理器。</li><li>propagation 事务的传播行为，默认值为REQUIRED。</li><li>isolation 事务的隔离度，默认采用DEFAULT。</li><li>timeout 事务的超时时间，默认值为-1,。如果超过该时间限制但事务还没有完成，则自动回滚事务。</li><li>readOnly 指定事务是否为只读事务，默认值为false；为了忽略那些不需要事务的方法，比如读取数据，可以设置readOnly为true。</li><li>rollbackFor 指定能够触发事务回滚的异常类型。</li><li>noRollbackFor 指定的异常类型，不回滚事务<blockquote><p>1.noRollbackFor或子类；2.rollbackFor或子类；3.throws定义的异常或子类；4.其它异常；5.无异常</p></blockquote></li></ul><h3 id="Transactional-propagation-xx"><a href="#Transactional-propagation-xx" class="headerlink" title="@Transactional(propagation=xx)"></a>@Transactional(propagation=xx)</h3><ol><li>propagation.REQUIRED 如果有事务，那么加入事务，没有的话新建一个（默认）</li><li>propagation.NOT_SUPPORTED 容器不为这个方法开启事务</li><li>propagation.REQUIRED_NEW 不管是否存在事务，都创建一个新的事务，原来的挂起，新的执行完毕，继续执行老的事务</li><li>propagation.MANDATORY 必须在一个已有的事务中执行，否则抛出异常</li><li>propagation.NEVER 必须在一个没有的事务中执行，否则抛出异常（与propagation.MANDATORY相反）</li><li>propagation.SUPPORTS 如果其它bean调用这个方法，在其它bean中声明事务，那就用事务，如果其它bean没有声明事务那就不用事务</li><li>propagation.NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与propagation.REQUIRED类似的操作</li></ol><h3 id="Transactional-isolation-xx"><a href="#Transactional-isolation-xx" class="headerlink" title="@Transactional(isolation=xx)"></a>@Transactional(isolation=xx)</h3><ol><li>Isolation.READ_UNCOMMITTED 读未提交数据 （脏读、不可重复读、幻读）</li><li>Isolation.READ_COMMITTED 读已提交数据（不可重复读、幻读）</li><li>Isolation.REPEATABLE_READ 可重复读 （幻读）</li><li>Isolation.SERIALIZATION 串行化 </li><li>Isolation.DEFAULT 使用数据库默认</li></ol><h3 id="Isolation-vs-Lock"><a href="#Isolation-vs-Lock" class="headerlink" title="Isolation vs Lock"></a>Isolation vs Lock</h3><ul><li>两个不同的东西，隔离不是靠锁实现的，是靠对数据的监控实现的。</li><li>锁：表加好锁了，除非出现死锁等特殊情况，事务是不会被数据库主动回滚的。</li><li>隔离：如果发现数据不符合数据库隔离级别，当前事务会出错并回滚。相比锁被回滚可能性较大，需要程序有出错重试的步骤。</li></ul><h3 id="Transactional注解的timeout参数"><a href="#Transactional注解的timeout参数" class="headerlink" title="@Transactional注解的timeout参数"></a>@Transactional注解的timeout参数</h3><ul><li>timeout事务的超时时间，默认值为-1,。如果超过该时间限制但事务还没有完成，则自动回滚事务。</li><li>方法抛出异常，事务被回滚，可能是SQL执行时间过长的异常，也可能是TransactionTimedOutException</li><li>从方法执行开始计算，每个SQL执行前检查一次是否超时，方法全部执行完毕后不检查是否超时</li></ul><h2 id="Mybatis进阶"><a href="#Mybatis进阶" class="headerlink" title="Mybatis进阶"></a>Mybatis进阶</h2><h3 id="复杂类的ORMapping和主子表的同时数据插入"><a href="#复杂类的ORMapping和主子表的同时数据插入" class="headerlink" title="复杂类的ORMapping和主子表的同时数据插入"></a>复杂类的ORMapping和主子表的同时数据插入</h3><p>#{}可转义 ${} 不可转义（可能导致sql注入）  </p><h3 id="使用TypeHandler处理枚举、数组、JSON等特殊类型"><a href="#使用TypeHandler处理枚举、数组、JSON等特殊类型" class="headerlink" title="使用TypeHandler处理枚举、数组、JSON等特殊类型"></a>使用TypeHandler处理枚举、数组、JSON等特殊类型</h3><p>EnumTypeHandler vs EnumOrdinalTypeHandler</p><ul><li>EnumTypeHandler存储的是对应类的名字，可以存储成一个字符串</li><li>EnumOrdinalTypeHandler存储的是枚举类型的顺序</li></ul><p>ArrayTypeHandler<br>自定义JsonTypeHandler</p><h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2><h3 id="安全控制的层级"><a href="#安全控制的层级" class="headerlink" title="安全控制的层级"></a>安全控制的层级</h3><ul><li>基于URL的控制</li><li>基于方法的控制</li><li>程序内</li></ul><h3 id="配置Spring-Security"><a href="#配置Spring-Security" class="headerlink" title="配置Spring Security"></a>配置Spring Security</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSecurity</span><br><span class="line">@EnableGlobalMethodSecurity(prePostEnabled = true, jsr250Enabled = false)</span><br><span class="line">public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    private final static Log log = LogFactory.getLog(WebSecurityConfig.class);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity httpSecurity) throws Exception &#123;</span><br><span class="line">        if (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(&quot;configure httpSecurity...&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //默认的spring-security配置会让所有的请求都必须在已登录的状况下访问；下面这段代码禁止了这种操作。</span><br><span class="line">        httpSecurity.csrf().disable()</span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()</span><br><span class="line">                .authorizeRequests().anyRequest().permitAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-Security-注解"><a href="#Spring-Security-注解" class="headerlink" title="Spring Security 注解"></a>Spring Security 注解</h3><p>@EnableGlobalMethodSecurity(prePostEnable=true, securedEnable=true, jsr250Enabled=true)<br>prePostEnable=true: @PreAuthorize @PostAuthorize @PreFilter @PostFilter<br>securedEnable=true: @Secured<br>jsr250Enable: @RolesRequied (JSR250)  </p><h3 id="PreAuthorize-PostAuthorize-中常用的表达式"><a href="#PreAuthorize-PostAuthorize-中常用的表达式" class="headerlink" title="@PreAuthorize @PostAuthorize 中常用的表达式"></a>@PreAuthorize @PostAuthorize 中常用的表达式</h3><ul><li>hasRole(‘user’, ‘admin’)  hasAnyRole(‘user’, ‘admin’)</li><li>hasAuthority(‘query’, ‘update’)   hasAnyAuthority(‘query’, ‘update’)</li><li>permitAll denyAll</li><li>principal, authentication 当前用户</li></ul><h3 id="Role-vs-Authorization"><a href="#Role-vs-Authorization" class="headerlink" title="Role vs Authorization"></a>Role vs Authorization</h3><ul><li>ROLE_开头则是role</li><li>JSR250 RolesAllowed全部要求是role</li><li>Spring EL中hasRole也要求是role hasAuthority则不用ROLE_开头</li></ul><h3 id="Controller内获取当前用户"><a href="#Controller内获取当前用户" class="headerlink" title="Controller内获取当前用户"></a>Controller内获取当前用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Object doSomething(Authentication auth)&#123;</span><br><span class="line">    User u = (User) auth.getPrincipal();</span><br><span class="line">&#125;</span><br><span class="line">或  </span><br><span class="line">Authentication auth = SecurityContextHolder.getContext().getAuthentication();</span><br></pre></td></tr></table></figure><h3 id="启用Spring-Security"><a href="#启用Spring-Security" class="headerlink" title="启用Spring Security"></a>启用Spring Security</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="OpenId"><a href="#OpenId" class="headerlink" title="OpenId"></a>OpenId</h3><ul><li>提供用户追踪方式</li><li>无需使用用户名密码登录</li><li>协议2.0版提供属性交换功能</li><li>目前已经很少使用</li></ul><h3 id="OAuth开放授权"><a href="#OAuth开放授权" class="headerlink" title="OAuth开放授权"></a>OAuth开放授权</h3><ul><li>目前是OAuth2.0</li><li>2.0不兼容1.0</li><li>密码无需告诉第三方</li><li>为用户提供一个令牌，允许通过令牌访问资源</li></ul><h3 id="OAuth-2-0-Grant-Types"><a href="#OAuth-2-0-Grant-Types" class="headerlink" title="OAuth 2.0 Grant Types"></a>OAuth 2.0 Grant Types</h3><ul><li>授权码模式 Authorization Code</li><li>简化模式 Implicit</li><li>密码模式 Password</li><li>客户端模式 Client Credentials</li><li>Refresh Token</li></ul><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><ul><li>JSON Web Token</li><li>三部分：Header、Playload、Verify Signature</li><li>Header：头部信息，声明类型和加密算法</li><li>Playload：载荷</li><li>Verify Signature：签名，用于验证头部和载荷部分是否被修改过</li></ul><h3 id="JWT的加密方式"><a href="#JWT的加密方式" class="headerlink" title="JWT的加密方式"></a>JWT的加密方式</h3><ul><li>HMAC  共用一个秘钥</li><li>SHA256    公钥私钥分开</li></ul><h3 id="生成JWT和验证JWT的jar"><a href="#生成JWT和验证JWT的jar" class="headerlink" title="生成JWT和验证JWT的jar"></a>生成JWT和验证JWT的jar</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.auth0&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>网站：<a href="https://github.com/auth0/java-jwt" target="_blank" rel="noopener">https://github.com/auth0/java-jwt</a>  </p><h2 id="Spring-Async-Scheduling-amp-Cache"><a href="#Spring-Async-Scheduling-amp-Cache" class="headerlink" title="Spring Async, Scheduling &amp; Cache"></a>Spring Async, Scheduling &amp; Cache</h2><h3 id="Spring-Async-异步执行"><a href="#Spring-Async-异步执行" class="headerlink" title="Spring Async 异步执行"></a>Spring Async 异步执行</h3><p>配置：@EnableAsync (@SpringBootApplication 那里)<br>使用：@Async （方法上）<br>@Async方法返回值：  </p><ul><li>void</li><li>Future<t></t></li><li>其他类型一律返回null；遇到int/double/float/boolean基本类型，执行时会抛出异常：AopInvocationException;</li></ul><h3 id="Spring-Scheduling"><a href="#Spring-Scheduling" class="headerlink" title="Spring Scheduling"></a>Spring Scheduling</h3><p>使用：</p><ul><li>@EnableScheduling 注解启用Scheduling</li><li>方法上加@Scheduled注解，方法会按照参数定期执行<br>@Scheduled 参数：</li><li>cron 值为字符串</li><li>zone 设置时区</li><li>fixedDelay (单位毫秒)，每次方法执行完毕后，休息固定时间后再次启动</li><li>fixedRate (单位毫秒)按照固定频率启动执行<br>-initialDelay (单位毫秒)，和上面三个参数搭配使用，首次执行延时 </li></ul><p>集群/负载均衡环境</p><ul><li>独立出来一个application运行scheduling task</li><li>使用：Quartz Scheduler</li></ul><h3 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h3><p>缓存：  </p><ul><li>利用java程序中的变量（简单；集群环境中多个实例无法同步）</li><li>缓存服务器（Memcached，Redis）<br>Spring中通过注解使用缓存  </li><li>@EnableCaching启用缓存注解</li><li>@Cacheable</li><li>@CacheEvict</li><li>@CachePut</li><li>@CacheConfig</li></ul><h3 id="使用-Redis-缓存服务"><a href="#使用-Redis-缓存服务" class="headerlink" title="使用 Redis 缓存服务"></a>使用 Redis 缓存服务</h3><p>POM中加入依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependecy&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>application.yml 中加入配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cache:</span><br><span class="line">    redis:</span><br><span class="line">      time-to-live: 3306</span><br><span class="line">  redis:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 6379</span><br><span class="line">    pool:</span><br><span class="line">      max-active: 5</span><br><span class="line">      max-idle: 10</span><br><span class="line">      max-wait: 10000</span><br></pre></td></tr></table></figure><h2 id="Websocket-amp-JMS"><a href="#Websocket-amp-JMS" class="headerlink" title="Websocket &amp; JMS"></a>Websocket &amp; JMS</h2><p>Websocket</p><ul><li>全双工通道，数据双向传输</li><li>浏览器和服务器之间的持久性的连接</li><li>比轮询/长轮询大幅节省资源</li><li>使用80/443等HTTP端口</li><li>ws://example.com/wsapi wss://secure.example.com/</li><li>IE10以上浏览器支持</li></ul><p>JMS  </p><ul><li>Java Message Service – Java消息服务</li><li>在两个应用程序或者分布式服务之间提供异步消息通讯</li><li>应用间解耦</li><li>企业应用集成中应用较多</li><li>消息服务器很多，Apache ActiveMQ是比较常见的一个</li></ul><p>JMS消息模式</p><ul><li>点对点（P2P）：每个消息有一个生产者一个消费者</li><li>发布者/订阅者（Pub/Sub）:每个消息一个生产者、多个消费者</li></ul><p>安装ActiveMQ<br>  配置pom文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>  配置application.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  activemq:</span><br><span class="line">    broker-url: tcp://127.0.0.1:61616</span><br></pre></td></tr></table></figure><p>  @EnableJms 注解</p><h2 id="部署Spring-Boot项目"><a href="#部署Spring-Boot项目" class="headerlink" title="部署Spring Boot项目"></a>部署Spring Boot项目</h2><h3 id="Spring-Profile-和配置日志记录框架"><a href="#Spring-Profile-和配置日志记录框架" class="headerlink" title="Spring Profile 和配置日志记录框架"></a>Spring Profile 和配置日志记录框架</h3><ul><li>可以设置不同的配置参数</li><li>可以设置不同的bean的装载</li></ul><p>Active Profile</p><ul><li>同时可以有多个被激活的profile</li><li>有active和default两个概念</li><li>如果没有设置active，则spring使用设置的default，如果没有声明default，则使用那些无显示指定的作为default</li></ul><h3 id="生产环境架构"><a href="#生产环境架构" class="headerlink" title="生产环境架构"></a>生产环境架构</h3><p>性能调优</p><ul><li>前端：数据缓存；加载顺序；显示顺序；预先加载；</li><li>NGINX: 设置客户端缓存；数据压缩传输；HTTP2.0</li><li>应用：优化算法；优化SQL（慢SQL）；避免N+1查询；异步操作；使用缓存；不常修改数据的静态化；集群；</li><li>数据库：索引和统计信息；优化表结构；冗余列和计算列；表拆分；分区表；统计慢SQL（提供程序）；SQL优化建议；升级硬件；</li></ul><h3 id="以服务程序运行（ubuntu）"><a href="#以服务程序运行（ubuntu）" class="headerlink" title="以服务程序运行（ubuntu）"></a>以服务程序运行（ubuntu）</h3><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="在-Spring-Boot-项目中使用Servlet-Filter-Listener等"><a href="#在-Spring-Boot-项目中使用Servlet-Filter-Listener等" class="headerlink" title="在 Spring Boot 项目中使用Servlet,Filter,Listener等"></a>在 Spring Boot 项目中使用Servlet,Filter,Listener等</h3><p>Servlet  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(name=&quot;QrcodeServlet&quot;, urlPatterns=&quot;/servlet/qrcode&quot;)</span><br><span class="line">public class QrcodeServlet extends HttpServlet implements Serializable&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Filter  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@WebFilter</span><br><span class="line">public class LogFilter implements Filter &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@ServletComponentScan 注解<br>@ComponentScan  </p><h3 id="Autowired-的加载规则"><a href="#Autowired-的加载规则" class="headerlink" title="Autowired 的加载规则"></a>Autowired 的加载规则</h3><p>@Autowired</p><ul><li>查找被注解的变量类型，找到所有此类型的构建或此类型子类的构建。</li><li>如果一个也没有找到，看required参数，false则用null，true则失败（默认）。</li><li>如果仅找到一个，则装载这个构件。</li><li>如果找到多个，且只有一个有@Primary注解，使用Primary的。</li><li>如果不符合上述条件，失败。</li></ul><p>@Autowired @Qualifier</p><ul><li>如果属性既有Autowired注解又有Qualifier注解</li><li>在构件中查找名字为Qualifier中指定的名字的注解。</li><li>在构件上指定名字的方法有两个，@Service(“这里写名字”)，@Qualifier(“这里写名字”)。</li></ul><h3 id="API-的版本"><a href="#API-的版本" class="headerlink" title="API 的版本"></a>API 的版本</h3><p>客户端传递版本信息方式</p><ul><li>URL</li><li>RequestHeader</li></ul><p>URL</p><ul><li>部署，通过修改NGINX配置，不同域名，不同前缀。</li><li>修改application.yml中的contextPath，server.servlet.contextPath:/tutorial-v2</li><li>修改@RequestMapping中的参数，例如，@RequestMapping(“/v1/tvseries”)</li><li>增加request的参数，例如：/tvseries?version=2</li></ul><p>Request Header  </p><ul><li>自定义request header，例如：Version:2</li><li>使用Accept  Accept:application/vnd.tutorial.v2 + json</li></ul><p>自定义 RequestMappingHandlerMapping  </p><ul><li>自定义ApiVersion注解</li><li>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</li></ul><h3 id="定制Spring-REST的错误返回信息"><a href="#定制Spring-REST的错误返回信息" class="headerlink" title="定制Spring REST的错误返回信息"></a>定制Spring REST的错误返回信息</h3><p>Controller中单独处理</p><ul><li>把返回值改成ResponseEntity<t></t></li><li>T为要返回的内容</li><li>通过ResponseEntity来设置返回的HttpResponse状态码</li></ul><p>全局的异常处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">public class ExceptionHandler &#123;</span><br><span class="line">    @ExceptionHandler(Throwable.class)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    ResponseEntity&lt;Object&gt; handleControllerException(Throwable ex, WebRequest request) &#123;</span><br><span class="line">        //处理异常，并设置给客户端反馈的信息</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Spring" scheme="http://yeonsea.club/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yeonsea.club/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>赠药山高僧惟俨二首</title>
    <link href="http://yeonsea.club/2018/12/23/%E8%B5%A0%E8%8D%AF%E5%B1%B1%E9%AB%98%E5%83%A7%E6%83%9F%E4%BF%A8%E4%BA%8C%E9%A6%96/"/>
    <id>http://yeonsea.club/2018/12/23/赠药山高僧惟俨二首/</id>
    <published>2018-12-23T11:11:58.000Z</published>
    <updated>2018-12-23T12:11:43.069Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2018/12/23/赠药山高僧惟俨二首/../赠药山高僧惟俨二首/赠药山高僧惟俨二首.jpeg"></p><blockquote><p>练得身形如鹤形，千株松下两函经。我来问道无馀说，云在青霄水在瓶。</p></blockquote><blockquote><p>选得幽居惬野情，终年无送亦无迎。有时直上孤峰顶，月下披云啸一声。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tao" scheme="http://yeonsea.club/categories/Tao/"/>
    
    
      <category term="Tao" scheme="http://yeonsea.club/tags/Tao/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yeonsea.club/2018/12/22/hello-world/"/>
    <id>http://yeonsea.club/2018/12/22/hello-world/</id>
    <published>2018-12-22T15:53:34.885Z</published>
    <updated>2018-12-23T12:12:50.552Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2018/12/22/hello-world/../hello-world/hello-world.jpg"></p><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
</feed>
