<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Đinh Giang</title>
  
  <subtitle>人生は意味が、唯一の生活をすることができますが见つかりました楽しいこと、 のような花が见つかる、あなた様と私が见つかりました</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yeonsea.club/"/>
  <updated>2019-09-19T09:28:19.341Z</updated>
  <id>http://yeonsea.club/</id>
  
  <author>
    <name>J</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式系统基础设施</title>
    <link href="http://yeonsea.club/2019/09/18/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/"/>
    <id>http://yeonsea.club/2019/09/18/分布式系统基础设施/</id>
    <published>2019-09-18T06:49:09.000Z</published>
    <updated>2019-09-19T09:28:19.341Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>一个大型、稳健、成熟的分布式系统的背后，往往会涉及众多的支撑系统，我们将这些支撑系统称为分布式系统的基础设施。</p></blockquote><h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><p>由于单台机器的内存资源和承载能力有限，并且如果大量使用本地缓存，也会使相同的数据被不同的节点存储多份，对内存资源造成较大的浪费，因此才催生出了分布式缓存。</p><h3 id="memcache"><a href="#memcache" class="headerlink" title="memcache"></a>memcache</h3><p>用于在应用中减少对数据库的访问，提高应用的访问速度，并降低数据库的负载。<br>memcache 使用 key-value 形式存储和访问数据，在内存中维护一张巨大的 HashTable。<br>memcache 使用了 libevent 来进行高效的网络连接处理。</p><h3 id="memcache-API-与分布式"><a href="#memcache-API-与分布式" class="headerlink" title="memcache API 与分布式"></a>memcache API 与分布式</h3><p>memcache 客户端与服务端通过构建在 TCP 协议之上的 memcache 协议来进行通信，协议支持两种数据的传递，这两种数据分别为文本行和非结构化数据。</p><ul><li>文本行：主要用来承载客户端的命令及服务端的响应。</li><li>非结构化数据：主要用于客户端和服务端数据的传递。采用字节流的形式。</li></ul><p>memcache 协议支持通过如下几种方式来读取写入失效数据：</p><ul><li>set  如果存在同样的 key ，替换</li><li>add  如果存在同样的 key ，失败</li><li>replace  如果不存在 key ，失败</li><li>append</li><li>prepend</li><li>cas  提供对变量的 cas 操作，它将保证数据更新之前，数据没有被其他人修改;</li><li>get</li><li>incr</li><li>decr</li><li>delete</li></ul><p>memcache 官方提供的 Memcache-Java-Client 工具包含了对 memcache 协议的 Java 封装，使用它可以比较方便地与缓存服务端进行通信，它的初始化方式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String[] servers = &#123;</span><br><span class="line"><span class="string">"192.168.136.135:11211"</span></span><br><span class="line">&#125;;</span><br><span class="line">SockIOPool pool = SockIOPool.getInstance();</span><br><span class="line">pool.setServers(servers); <span class="comment">// 设置服务器</span></span><br><span class="line">pool.setFailover(<span class="keyword">true</span>); <span class="comment">// 容错</span></span><br><span class="line">pool.setInstance(<span class="number">10</span>); <span class="comment">// 设置初始连接数</span></span><br><span class="line">pool.setMinConn(<span class="number">25</span>); <span class="comment">// 设置最小连接数</span></span><br><span class="line">pool.setMaxConn(<span class="number">25</span>); <span class="comment">// 设置最大连接数</span></span><br><span class="line">pool.setMaintSleep(<span class="number">30</span>); <span class="comment">// 设置连接池维护线程的睡眠时间</span></span><br><span class="line">pool.setNagle(<span class="keyword">false</span>); <span class="comment">// 设置是否使用 Nagle 算法</span></span><br><span class="line">pool.setSocketTO(<span class="keyword">true</span>); <span class="comment">// 设置 socket 的读取等待超时时间</span></span><br><span class="line">pool.setAliveCheck(<span class="keyword">true</span>); <span class="comment">// 设置连接心跳检测开关</span></span><br><span class="line">pool.setHashingAlg(SockIOPool.CONSISTENT_HASH); <span class="comment">// 设置 Hash 算法</span></span><br><span class="line">pool.initialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>memcache 本身并不是一种分布式缓存系统，它的分布式是由访问它的客户端来实现的。</p><p>一种比较简单的实现方式是根据缓存的 key 来进行 Hash ，当后端有 N 台缓存服务器时，访问的服务器为 hash(key)%N，这样可以将前端的请求均衡地映射到后端的缓存服务器。</p><p>但如果考虑缓存实例变动（增删）的情况：<br>某一缓存实例宕机，需要将该实例从集群中摘除，则映射公式变为 hash(object) % (N - 1)<br>增加一台缓存实例，将该实例加入集群，则映射公式变为 hash(object) % (N + 1)<br>对于以上情况，无论新增还是移除，大部分object所映射的缓存实例均会改变，缓存命中率大幅度降低从而回源到服务器，短时间内造成缓存雪崩现象。</p><p><em>使用 consistent Hash 算法能够在一定程度上改善上述问题。</em></p><ul><li>环形结构</li><li>虚拟节点</li></ul><h3 id="分布式-session"><a href="#分布式-session" class="headerlink" title="分布式 session"></a>分布式 session</h3><blockquote><p>传统的应用服务器，如 tomcat、jboss 等，其自身所实现的 session 管理大部分都是基于单机的。对于大型分布式网站来说，支撑其业务的远远不止一台服务器，而是一个分布式集群，请求在不同服务器之间跳转。<br>传统网站一般将一部分数据存储在 cookie 中，来规避分布式环境下 session 的操作。这样做的弊端很多，一方面 cookie 的安全性一直广为诟病，另一方面 cookie 存储数据的大小是有限制的。</p></blockquote><ul><li>将 session 持久化到 DB 中，可以保证宕机时会话不易丢失，但系统的整体吞吐将受到很大的影响。</li><li>将session 统一存储在缓存集群上，可以保证较高的读写性能，可以利用缓存的失效机制，但一旦缓存重启，里面保存的会话也就丢失了。</li></ul><p>通过将 session 以 sessionid 作为 key，保存到后端的缓存集群中，使得不管请求如何分配，即便是 Web Server 宕机，也不会影响其他 Web Server 通过 sessionid 从 Cache Server 中获得 session，这样既实现了集群间的 session 同步，又提高了 Web Server 的容错性。</p><p>memcache-session-manager 是一个开源的高可用的 Tomcat session 共享解决方案，支持 Sticky 模式和 Non-Sticky 模式。<br>以 Non-Sticky 模式为例，它需要给 Tomcat 的 $CATALINA_HOME/conf/context.xml 文件配置 SessionManager，具体配置如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">"de.javakaffee.web.msm.MemcachedBackupSessionManager"</span></span></span><br><span class="line"><span class="tag"><span class="attr">memcachedNodes</span>=<span class="string">"n1:192.168.0.100,:11211, n2:192.168.0.101:11211"</span></span></span><br><span class="line"><span class="tag"><span class="attr">Sticky</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag"><span class="attr">sessionBackupAsync</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag"><span class="attr">lockingNode</span>=<span class="string">"auto"</span></span></span><br><span class="line"><span class="tag"><span class="attr">requestUriIgnorePattern</span>=<span class="string">".*\.(ico|png|gif|jpg|css|js)$"</span></span></span><br><span class="line"><span class="tag"><span class="attr">transcoderFactoryClass</span> = <span class="string">"de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h2><p>面对并发访问量的激增和数据几何级的增长，如何存储正在迅速膨胀并且不断累积的数据，以及应对日益增长的用户访问频次，称为亟待解决的问题。</p><p>传统IOE解决方案，使用和扩展的成本越来越高，使得互联网企业不得不思考新的解决方案。开源软件加廉价PC Server的分布式架构，得益于社区的支持。在节约成本的同时，也给系统带来了良好的扩展能力，并且由于开源软件的代码透明，使得企业能够以更低的代价定制更符合自身使用场景的功能，以提高系统的整体性能。</p><h3 id="MySQL-扩展"><a href="#MySQL-扩展" class="headerlink" title="MySQL 扩展"></a>MySQL 扩展</h3><h4 id="业务拆分"><a href="#业务拆分" class="headerlink" title="业务拆分"></a>业务拆分</h4><blockquote><p>业务发展初期为了便于快速迭代，很多应用都采用集中式的架构。随着业务规模的扩展，使系统变得越来越复杂，越来越难以维护，开发效率越来越低，并且系统的资源消耗也越来越大，通过硬件提升性能的成本也越来越高。因此，系统业务的拆分是难以避免的。</p></blockquote><p>业务拆分不仅仅提高了系统的可扩展性，也带来了开发工作效率的提升。</p><h4 id="复制策略"><a href="#复制策略" class="headerlink" title="复制策略"></a>复制策略</h4><p>要实现数据库的复制，需要开启 Master 服务器端的 Binary log。数据复制的过程实际上就是 Slave 从 master 获取 binary log，然后再在本地镜像的执行日志中记录的操作。<br>由于复制过程是异步的，只能够保证数据最终一致性。<br>MySQL 的复制可以基于一条语句(statement level)，也可以基于一条记录(row level)。</p><blockquote><p>前段服务器通过 Master 来执行数据写入的操作，数据的更新通过 Binary log 同步到 Slave 集群，而对于数据读取的请求，则交由 Slave 来处理，这样 Slave 集群可以分担数据库读的压力，并且读、写分离保障了数据能够达到最终一致性。</p></blockquote><p>Q:<br>Master-Slaves 复制架构存在一个问题，即所谓的单点故障。当 Master 宕机时，系统将无法写入，而在某些特定的场景下，也可能需要 Master 停机，以便进行系统维护、优化或者升级。<br>A:<br>最佳的方式就是采用 Dual-Master 架构，即 Master-Master 架构。<br>MySQL 不会将复制产生的变更记录到 Binary log ，这样就避免了服务器间数据的循环复制。</p><p><em>仅开启一台 Master 的写入，另一台 Master 仅仅 stand by 或者作为读库开放，这样可以避免数据写入的冲突，防止数据不一致的情况发生。</em></p><p>如需进行停机维护，可按如下步骤执行 Master 的切换操作：</p><ol><li>停止当前 Master 的所有写入操作。</li><li>在 Master 上执行 set global read_only=1，同时更新 MySQL 配置文件中相应的配置，避免重启时失效。</li><li>在 Master 上执行 show Master status，以记录 Binary log 坐标。</li><li>使用 Master 上的 Binary log 坐标，在 stand by 的 Master 上执行 select Master_pos_wait()，等待 stand by Master 的 Binary log 跟上 Master 的 Binary log。</li><li>在 stand by Master 开启写入时，设置 read_only=0。</li><li>修改应用程序的配置，使其写入到新的 Master。</li></ol><blockquote><p>假如 Master 意外宕机，处理过程要稍微复杂一点，因为此时 Master 与 stand by Master 上的数据并不一定同步，需要将 Master 上没有同步到 stand by Master 的 Binary log 复制到 Master 上进行 replay，直到 stand by Master 与 原 Master 上的 Binary log 同步，才能够开启写入；否则，这一部分不同步的数据就有可能导致数据不一致。</p></blockquote><h4 id="分表与分库"><a href="#分表与分库" class="headerlink" title="分表与分库"></a>分表与分库</h4><p>对于访问极为频繁且数据量巨大的单表来说，我们首先要做的就是减少单表的记录条数，以便减少数据查询所需要的时间，提高数据库的吞吐，这就是所谓的分表。</p><p>用户 id 是最常用的分表字段。</p><blockquote><p>假设有一张记录用户购买信息的订单表 order，由于 order 表记录条数太多，将被拆分成 256 张表。拆分的记录根据 user_id%256，找到对应订单存储的表进行访问。</p></blockquote><p>分表能够解决单表数据量过大带来查询效率下降的问题，但是，却无法给数据库的并发处理能力带来质的提升。<br>与分表策略相似，分库也可以采用通过一个关键字取模的方式，来对数据访问进行路由。</p><blockquote><p>有时数据库可能既面临着高并发访问的压力，又需要面对海量数据的存储问题，这时需要对数据库即采用分库策略，又采用分表策略，以便同时扩展系统的并发处理能力，以及提升单表的查询能力，这就是所谓的分库分表。</p></blockquote><p>一般分库分表的路由策略：</p><ul><li>中间变量=user_id%(库数量*每个库的表数量)</li><li>库=取整(中间变量/每个库的表数量)</li><li>表=中间变量%每个库的表数量</li></ul><p><em>业务拆分及分库分表带来的问题：</em></p><ul><li>原本跨表的事务上升为分布式事务；</li><li>由于记录被切分到不同的库与不同的表当中，难以进行多表关联查询，并且不能不指定路由字段对数据进行查询。</li><li>如果需要对系统进行进一步扩容(路由策略变更)，将变得非常不方便，需要重新进行数据迁移。</li></ul><h3 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h3><p>Apache Hadoop 项目下的一个子项目，它以 Google BigTable 为原型，设计实现了高可靠性、高可扩展性、实时读写的列存储数据库。</p><blockquote><p>本质实际上是一张稀疏的大表，用来存储粗粒度的结构化数据，并且能够通过简单地增加节点来实现系统的线性扩展。</p></blockquote><p>HBase 运行在分布式文件系统 HDFS 之上，利用它可以在廉价的 PC Server 上搭建大规模结构化存储集群。</p><p>HBase 集群中通常包含两种角色，HMaster 和 HRegionServer。当表随着记录条数的增加而不断变大后，将会分裂成一个个Region，每个 Region 可以由(startkey，endkey)来表示，它包含一个 startkey 到 endkey 的半闭区间。<br>一个 HRegion 可以管理多个 Region，并由 HMaster 来负责 HRegionServer 的调度及集群状态的监管。</p><h4 id="HBase-安装"><a href="#HBase-安装" class="headerlink" title="HBase 安装"></a>HBase 安装</h4><ol><li>下载</li><li>编辑 hbase-env.sh ，设置 JAVA_HOME</li><li>编辑 hbase-site.xml 文件</li><li>启动 HBase  先启动 Hadoop 再启动 HBase<h4 id="HBase-API"><a href="#HBase-API" class="headerlink" title="HBase API"></a>HBase API</h4>以 Java 为例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 配置 HBase 的 HMaster 服务器地址和对应的端口（默认为60000），以及对应的 ZooKeeper 服务器地址和端口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Configuration conf = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">conf = HBaseConfiguration.create();</span><br><span class="line">conf.set(<span class="string">"hbase.ZooKeeper.property.clientPort"</span>, <span class="string">"2181"</span>);</span><br><span class="line">conf.set(<span class="string">"hbase.ZooKeeper.quorum"</span>, <span class="string">"192.168.136.135:60000"</span>);</span><br><span class="line">conf.set(<span class="string">"hbase.master"</span>, <span class="string">"192.168.136.135:60000"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 通过程序增加 user 表，包含三个列族，分别为 info、class、parent，如果该表已经存在，则先删除该表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createTable</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String tableName = <span class="string">"user"</span>;</span><br><span class="line">HBaseAdmin hBaseAdmin = <span class="keyword">new</span> hBaseAdmin(conf);</span><br><span class="line"><span class="keyword">if</span> (hBaseAdmin.tableExists(tableName)) &#123;</span><br><span class="line">hBaseAdmin.disableTable(tableName);</span><br><span class="line">hBaseAdmin.deleteTable(tableName);</span><br><span class="line">&#125;</span><br><span class="line">HTableDescriptor tableDescriptor = <span class="keyword">new</span> HTableDescriptor(tableName.valueOf(tableName));</span><br><span class="line">tableDescriptor.addFamily(<span class="keyword">new</span> HColumnDescriptor(<span class="string">"info"</span>));</span><br><span class="line">tableDescriptor.addFamily(<span class="keyword">new</span> HColumnDescriptor(<span class="string">"class"</span>));</span><br><span class="line">tableDescriptor.addFamily(<span class="keyword">new</span> HColumnDescriptor(<span class="string">"parent"</span>));</span><br><span class="line">hBaseAdmin.createTable(tableDescriptor);</span><br><span class="line">hBaseAdmin.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将数据添加到 user 表，每个列族指定一个列 col, 并给该列赋值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putRow</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String tableName = <span class="string">"user"</span>;</span><br><span class="line">String[] familyNames = &#123;<span class="string">"info"</span>, <span class="string">"class"</span>, <span class="string">"parent"</span>&#125;;</span><br><span class="line">HTable table = <span class="keyword">new</span> HTable(conf, tableName);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; familyNames.length; j++) &#123;</span><br><span class="line">Put put = <span class="keyword">new</span> Put(Bytes.toBytes(i + <span class="string">""</span>));</span><br><span class="line">put.add(Bytes.toBytes(familyNames[j]),</span><br><span class="line">Bytes.toBytes(<span class="string">"col"</span>),</span><br><span class="line">Bytes.toBytes(<span class="string">"value_"</span> + i + <span class="string">"_"</span> + j));</span><br><span class="line">table.put(put);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">table.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 取得 rowkey 为 1 的行，并将该行打印出来</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getRow</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String tableName = <span class="string">"user"</span>;</span><br><span class="line">String rowKey = <span class="string">"1"</span>;</span><br><span class="line">HTable table = <span class="keyword">new</span> HTable(conf, tableName);</span><br><span class="line">Get g = <span class="keyword">new</span> Get(Bytes.toBytes(rowKey));</span><br><span class="line">Result r = table.get(g);</span><br><span class="line">outputResult(r);</span><br><span class="line">table.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outputResult</span><span class="params">(Result rs)</span> </span>&#123;</span><br><span class="line">List&lt;Cell&gt; list = rs.listCells();</span><br><span class="line">System.out.println(<span class="string">"row key: "</span> + <span class="keyword">new</span> String(rs.getRow()));</span><br><span class="line"><span class="keyword">for</span> (Cell cell : list) &#123;</span><br><span class="line">System.out.println(<span class="string">"family: "</span> + <span class="keyword">new</span> String(cell.getFamily()) </span><br><span class="line">+ <span class="string">", col: "</span> + <span class="keyword">new</span> String(cell.getQualifier())</span><br><span class="line">+ <span class="string">", value: "</span> + <span class="keyword">new</span> String(cell.getValue()) );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* scan 扫描 user 表，并将查询结果打印出来</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scanTable</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String tableName = <span class="string">"user"</span>;</span><br><span class="line">HTable table = <span class="keyword">new</span> HTable(conf, tableName);</span><br><span class="line">Scan a = <span class="keyword">new</span> Scan();</span><br><span class="line">ResultScanner rs = table.getScanner(s);</span><br><span class="line"><span class="keyword">for</span> (Result r : rs) &#123;</span><br><span class="line">outputResult(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 startrow 和 endrow 进行查询</span></span><br><span class="line">s = <span class="keyword">new</span> Scan(<span class="string">"2"</span>.getBytes(), <span class="string">"6"</span>.getBytes());</span><br><span class="line">rs = table.getScanner(s);</span><br><span class="line"><span class="keyword">for</span> (Result r : rs) &#123;</span><br><span class="line">outputResult(r);</span><br><span class="line">&#125;</span><br><span class="line">table.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 删除 rowkey 为 1 的记录</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteRow</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String tableName = <span class="string">"user"</span>;</span><br><span class="line">String rowKey = <span class="string">"1"</span>;</span><br><span class="line">HTable table = <span class="keyword">new</span> HTable(conf, tableName);</span><br><span class="line">List&lt;Delete&gt; list = <span class="keyword">new</span> ArrayList&lt;Delete&gt;();</span><br><span class="line">Delete d = <span class="keyword">new</span> Delete(rowkey.getBytes());</span><br><span class="line">list.add(d);</span><br><span class="line">table.delete(list);</span><br><span class="line">table.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="rowkey-设计"><a href="#rowkey-设计" class="headerlink" title="rowkey 设计"></a>rowkey 设计</h4><p>要想访问 HBase 的行，只有三种方式，一种是通过指定 rowkey 进行访问，另一种是指定 rowkey 的 range 进行 scan，再者就是全盘扫描。</p><blockquote><p>关系型数据库能够很好地支持多条件查询，但对于 HBase 来说，实现起来并不是那么的容易。基本的思路就是建立一张二级索引表，将查询条件设计成二级索引表的rowkey，而存储的数据则是数据表的rowkey，这样就可以在一定程度上实现多个条件的查询。但是二级索引表也会引入一系列的问题，多表的插入将降低数据写入的性能，并且由于多表之间无事务保障，可能会带来数据一致性问题。(华为提供了 hindex 的二级索引解决方案)</p></blockquote><p>与传统的关系型数据库相比，HBase 有更好的伸缩能力，更适合于海量数据的存储和处理。由于多个 Region Server 的存在，使得 HBase 能够多个节点同时写入，显著提高了写入性能，并且是可扩展的。</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>与其他很多 key-value 数据库的不同之处在于，Redis 不仅支持简单的键值对类型的存储，还支持其他一系列丰富的数据存储结构，并在这些数据结构类型上定义了一套强大的 API。</p><h4 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a>安装 Redis</h4><h4 id="使用-Redis-API"><a href="#使用-Redis-API" class="headerlink" title="使用 Redis API"></a>使用 Redis API</h4><p>Redis 的 Java client 有很多，比较常用的是 Jedis。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"192.168.136.135"</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line">redis.set(<span class="string">"name"</span>, <span class="string">"yeonsea"</span>);<span class="comment">// 设置 key-value</span></span><br><span class="line">redis.setex(<span class="string">"content"</span>, <span class="number">5</span>, <span class="string">"hello"</span>);<span class="comment">// 设置 key-value 有效期为 5 秒</span></span><br><span class="line">redis.mset(<span class="string">"class"</span>, <span class="string">"a"</span>, <span class="string">"age"</span>, <span class="string">"25"</span>);<span class="comment">// 一次设置多个 key-value</span></span><br><span class="line">redis.append(<span class="string">"content"</span>, <span class="string">" lucy"</span>);<span class="comment">// 给字符串追加内容</span></span><br><span class="line">String content = redis.get(<span class="string">"content"</span>);<span class="comment">// 根据 key 获取 value </span></span><br><span class="line">List&lt;String&gt; list = redis.mget(<span class="string">"class"</span>, <span class="string">"age"</span>);<span class="comment">// 一次获取多个 key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hashs 操作</span></span><br><span class="line">redis.hset(<span class="string">"url"</span>, <span class="string">"google"</span>, <span class="string">"www.google.com"</span>);<span class="comment">// 给 Hash 添加 key-value</span></span><br><span class="line">redis.hset(<span class="string">"url"</span>, <span class="string">"taobao"</span>, <span class="string">"www.taobao.com"</span>);</span><br><span class="line">redis.hset(<span class="string">"url"</span>, <span class="string">"sina"</span>, <span class="string">"www.sina.com.cn"</span>);</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">map.put(<span class="string">"name"</span>, <span class="string">"yeon"</span>);</span><br><span class="line">map.put(<span class="string">"sex"</span>, <span class="string">"male"</span>);</span><br><span class="line">map.put(<span class="string">"age"</span>, <span class="string">"100"</span>);</span><br><span class="line">redis.hmset(<span class="string">"userinfo"</span>, map);<span class="comment">// 批量设置值</span></span><br><span class="line"></span><br><span class="line">String name = redis.hget(<span class="string">"userinfo"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取 Hash 的多个 key 的值</span></span><br><span class="line">List&lt;String&gt; urlist = redis.hmget(<span class="string">"url"</span>, <span class="string">"google"</span>, <span class="string">"taobao"</span>, <span class="string">"sina"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取 Hash 的所有 key 的值</span></span><br><span class="line">Map&lt;String, String&gt; userinfo = redis.hgetAll(<span class="string">"userinfo"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// lists 操作</span></span><br><span class="line">redis.lpush(<span class="string">"charlist"</span>, <span class="string">"abc"</span>);<span class="comment">// 在 list 首部添加元素</span></span><br><span class="line">redis.rpush(<span class="string">"charlist"</span>, <span class="string">"hij"</span>);<span class="comment">// 在 list 尾部添加元素</span></span><br><span class="line">List&lt;String&gt; charlist = redis.lrange(<span class="string">"charlist"</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">redis.lpop(<span class="string">"charlist"</span>);<span class="comment">// 在 list 首部删除元素</span></span><br><span class="line">redis.rpop(<span class="string">"charlist"</span>);<span class="comment">// 在 list 尾部删除元素</span></span><br><span class="line">Long charlistSize = redis.llen(<span class="string">"charlist"</span>);<span class="comment">// 获得 list 的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sets</span></span><br><span class="line">redis.sadd(<span class="string">"SetMem"</span>, <span class="string">"s1"</span>);<span class="comment">// 给 set 添加元素</span></span><br><span class="line">redis.srem(<span class="string">"SetMem"</span>, <span class="string">"s1"</span>); <span class="comment">// 从 set 中移除元素</span></span><br><span class="line">Set&lt;String&gt; set = redis.smember(<span class="string">"SetMem"</span>);<span class="comment">// 枚举出 set 的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sorted sets 是 set 的一个升级版本</span></span><br><span class="line">redis.zadd(<span class="string">"SortSetMem"</span>, <span class="number">1</span>, <span class="string">"5th"</span>);<span class="comment">// 插入 sort set，并指定元素的序号</span></span><br><span class="line">redis.zadd(<span class="string">"SortSetMem"</span>, <span class="number">2</span>, <span class="string">"4th"</span>);</span><br><span class="line">redis.zadd(<span class="string">"SortSetMem"</span>, <span class="number">3</span>, <span class="string">"3th"</span>);</span><br><span class="line">redis.zadd(<span class="string">"SortSetMem"</span>, <span class="number">4</span>, <span class="string">"2th"</span>);</span><br><span class="line">redis.zadd(<span class="string">"SortSetMem"</span>, <span class="number">5</span>, <span class="string">"1th"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据范围取 set</span></span><br><span class="line">Set&lt;String&gt; sorted = redis.zrange(<span class="string">"SortSetMem"</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据范围反向取 set</span></span><br><span class="line">Set&lt;String&gt; revsorset = redis.zrevrange(<span class="string">"SortSetMem"</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><h2 id="消息系统"><a href="#消息系统" class="headerlink" title="消息系统"></a>消息系统</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="SOA" scheme="http://yeonsea.club/tags/SOA/"/>
    
  </entry>
  
  <entry>
    <title>互联网安全架构</title>
    <link href="http://yeonsea.club/2019/09/11/%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84/"/>
    <id>http://yeonsea.club/2019/09/11/互联网安全架构/</id>
    <published>2019-09-11T02:18:19.000Z</published>
    <updated>2019-09-18T06:40:16.452Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>随着移动互联网的兴起，以及 RESTful 和 Web Service 等技术的大规模使用，HTTP 协议因其使用方便及跨平台的特性，在 Web 开发和 SOA 领域得到了广泛使用。但其所涵盖的信息，大都是未经加密的明文，信息获取门槛的降低，也为应用架构的安全性与稳定性带来了挑战。</p></blockquote><h2 id="常见的-Web-攻击手段"><a href="#常见的-Web-攻击手段" class="headerlink" title="常见的 Web 攻击手段"></a>常见的 Web 攻击手段</h2><p>XSS, CSRF, SQL注入更多需要从开发流程上来予以保障，而DDoS，攻击手段多样，产生的影响及危害巨大。</p><h3 id="XSS-攻击"><a href="#XSS-攻击" class="headerlink" title="XSS 攻击"></a>XSS 攻击</h3><p>跨站脚本攻击(Cross Site Scripting)</p><h4 id="XSS-原理"><a href="#XSS-原理" class="headerlink" title="XSS 原理"></a>XSS 原理</h4><p>表单，URL中带有恶意脚本</p><h4 id="XSS-防范"><a href="#XSS-防范" class="headerlink" title="XSS 防范"></a>XSS 防范</h4><p>XSS 之所以会发生，是因为用户输入的数据变成了代码。因此，我们需要对用户输入的数据进行HTML转义处理。<br>如今很多开源的开发框架本身默认就提供HTML代码转义的功能，如流行的jstl,struts等，不需要开发人员再进行过多的开发。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">escapeXml=&quot;true&quot;</span><br></pre></td></tr></table></figure></p><h3 id="CRSF-攻击"><a href="#CRSF-攻击" class="headerlink" title="CRSF 攻击"></a>CRSF 攻击</h3><p>跨站请求伪造(cross site request forgery)，是一种对网站的恶意利用。<br><strong>XSS 利用的是站点内的信任用户，而CSRF则是通过伪装来自受信任用户的请求来利用受信任的网站。</strong></p><h4 id="CRSF-攻击原理"><a href="#CRSF-攻击原理" class="headerlink" title="CRSF 攻击原理"></a>CRSF 攻击原理</h4><p>受害者只需要做下面两件事情，攻击者就能够完成CSRF攻击：</p><ul><li>登录受信任站点A，并在本地生成cookie;</li><li>在不登出站点A(清除站点A的cookie)的情况下，访问恶意站点B</li></ul><p><strong>很多情况下所谓的恶意站点，很有可能是一个存在其他漏洞(如XSS)的受信任且被很多人访问的站点，这样，普通用户可能在不知不觉中便成为了受害者。</strong></p><h4 id="攻击举例"><a href="#攻击举例" class="headerlink" title="攻击举例"></a>攻击举例</h4><p>银行转账<br><strong>正常银行的交易付款会有USB key，验证码，登录密码和支付密码等一系列屏障，流程上复杂的多，安全系数也高得多。</strong></p><h4 id="CSRF-的防御"><a href="#CSRF-的防御" class="headerlink" title="CSRF 的防御"></a>CSRF 的防御</h4><ul><li>将 cookie 设置为 HttpOnly<br>在Java的Servlet的API中设置cookie为HostOnly的代码如下</li></ul><p><code>response.setHeader(“Set-Cookie”, “cookiename=cookievalue;HttpOnly&quot;);</code></p><ul><li>增加 token<br>攻击者可以在不知道用户验证信息的情况下直接利用用户的cookie来通过安全验证。由此可知，抵御CSRF攻击的关键在于：在请求中放入攻击者所不能伪造的信息。<br>token 的值通过服务端生成，表单提交后token的值通过post请求与参数一同带到服务端，每次会话可以使用相同的token，会话过期，则token失效，攻击者无法获取到token，也就无法伪造请求。<br>在 session 中添加 token 的实现代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpSesssion session = request.getSession();</span><br><span class="line">Object token = session.getAttribute(<span class="string">"_token"</span>);</span><br><span class="line"><span class="keyword">if</span> (token == <span class="keyword">null</span> || <span class="string">""</span>.equals(token)) &#123;</span><br><span class="line">session.setAttribute(<span class="string">"_token"</span>, UUID.randomUUID().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 Referer 识别<br>根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。在通常情况下，访问一个安全受限的页面的请求都来自于同一个网站。</li></ul><p><code>String referer = request.getHeader(&quot;Referer&quot;);</code></p><h3 id="SQL-注入攻击"><a href="#SQL-注入攻击" class="headerlink" title="SQL 注入攻击"></a>SQL 注入攻击</h3><blockquote><p>所谓 SQL 注入，就是通过把 SQL 命令伪装成正常的 HTTP 请求参数，传递到服务端，欺骗服务器最终执行恶意的 SQL 命令，达到入侵目的。</p></blockquote><h4 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h4><h4 id="SQL-注入的防范"><a href="#SQL-注入的防范" class="headerlink" title="SQL 注入的防范"></a>SQL 注入的防范</h4><ul><li>使用预编译语句  PreparedStatement</li><li>使用 ORM 框架  防止SQL注入的关键在于对一些关键字符进行转义 需要一些简单的配置</li><li>避免密码明文存放  哈希加盐</li><li>处理好相应的异常  后台的系统异常，很可能包含了一些如服务器版本、数据库版本、编程语言等信息，甚至是数据库连接的地址与用户名密码，攻击者可以按图索骥，找到对应版本的服务器漏洞或者数据库漏洞进行攻击。<h3 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h3><blockquote><p>在上网的过程中，我们经常会将一些图片、压缩包之类的文件上传到远端服务器进行保存。文件上传攻击指的是恶意攻击者利用一些站点没有对文件的类型做很好的检验，上传了可以执行的文件或者脚本，并且通过脚本获得服务器上响应的权利，或者是通过诱导外部用户访问，下载上传的病毒或木马文件，达到攻击的目的。<br>很多类型的文件，起始的几个字节内容是固定的，因此，根据这几个字节的内容，就可以确定文件类型，这几个字节也被称为“魔数”。</p></blockquote></li><li>通过魔数来判断文件类型</li><li>imagemagick 针对图片处理的开发工具包  没有提供 jni 对应的头文件(对缩放好的图像进行保存的图片水印生成，锐化，截取，图像格式转换等一系列复杂的操作)</li><li>jmagic  Java 通过它对imagemagick进行调用 (so文件放在/usr/lib下，用jar进行调用)</li></ul><p>代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取文件头</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getFileHeader</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 这里需要注意的是，每个文件的魔数的长度都不相同，因此需要使用 startwith</span></span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">28</span>];</span><br><span class="line">InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">inputStream = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">inputStream.read(b, <span class="number">0</span>, <span class="number">28</span>);</span><br><span class="line">inputStream.close();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bytes2hex(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断文件类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FileType <span class="title">getType</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String fileHead = getFileHeader(filePath);</span><br><span class="line"><span class="keyword">if</span> (fileHead == <span class="keyword">null</span> || fileHead.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">fileHead = fileHead.toUpperCase();</span><br><span class="line">FileType[] fileTypes = FileType.values();</span><br><span class="line"><span class="keyword">for</span> (FileType type : fileTypes) &#123;</span><br><span class="line"><span class="keyword">if</span> (fileHead.startsWith(type.getValue())) &#123;</span><br><span class="line"><span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="DDoS-攻击"><a href="#DDoS-攻击" class="headerlink" title="DDoS 攻击"></a>DDoS 攻击</h3><p>Distribute Denial of Service 分布式拒绝服务攻击</p><h4 id="SYN-Flood"><a href="#SYN-Flood" class="headerlink" title="SYN Flood"></a>SYN Flood</h4><p>SYN Flood 利用了TCP协议三次握手的过程来达成攻击的目的。攻击者伪造大量的IP地址给服务器发送SYN报文，但是由于伪造的IP地址几乎不可能存在，也就不可能从客户端得到任何回应，服务端将维护一个非常大的半连接等待列表，并且不断对这个列表中的IP地址进行遍历和重试，占用了大量的系统资源。<br>更为严重的是，由于服务器资源有限，大量的恶意客户端信息占满了服务器的等待队列，导致服务器不再接收新的SYN请求，正常用户无法完成三次握手与服务器进行通信，这便是SYN Flood攻击。</p><h4 id="DNS-Query-Flood"><a href="#DNS-Query-Flood" class="headerlink" title="DNS Query Flood"></a>DNS Query Flood</h4><p>是 UDP Flood 攻击的一种变形，攻击方式是向被攻击的服务器发送海量的域名解析请求。</p><h4 id="CC-攻击"><a href="#CC-攻击" class="headerlink" title="CC 攻击"></a>CC 攻击</h4><p>Challenge Collapsar 是基于应用层 HTTP 协议发起的 DDoS 攻击，也称为 HTTP Flood。<br><strong>控制大量肉鸡或HTTP代理，有意避开CDN以及分布式缓存，多次DB，从而拖垮后端的业务处理系统。</strong></p><h3 id="其他攻击手段"><a href="#其他攻击手段" class="headerlink" title="其他攻击手段"></a>其他攻击手段</h3><p>DNS域名劫持、CDN回源攻击、服务器权限提升、缓冲区溢出，平台或软件漏洞。</p><h2 id="常用的安全算法"><a href="#常用的安全算法" class="headerlink" title="常用的安全算法"></a>常用的安全算法</h2><h3 id="数字摘要"><a href="#数字摘要" class="headerlink" title="数字摘要"></a>数字摘要</h3><p>也称消息摘要，由一个单向 Hash 函数对消息进行计算而产生。<br><strong>一个 Hash 函数的好坏是由发生碰撞的概率决定的，如果攻击者能够轻易地构造出两个具有相同 Hash 值的消息，那么这样的 Hash 函数是很危险的。可以认为，摘要的长度越长，算法也就越安全。</strong></p><p>摘要的特点:</p><ul><li>无论输入的消息有多长，计算出来的消息摘要长度总是固定的。</li><li>一般只要输入的消息不同，对其进行摘要以后产生的摘要消息也不相同，但输入相同必会产生相同的输出。</li><li>由于消息摘要并不包含原文的信息，因此只能进行正向的信息摘要，而无法从摘要中恢复出原来的消息，甚至根本就找不到任何与原消息相关的信息。</li></ul><h4 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h4><p>Message Digest Algorithm 5(信息摘要算法5)，是数字摘要算法的一种实现，用于确保信息传输完整性和一致性，摘要长度为 128 位。<br>MD5由MD4，MD3，MD2改进而来，主要增强了算法复杂度和不可逆性。<br>基于 Java 的 MD5 算法的使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] testMD5(String content) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">MessageDigest md = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = md.digest(content.getBytes(<span class="string">"utf8"</span>));</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h4><p>Secure Hash Algorithm，即安全散列算法。<br>SHA1 是基于 MD4 算法的，现在已成为公认的最安全的散列算法之一。<br><strong>SHA-1 算法生成的摘要信息长度为160位，由于生成的摘要信息更长，运算的过程更加复杂，在相同的硬件上，SHA-1 的运行速度比MD5更慢，但是也更为安全。</strong>  </p><p>基于 Java 的 SHA-1 算法的使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] testSHA1(String content) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">MessageDigest md = MessageDigest.getInstance(<span class="string">"SHA-1"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = md.digest(content.getBytes(<span class="string">"utf8"</span>));</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>由于计算出的摘要转换成字符串，可能会生成一些无法显示和网络传输的控制字符，因此，需要对生成的摘要字符串进行编码，常用的编码方式包括十六进制编码与 Base64 编码。</em></p><h4 id="十六进制编码"><a href="#十六进制编码" class="headerlink" title="十六进制编码"></a>十六进制编码</h4><p>基于 Java 的十六进制编码与解码的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">bytes2hex</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">StringBuilder hex = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="keyword">byte</span>[i];</span><br><span class="line"><span class="keyword">boolean</span> negative = <span class="keyword">false</span>; <span class="comment">// 是否为负数</span></span><br><span class="line"><span class="keyword">if</span> (b &lt; <span class="number">0</span>) negative = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">int</span> inte = Math.abs(b);</span><br><span class="line"><span class="keyword">if</span> (negative) inte = inte | <span class="number">0x80</span>; </span><br><span class="line"><span class="comment">// 负数会转成正数（最高位的负号变成数值计算），再转十六进制</span></span><br><span class="line">String temp = Integer.toHexString(inte &amp; <span class="number">0xFF</span>); <span class="comment">// &amp;0xff可以将高的24位置为0，低8位保持原样</span></span><br><span class="line"><span class="keyword">if</span> (temp.length() == <span class="number">1</span>) &#123;</span><br><span class="line">hex.append(<span class="string">"0"</span>);</span><br><span class="line">&#125;</span><br><span class="line">hex.append(temp.toLowerCase());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hex.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] hex2bytes(String hex) &#123;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[hex.length()/<span class="number">2</span>]; <span class="comment">// 8位二进制可以转换为两位16进制</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hex.length(); i = i + <span class="number">2</span>) &#123;</span><br><span class="line">String subStr = hex.substring(i, i + <span class="number">2</span>);</span><br><span class="line"><span class="keyword">boolean</span> negative = <span class="keyword">false</span>; <span class="comment">// 是否为负数</span></span><br><span class="line"><span class="keyword">int</span> inte = Integer.parseInt(subStr, <span class="number">16</span>);</span><br><span class="line"><span class="keyword">if</span> (inte &gt; <span class="number">127</span>) negative = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (inte == <span class="number">128</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> = -<span class="number">128</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line">inte = <span class="number">0</span> - (inte &amp; <span class="number">0x7F</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)inte;</span><br><span class="line">bytes[i/<span class="number">2</span>] = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>由于 Java 中没有无符号整型，解码时需要先将符号位进行还原，再对数值进行转换。</strong></p><h4 id="Base64-编码"><a href="#Base64-编码" class="headerlink" title="Base64 编码"></a>Base64 编码</h4><p>是一个基于 64 个可打印字符来表示二进制数据的方法，每6位为一个单元。<br>Base64编码要求把3个8位字节（38=24）转化为4个6位的字节（46=24），之后在6位的前面补两个0，形成8位一个字节的形式。<br><strong>Base64不是一种加密算法，仅仅是一种编码算法而已。它可以将一组二进制信息编码成可打印的字符，在网络上传输与展现。</strong></p><p>基于 Java 的 Base64 算法的使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">byte2base64</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">BASE64Encoder base64Encoder = <span class="keyword">new</span> BASE64Encoder();</span><br><span class="line"><span class="keyword">return</span> base64Encoder.encode(bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] base642byte(String base64) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">BASE64Decoder base64Decoder = <span class="keyword">new</span> BASE64Decoder();</span><br><span class="line"><span class="keyword">return</span> base64Decoder.decodeBuffer(base64);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="彩虹表破解-Hash-算法"><a href="#彩虹表破解-Hash-算法" class="headerlink" title="彩虹表破解 Hash 算法"></a>彩虹表破解 Hash 算法</h4><p>Rainbow Table 法是一种破解哈希算法的技术，从原理上来说能够对任何一种 Hash 算法进行攻击。<br>采用穷举法，理论上彩虹的大小是可以无穷大的。</p><h3 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h3><p>加密和解密方事先都必须知道加密的密钥。</p><blockquote><p>对称加密算法的特点是算法公开、计算量小、加密速度快、加密速率高。优势在于加解密的高速度和使用长密钥时的难破解性，但是，对称加密算法的安全性依赖于密钥，泄露密钥就意味着任何人都可以对加密的密文进行解密。</p></blockquote><h4 id="DES-算法"><a href="#DES-算法" class="headerlink" title="DES 算法"></a>DES 算法</h4><p>DES 算法属于对称加密算法，明文按 64 位进行分组，密钥长 64 位，但事实上只有 56 位参与DES运算(8的倍数位为校验位)，分组后的明文和56位的密钥按位替代或交换的方法形成密文。<br>3DES 是DES向AES过渡的加密算法，它使用3条56位的密钥对数据进行3次加密，是DES的一个更安全的变形。<br>基于 Java 的 DES 算法的使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 生成 DES 密钥</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">genKeyDES</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">KeyGenerator keyGen = keyGenerator.getInstance(<span class="string">"DES"</span>);</span><br><span class="line">keyGen.init(<span class="number">56</span>);</span><br><span class="line">SecretKey key = keyGen.generateKey();</span><br><span class="line">String base64Str = byte2base64(key.getEncoded());</span><br><span class="line"><span class="keyword">return</span> base64Str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecretKey <span class="title">loadKeyDES</span><span class="params">(String base64Key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = base642byte(base64Key);</span><br><span class="line">SecretKey key = <span class="keyword">new</span> SecretKeySpec(bytes, <span class="string">"DES"</span>);</span><br><span class="line"><span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 加密与解密</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encryptDES(<span class="keyword">byte</span>[] source, SecretKey key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">Cipher cipher = Cipher.getInstance(<span class="string">"DES"</span>);</span><br><span class="line">cipher.init(Cipher.ENCRYPT_MODE, key);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = cipher.doFinal(source);</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decryptDES(<span class="keyword">byte</span>[] source, SecretKey key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">Cipher cipher = Cipher.getInstance(<span class="string">"DES"</span>);</span><br><span class="line">cipher.init(Cipher.DECRYPT_MODE, key);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = cipher.doFinal(source);</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="AES-算法"><a href="#AES-算法" class="headerlink" title="AES 算法"></a>AES 算法</h4><p>Advanced Encryption Standard，即高级加密标准。<br>AES 算法作为新一代的数据加密标准，汇聚了强安全性、高性能、高效率、易用和灵活等优点，设计有三个密钥长度(128，192，256位)，比 DES 算法的加密强度更高，更为安全。<br>基于 Java 的AES 算法的使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 生成 AES 密钥</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">genKeyAES</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">KeyGenerator keyGen = keyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">keyGen.init(<span class="number">128</span>);</span><br><span class="line">SecretKey key = keyGen.generateKey();</span><br><span class="line">String base64Str = byte2base64(key.getEncoded());</span><br><span class="line"><span class="keyword">return</span> base64Str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecretKey <span class="title">loadKeyAES</span><span class="params">(String base64Key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = base642byte(base64Key);</span><br><span class="line">SecretKey key = <span class="keyword">new</span> SecretKeySpec(bytes, <span class="string">"AES"</span>);</span><br><span class="line"><span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 加密与解密</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encryptAES(<span class="keyword">byte</span>[] source, SecretKey key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">Cipher cipher = Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">cipher.init(Cipher.ENCRYPT_MODE, key);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = cipher.doFinal(source);</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decryptDES(<span class="keyword">byte</span>[] source, SecretKey key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">Cipher cipher = Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">cipher.init(Cipher.DECRYPT_MODE, key);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = cipher.doFinal(source);</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>由于美国对于加密软件出口的控制，如果使用192位和256位的密钥，则需要另外下载无政策和司法限制的文件，否则程序运行时会出现异常。</strong></p><h3 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h3><p>如果使用公钥对数据进行加密，只有用对应的私钥才能进行解密，而如果使用私钥对数据进行加密，那么只有用对应的公钥才能进行解密。因为加密和解密使用的是两个不同的密钥，所以这种算法称为非对称加密算法。</p><h4 id="RSA-算法"><a href="#RSA-算法" class="headerlink" title="RSA 算法"></a>RSA 算法</h4><blockquote><p>RSA 是目前最有影响力的非对称加密算法，它能够抵抗到目前为止已知的所有密码攻击，已被 ISO 推荐为公钥数据加密标准。<br>RSA 算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但反过来对其乘积进行因式分解却及其困难，因此可以将乘积公开作为加密密钥。<br>基于Java 的 RSA 算法的使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 生成公钥与私钥</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KeyPair <span class="title">getKeyPair</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">keyPairGenerator.initialize(<span class="number">512</span>);</span><br><span class="line">KeyPair keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line"><span class="keyword">return</span> keyPair;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPublicKey</span><span class="params">(KeyPair keyPair)</span> </span>&#123;</span><br><span class="line">PrivateKey publicKey = KeyPair.getPublic();</span><br><span class="line"><span class="keyword">byte</span>[] bytes = publicKey.getEncoded();</span><br><span class="line"><span class="keyword">return</span> byte2base64(bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPrivateKey</span><span class="params">(KeyPair keyPair)</span> </span>&#123;</span><br><span class="line">PrivateKey privateKey = KeyPair.getPrivate();</span><br><span class="line"><span class="keyword">byte</span>[] bytes = privateKey.getEncoded();</span><br><span class="line"><span class="keyword">return</span> byte2base64(bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将 String 类型的密钥转换为 PublicKey 和 PrivateKey 对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PublicKey <span class="title">string2PublicKey</span><span class="params">(String pubStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] keyBytes = base642byte(pubStr);</span><br><span class="line">X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(keyBytes);</span><br><span class="line">KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">PublicKey publickey = KeyFactory.generatePublic(keySpec);</span><br><span class="line"><span class="keyword">return</span> publicKey;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PrivateKey <span class="title">string2PrivateKey</span><span class="params">(String priStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] keyBytes = base642byte(priStr);</span><br><span class="line">X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(keyBytes);</span><br><span class="line">KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">PrivateKey privatekey = KeyFactory.generatePrivate(keySpec);</span><br><span class="line"><span class="keyword">return</span> privatekey;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用公钥加密，私钥解密</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] publicEncrypt(<span class="keyword">byte</span>[] content, publicKey) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = cipher.doFinal(content);</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] privateEncrypt(<span class="keyword">byte</span>[] content, privateKey) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = cipher.doFinal(content);</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><blockquote><p>签名认证是非对称加密技术与数字摘要技术的综合运用，指的是将通信内容的摘要信息使用发送者的私钥进行加密，然后将密文与原文一起传输给信息的接收者，接受者通过发送者的公钥解密被加密的摘要信息，然后使用与发送者相同的摘要算法，对接收到的内容采用相同的方式产生摘要串，与解密的摘要串进行对比，如果相同，则说明接收到的内容是完整的，在传输过程中没有受到第三方篡改，否则说明通信内容已被第三方修改。</p></blockquote><h4 id="MD5withRSA"><a href="#MD5withRSA" class="headerlink" title="MD5withRSA"></a>MD5withRSA</h4><p>算法实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] sign(<span class="keyword">byte</span>[] content, PrivateKey privateKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">MessageDigest md = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = md.digest(content);</span><br><span class="line">Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">cipher.init(Cipher.ENCRYPT_MODE, privateKey);</span><br><span class="line"><span class="keyword">byte</span>[] encryptBytes = cipher.doFinal(bytes);</span><br><span class="line"><span class="keyword">return</span> encryptBytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(<span class="keyword">byte</span>[] content, <span class="keyword">byte</span>[] sign, PublicKey publicKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">MessageDigest md = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = md.digest(content);</span><br><span class="line">Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">cipher.init(Cipher.DECRYPT_MODE, publicKey);</span><br><span class="line"><span class="keyword">byte</span>[] decryptBytes = cipher.doFinal(sign);</span><br><span class="line"><span class="keyword">if</span> (byte2base64(decryptBytes).equals(byte2base64(bytes))) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>基于 Java 的 Signature API 的使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] sign(<span class="keyword">byte</span>[] content, PrivateKey privateKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">Signature signature = Signature.getInstance(<span class="string">"MD5withRSA"</span>);</span><br><span class="line">signature.initSign(privateKey);</span><br><span class="line">signature.update(content);</span><br><span class="line"><span class="keyword">return</span> signature.sign();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(<span class="keyword">byte</span>[] content, <span class="keyword">byte</span>[] sign, PublicKey publicKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Signature signature = Signature.getInstance(<span class="string">"MD5withRSA"</span>);</span><br><span class="line">signature.initSign(publicKey);</span><br><span class="line">signature.update(content);</span><br><span class="line"><span class="keyword">return</span> signature.verify(sign);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="SHA1withRSA"><a href="#SHA1withRSA" class="headerlink" title="SHA1withRSA"></a>SHA1withRSA</h4><p>算法实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] sign(<span class="keyword">byte</span>[] content, PrivateKey privateKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">MessageDigest md = MessageDigest.getInstance(<span class="string">"SHA1"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = md.digest(content);</span><br><span class="line">Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">cipher.init(Cipher.ENCRYPT_MODE, privateKey);</span><br><span class="line"><span class="keyword">byte</span>[] encryptBytes = cipher.doFinal(bytes);</span><br><span class="line"><span class="keyword">return</span> encryptBytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(<span class="keyword">byte</span>[] content, <span class="keyword">byte</span>[] sign, PublicKey publicKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">MessageDigest md = MessageDigest.getInstance(<span class="string">"SHA1"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = md.digest(content);</span><br><span class="line">Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">cipher.init(Cipher.DECRYPT_MODE, publicKey);</span><br><span class="line"><span class="keyword">byte</span>[] decryptBytes = cipher.doFinal(sign);</span><br><span class="line"><span class="keyword">if</span> (byte2base64(decryptBytes).equals(byte2base64(bytes))) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>基于 Java 的 Signature API 的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] sign(<span class="keyword">byte</span>[] content, PrivateKey privateKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">Signature signature = Signature.getInstance(<span class="string">"SHA1withRSA"</span>);</span><br><span class="line">signature.initSign(privateKey);</span><br><span class="line">signature.update(content);</span><br><span class="line"><span class="keyword">return</span> signature.sign();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(<span class="keyword">byte</span>[] content, <span class="keyword">byte</span>[] sign, PublicKey publicKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Signature signature = Signature.getInstance(<span class="string">"SHA1withRSA"</span>);</span><br><span class="line">signature.initSign(publicKey);</span><br><span class="line">signature.update(content);</span><br><span class="line"><span class="keyword">return</span> signature.verify(sign);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>Digital Certificate 也称电子证书。集合了多种密码学的加密算法，证书自身带有公钥信息，可以完成相应的加密，解密操作，同时，还拥有自身信息的数字签名，可以鉴别证书的颁发机构，以及证书内容的完整性。由于证书本身含有用户的认证信息，因此可以作为用户身份识别的依据。<br>内容：</p><ul><li>对象的名称(人，组织，服务器)</li><li>证书的过期时间</li><li>证书的颁发机构(谁为证书担保)</li><li>证书颁发机构对证书信息的数字签名</li><li>签名算法</li><li>对象的公钥</li></ul><p><strong>数字证书一般采用 Base64 编码后再进行存储</strong></p><h4 id="X-509"><a href="#X-509" class="headerlink" title="X.509"></a>X.509</h4><p>提供了一种标准的方式，将证书信息规范地存储到一系列可解析的字段当中。</p><h4 id="证书签发"><a href="#证书签发" class="headerlink" title="证书签发"></a>证书签发</h4><p>需要由数字证书认证机构(Certificate Authority，CA)来进行颁发，只有经过 CA 颁发的数字证书在网络中才具备可认证性。</p><blockquote><p>数字证书的签发过程实际上就是对数字证书的内容，包括证书代表对象的公钥进行数字签名，而验证证书的过程，实际上是验证证书的数字签名，包含了对证书有效期的验证。</p></blockquote><h4 id="证书检验"><a href="#证书检验" class="headerlink" title="证书检验"></a>证书检验</h4><p>客户端接收到数字证书时，首先会检查证书的认证机构，如果该机构是权威的证书认证机构，则通过该权威认证机构的根证书获得证书颁发者的公钥，通过该公钥，对证书的数字签名进行检验，并验证证书的有效时间是否过期。</p><blockquote><p>根证书是证书认证机构给自己颁发的数字证书，是证书信任链的起始点，安装根证书则意味着对这个证书认证机构的信任。<br>证书链的终点就是根证书。</p></blockquote><h4 id="证书管理"><a href="#证书管理" class="headerlink" title="证书管理"></a>证书管理</h4><p>任何机构或者个人都可以申请数字证书。</p><h5 id="keytool"><a href="#keytool" class="headerlink" title="keytool"></a>keytool</h5><p>是 Java 的数字证书管理工具，用于数字证书的生成、导入、导出与撤销等操作。</p><ol><li>构建自签名证书</li><li>证书导出</li><li>导出CSR</li><li>导入数字证书<h5 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h5>OpenSSL 包含一个开源的 SSL 协议的实现，虽然 OpenSSL 使用 SSL 作为其名字的重要组成部分，到实现的功能却远远超出了 SSL 协议本身。<br>包含三个组成部分：</li></ol><ul><li>SSL协议库</li><li>密码算法库</li><li>各种与之相关的应用程序</li></ul><ol><li>安装</li><li>配置</li><li>生成 OpenSSL 根证书</li><li>OpenSSL 签发服务端证书</li><li>OpenSSL 签发客户端证书</li></ol><h5 id="证书的使用"><a href="#证书的使用" class="headerlink" title="证书的使用"></a>证书的使用</h5><p>证书除包含一些认证信息以外，还包含了证书持有人的公钥，外界获得证书以后，可以使用对相关信息进行加密，而信息接收方则使用私钥进行解密。</p><h2 id="摘要认证"><a href="#摘要认证" class="headerlink" title="摘要认证"></a>摘要认证</h2><blockquote><p>相对于基于 TCP 协议层面的通信方式，针对 HTTP 协议的攻击门槛更低，因此，基于 HTTP 协议的 Web 与 SOA 架构，在应用的安全性方面需要更加重视。</p></blockquote><h3 id="摘要认证的原理"><a href="#摘要认证的原理" class="headerlink" title="摘要认证的原理"></a>摘要认证的原理</h3><blockquote><p>鉴于使用 HTTPS 性能上的成本以及需要额外申请 CA 证书，在这种情况下，一般采用对参数和响应进行摘要的方法，即能够满足需求。<br>由于传递端和接收端都认为 HTTP 协议的请求参数是无序的，因此客户端与服务端双方需要约定好参数的排序方式。请求的参数经过排序后，再将参数名称和值经过一定的策略组织起来，加上一个密钥 secret，也就是所谓的盐，然后通过约定的摘要算法生成数字摘要，传递给服务端。<br>但是，摘要的安全性取决于secret的安全性。</p></blockquote><h3 id="摘要认证的实现"><a href="#摘要认证的实现" class="headerlink" title="摘要认证的实现"></a>摘要认证的实现</h3><h4 id="客户端参数摘要生成"><a href="#客户端参数摘要生成" class="headerlink" title="客户端参数摘要生成"></a>客户端参数摘要生成</h4><p>基于 Java 客户端参数摘要生成的部分关键代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getDigest</span><span class="params">(Map&lt;String, String&gt; params)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String secret = <span class="string">"abcdefjhijklmn"</span>;</span><br><span class="line">Set&lt;String&gt; keySet = params.keySet();</span><br><span class="line"><span class="comment">// 使用 treeSet 排序</span></span><br><span class="line">TreeSet&lt;String&gt; sortSet = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">sortSet.addAll(keySet);</span><br><span class="line">String keyvalueStr = <span class="string">""</span>;</span><br><span class="line">Iterator&lt;String&gt; it = sortSet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">String key = it.next();</span><br><span class="line">String value = params.get(key);</span><br><span class="line">keyvalueStr += key + value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">keyvalueStr += secret;</span><br><span class="line">String base64Str = byte2base64(getMD5(keyvalueStr));</span><br><span class="line"><span class="keyword">return</span> base64Str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="服务端参数摘要校验"><a href="#服务端参数摘要校验" class="headerlink" title="服务端参数摘要校验"></a>服务端参数摘要校验</h4><p>基于 Java 服务端参数摘要校验的部分关键代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(Map params, String digest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String secret = <span class="string">"abcdefjhijklmn"</span>;</span><br><span class="line">Set&lt;String&gt; keySet = params.keySet();</span><br><span class="line"><span class="comment">// 使用 treeSet 排序</span></span><br><span class="line">TreeSet&lt;String&gt; sortSet = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">sortSet.addAll(keySet);</span><br><span class="line">String keyvalueStr = <span class="string">""</span>;</span><br><span class="line">Iterator&lt;String&gt; it = sortSet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">String key = it.next();</span><br><span class="line">String value = params.get(key);</span><br><span class="line">keyvalueStr += key + value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">keyvalueStr += secret;</span><br><span class="line">String base64Str = byte2base64(getMD5(keyvalueStr));</span><br><span class="line"><span class="keyword">if</span>(base64Str.equals(digest)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="服务端响应摘要生成"><a href="#服务端响应摘要生成" class="headerlink" title="服务端响应摘要生成"></a>服务端响应摘要生成</h4><p>基于 Java 服务端响应摘要生成的部分关键代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getDigest</span><span class="params">(String content)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String secret = <span class="string">"abcdefjhijklmn"</span>;</span><br><span class="line">content += secret;</span><br><span class="line">String base64Str = byte2base64(getMD5(content));</span><br><span class="line"><span class="keyword">return</span> base64Str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="客户端响应摘要校验"><a href="#客户端响应摘要校验" class="headerlink" title="客户端响应摘要校验"></a>客户端响应摘要校验</h4><p>基于 Java 客户端响应摘要校验的部分关键代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String responseContent, String digest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String secret = <span class="string">"abcdefjhijklmn"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = getMD5(responseContent + secret);</span><br><span class="line">String responseDigest = byte2base64(bytes);</span><br><span class="line"><span class="keyword">if</span> (responseDigest.equals(digest)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="签名认证"><a href="#签名认证" class="headerlink" title="签名认证"></a>签名认证</h2><h3 id="签名认证的原理"><a href="#签名认证的原理" class="headerlink" title="签名认证的原理"></a>签名认证的原理</h3><p>类似摘要认证，但签名认证不再加上 secret ，而是直接通过约定的摘要算法来生成数字摘要，并且使用客户端私钥对数字摘要进行加密，将加密的密文传递给服务端。</p><h3 id="签名认证的实现"><a href="#签名认证的实现" class="headerlink" title="签名认证的实现"></a>签名认证的实现</h3><h4 id="客户端参数签名生成"><a href="#客户端参数签名生成" class="headerlink" title="客户端参数签名生成"></a>客户端参数签名生成</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getSign</span><span class="params">(Map&lt;String, String&gt; params)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Set&lt;String&gt; keySet = params.keySet();</span><br><span class="line"><span class="comment">// 使用 treeSet 排序</span></span><br><span class="line">TreeSet&lt;String&gt; sortSet = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">sortSet.addAll(keySet);</span><br><span class="line">String keyvalueStr = <span class="string">""</span>;</span><br><span class="line">Iterator&lt;String&gt; it = sortSet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext) &#123;</span><br><span class="line">String key = it.next();</span><br><span class="line">String value = params.get(key);</span><br><span class="line">keyvalueStr += key + value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] md5Bytes = getMD5(keyvalueStr);</span><br><span class="line">PrivateKey privateKey = AsymmetricalUtil.string2PrivateKey(consumerPrivateKey);</span><br><span class="line"><span class="keyword">byte</span>[] encryptBytes = AsymmetricalUtil.privateEncrypt(md5Bytes, privateKey);</span><br><span class="line">String hexStr = byte2hex(encryptBytes);</span><br><span class="line"><span class="keyword">return</span> hexStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用 Java API 对客户端请求进行数字签名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getSign</span><span class="params">(Map&lt;String, String&gt; params)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Set&lt;String&gt; keySet = params.keySet();</span><br><span class="line"><span class="comment">// 使用 treeSet 排序</span></span><br><span class="line">TreeSet&lt;String&gt; sortSet = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">sortSet.addAll(keySet);</span><br><span class="line">String keyvalueStr = <span class="string">""</span>;</span><br><span class="line">Iterator&lt;String&gt; it = sortSet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">String key = it.next();</span><br><span class="line">String value = params.get(key);</span><br><span class="line">keyvalueStr += key + value;</span><br><span class="line">&#125;</span><br><span class="line">PrivateKey privateKey = AsymmetricalUtil.string2PrivateKey(consumerPrivateKey);</span><br><span class="line">Signature signature = Signature.getInstance(<span class="string">"MD5withRSA"</span>);</span><br><span class="line">signature.initSign(privateKey);</span><br><span class="line">signature.update(keyvalueStr.getBytes());</span><br><span class="line"><span class="keyword">return</span> byte2hex(signature.sign());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务端参数签名校验"><a href="#服务端参数签名校验" class="headerlink" title="服务端参数签名校验"></a>服务端参数签名校验</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(Map params, String digest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Set&lt;String&gt; keySet = params.keySet();</span><br><span class="line"><span class="comment">// 使用 treeSet 排序</span></span><br><span class="line">TreeSet&lt;String&gt; sortSet = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">sortSet.addAll(keySet);</span><br><span class="line">String keyvalueStr = <span class="string">""</span>;</span><br><span class="line">Iterator&lt;String&gt; it = sortSet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">String key = it.next();</span><br><span class="line">String value = params.get(key);</span><br><span class="line">keyvalueStr += key + value;</span><br><span class="line">&#125;</span><br><span class="line">String hexStr = byte2hex(getMD5(keyvalueStr));</span><br><span class="line">PublicKey publickey = AsymmetricalUtil.string2PublicKey(consumerPublicKey);</span><br><span class="line"><span class="keyword">byte</span>[] decryptBytes = AsymmetricalUtil.publicDecrypt(hex2bytes(digest), publickey);</span><br><span class="line">String decryptDigest = bytes2hex(decryptBytes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(hexStr.equals(decryptDigest)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用 Java 数字签名 API 对客户端进行数字签名校验</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(Map params, String sign)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Set&lt;String&gt; keySet = params.keySet();</span><br><span class="line"><span class="comment">// 使用 treeSet 排序</span></span><br><span class="line">TreeSet&lt;String&gt; sortSet = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">sortSet.addAll(keySet);</span><br><span class="line">String keyvalueStr = <span class="string">""</span>;</span><br><span class="line">Iterator&lt;String&gt; it = sortSet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">String key = it.next();</span><br><span class="line">String value = params.get(key);</span><br><span class="line">keyvalueStr += key + value;</span><br><span class="line">&#125;</span><br><span class="line">PublicKey publickey = AsymmetricalUtil.string2PublicKey(consumerPublicKey);</span><br><span class="line">Signature signature = Signature.getInstance(<span class="string">"MD5withRSA"</span>);</span><br><span class="line">signature.initVerify(publickey);</span><br><span class="line">signature.update(keyvalueStr.getBytes());</span><br><span class="line"><span class="keyword">return</span> signature.verify(hex2bytes(sign));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务端响应签名生成"><a href="#服务端响应签名生成" class="headerlink" title="服务端响应签名生成"></a>服务端响应签名生成</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getSign</span><span class="params">(String content)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] md5Bytes = getMD5(content);</span><br><span class="line">PrivateKey privatekey = AsymmetricalUtil.string2PrivateKey(providePrivateKey);</span><br><span class="line"><span class="keyword">byte</span>[] encryptBytes = AsymmetricalUtil.privateEncrypt(md5Bytes, privateKey);</span><br><span class="line">String hexStr = bytes2hex(encryptBytes);</span><br><span class="line"><span class="keyword">return</span> hexStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用 Java 数字签名 API 生成服务器端响应的数字签名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getSign</span><span class="params">(String content)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">PrivateKey privatekey = AsymmetricalUtil.string2PrivateKey(providePrivateKey);</span><br><span class="line">Signature signature = Signature.getInstance(<span class="string">"MD5withRSA"</span>);</span><br><span class="line">signature.initSign(privateKey);</span><br><span class="line">signature.update(content.getBytes());</span><br><span class="line">String hexStr = bytes2hex(signature.sign());</span><br><span class="line"><span class="keyword">return</span> hexStr;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">#### 客户端响应签名校验</span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String responseContent, String digest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = getMD5(responseContent);</span><br><span class="line">String responseDigest = bytes2hex(bytes);</span><br><span class="line"></span><br><span class="line">PublicKey publickey = AsymmetricalUtil.string2PublicKey(providerPublicKey);</span><br><span class="line"><span class="keyword">byte</span>[] decryptBytes = AsymmetricalUtil.publicDecrypt(hex2bytes(digest), publickey);</span><br><span class="line">String decryptDigest = byte2hex(decryptBytes);</span><br><span class="line"><span class="keyword">if</span>(responseContent.equals(decryptBytes)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用 Java 数字签名 API 对服务端响应数字签名的校验</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String responseContent, String sign)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">PublicKey publickey = AsymmetricalUtil.string2PrivateKey(providePublicKey);</span><br><span class="line">Signature signature = Signature.getInstance(<span class="string">"MD5withRSA"</span>);</span><br><span class="line">signature.initVerify(publickey);</span><br><span class="line">signature.update(content.getBytes());</span><br><span class="line">String hexStr = bytes2hex(responseContent.getBytes());</span><br><span class="line"><span class="keyword">return</span> signature.verify(hex2bytes(sign));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="HTTPS 协议"></a>HTTPS 协议</h2><h3 id="HTTPS-协议原理"><a href="#HTTPS-协议原理" class="headerlink" title="HTTPS 协议原理"></a>HTTPS 协议原理</h3><p>Hypertext Transfer Protocol over Secure Socket Layer，即基于 SSL 的 HTTP 协议。<br>HTTPS 协议在 HTTP 协议与 TCP 协议增加了一层安全层，所有请求和响应数据在经过网络传输之前，都会先进行加密，然后再进行传输。<br>HTTPS 既支持单向认证，也支持双向认证。</p><h3 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL TLS"></a>SSL TLS</h3><p>Secure Sockets Layer，即安全套接层。<br>SSL 协议的优势在于它与应用层协议独立无关，高层的应用协议如 HTTP、SSH、FTP等等，能透明的建立于 SSL 协议之上，在应用层通信之前就已经完成加密算法、通信密钥的协商以及服务端及客户端的认证工作，在此之后所有应用层协议所传输的数据都会被加密，从而保证通信的私密性。<br>SSL 的继任者是 TLS 协议，全称为 Transport Layer Security，即传输层安全协议，是基于 SSL 协议的通用化协议。</p><p>SSL TLS协议均可分为两层：</p><ul><li>Record Protocol 记录协议 建立在可靠的传输协议(如TCP)之上，提供数据封装、加密解密、数据压缩、数据校验等基本功能。</li><li>Handshake Protocol 握手协议 在实际的数据传输开始前，进行加密算法的协商，通过密钥的交换，通信双方身份的认证等工作。</li></ul><blockquote><p>JSSE(Java Security Socket Extension)是 sun 公司为了解决互联网信息安全传输提出的一个解决方案，它实现了 SSL 和 TSL 协议，包含了数据加密、服务器验证、消息完整性和客户端验证等技术。</p></blockquote><p>首先，将生成的客户端私钥和数字证书进行导出，生成 Java 环境可用的 keystore 文件。<br>Java 实现的通信客户端<br>SSLSocket 初始化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String host = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="keyword">int</span> port = <span class="number">1234</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含客户端的私钥与服务端的证书</span></span><br><span class="line">String keystorePath = <span class="string">"/home/user/temp/testssl/client.keystore"</span>;</span><br><span class="line">String trustKeystorePath = <span class="string">"home/user/temp/testssl/ca-trust.keystore"</span>;</span><br><span class="line">String keystorePassword = <span class="string">"123456"</span>;</span><br><span class="line"></span><br><span class="line">SSLContext sslContext = sslContext.getInstance(<span class="string">"SSL"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 密钥库</span></span><br><span class="line">KeyManagerFactory kmf = KeyManagerFactory.getInstance(<span class="string">"sunx509"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信任库</span></span><br><span class="line">TrustManagerFactory tmf = TrustManagerFactory.getInstance(<span class="string">"sunx509"</span>);</span><br><span class="line"></span><br><span class="line">KeyStore keyStore = KeyStore.getInstance(<span class="string">"pkcs12"</span>);</span><br><span class="line">KeyStore trustKeystore = KeyStore.getInstance(<span class="string">"jks"</span>);</span><br><span class="line"></span><br><span class="line">FileInputStream keystoreFis = <span class="keyword">new</span> FileInputStream(keystorePath);</span><br><span class="line">keystore.load(keystoreFis, keystorePassword.toCharArray);</span><br><span class="line"></span><br><span class="line">FileInputStream trustKeystoreFis = <span class="keyword">new</span> FileInputStream(trustKeystorePath);</span><br><span class="line">trustKeystore.load(trustKeystoreFis, keystorePassword.toCharArray());</span><br><span class="line"></span><br><span class="line">kmf.init(keystore, keystorePassword.toCharArray());</span><br><span class="line">tmf.init(trustKeystore);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文初始化</span></span><br><span class="line">sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// SSLSocket 初始化</span></span><br><span class="line">sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket(host, port);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>进行 SSL 通信：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String hello = <span class="string">"hello yeonsea!"</span>;</span><br><span class="line">OutputStream output = sslSocket.getOutputStream();</span><br><span class="line">output.write(hello.getBytes(), <span class="number">0</span>, hello.getBytes().length);</span><br><span class="line">output.flush();</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] inputBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">InputStream input = sslSocket.getInputStream();</span><br><span class="line">input.read(inputBytes);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(inputBytes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Java 实现的通信服务端<br>SSLServerSocket 初始化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">int</span> port = <span class="number">1234</span>;</span><br><span class="line"><span class="comment">// keystore 中包含服务端的私钥与服务端的证书</span></span><br><span class="line">String keystorePath = <span class="string">"/home/user/temp/testssl/server.keystore"</span>;</span><br><span class="line">String trustKeystorePath = <span class="string">"/home/user/temp/testssl/ca-trust.keystore"</span>;</span><br><span class="line">String keystorePassword = <span class="string">"123456"</span>;</span><br><span class="line"></span><br><span class="line">SSLContext sslContext = SSLContext.getInstance(<span class="string">"SSL"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 密钥库</span></span><br><span class="line">KeyManagerFactory kmf = KeyManagerFactory.getInstance(<span class="string">"sunx509"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信任库</span></span><br><span class="line">TrustManagerFactory tmf = TrustManagerFactory.getInstance(<span class="string">"sunx509"</span>);</span><br><span class="line"></span><br><span class="line">KeyStore keyStore = KeyStore.getInstance(<span class="string">"pkcs12"</span>);</span><br><span class="line">KeyStore trustKeystore = KeyStore.getInstance(<span class="string">"jks"</span>);</span><br><span class="line"></span><br><span class="line">FileInputStream keystoreFis = <span class="keyword">new</span> FileInputStream(keystorePath);</span><br><span class="line">keystore.load(keystoreFis, keystorePassword.toCharArray);</span><br><span class="line"></span><br><span class="line">FileInputStream trustKeystoreFis = <span class="keyword">new</span> FileInputStream(trustKeystorePath);</span><br><span class="line">trustKeystore.load(trustKeystoreFis, keystorePassword.toCharArray());</span><br><span class="line"></span><br><span class="line">kmf.init(keystore, keystorePassword.toCharArray());</span><br><span class="line">tmf.init(trustKeystore);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文初始化</span></span><br><span class="line">sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">serverSocket =(SSLServerSocket).getSocketFactory().createServerSocket(port);</span><br><span class="line">serverSocket.setNeedClientAuth(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>处理 SSL 请求：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String bye = <span class="string">"bye bye"</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">Socket socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] inputBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">InputStream input = socket.getInputStream();</span><br><span class="line">input.read(inputBytes);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(inputBytes));</span><br><span class="line"></span><br><span class="line">OutputStream output = socket.getOutputStream();</span><br><span class="line">output.write(bye.getBytes, <span class="number">0</span>, bye.getBytes().length);</span><br><span class="line">output.flush;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="部署-HTTPS-Web"><a href="#部署-HTTPS-Web" class="headerlink" title="部署 HTTPS Web"></a>部署 HTTPS Web</h3><p>以 Tomcat 为例</p><h4 id="Tomcat-单向认证配置"><a href="#Tomcat-单向认证配置" class="headerlink" title="Tomcat 单向认证配置"></a>Tomcat 单向认证配置</h4><p>修改 Tomcat 配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- cd tomcat/conf;    vim server.xml;    找到默认注释的一段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"443"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">SSLEnabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag"><span class="attr">maxThreads</span>=<span class="string">"150"</span> <span class="attr">scheme</span>=<span class="string">"https"</span> <span class="attr">secure</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag"><span class="attr">clientAuth</span>=<span class="string">"false"</span> <span class="attr">sslProtocol</span>=<span class="string">"TLS"</span></span></span><br><span class="line"><span class="tag"><span class="attr">keystoreFile</span>=<span class="string">"home/user/temp/testssl/server.keystore"</span></span></span><br><span class="line"><span class="tag"><span class="attr">keystorePass</span>=<span class="string">"123456"</span></span></span><br><span class="line"><span class="tag"><span class="attr">keystoreType</span>=<span class="string">"pkcs12"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>安装 authbind<br>配置443端口<br>重启 tomcat</p><h4 id="Tomcat-双向认证的配置"><a href="#Tomcat-双向认证的配置" class="headerlink" title="Tomcat 双向认证的配置"></a>Tomcat 双向认证的配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"443"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">SSLEnabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag"><span class="attr">maxThreads</span>=<span class="string">"150"</span> <span class="attr">scheme</span>=<span class="string">"https"</span> <span class="attr">secure</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag"><span class="attr">clientAuth</span>=<span class="string">"false"</span> <span class="attr">sslProtocol</span>=<span class="string">"TLS"</span></span></span><br><span class="line"><span class="tag"><span class="attr">keystoreFile</span>=<span class="string">"home/user/temp/testssl/server.keystore"</span></span></span><br><span class="line"><span class="tag"><span class="attr">keystorePass</span>=<span class="string">"123456"</span></span></span><br><span class="line"><span class="tag"><span class="attr">keystoreType</span>=<span class="string">"pkcs12"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">truststoreFile</span>=<span class="string">"home/user/temp/testssl/ca-trust.keystore"</span></span></span><br><span class="line"><span class="tag"><span class="attr">truststorePass</span>=<span class="string">"123456"</span></span></span><br><span class="line"><span class="tag"><span class="attr">truststoreType</span>=<span class="string">"jks"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="OAuth-协议"><a href="#OAuth-协议" class="headerlink" title="OAuth 协议"></a>OAuth 协议</h2><blockquote><p>随着互联网的深入发展，一些互联网巨头逐渐累积了海量的用户和数据。对于平台级的软件厂商来说，用户需求多种多样，变化万千，以一己之力予以充分满足，难免疲于奔命，因此，将数据以接口的形式下放给众多的第三方开发者，便成了必然趋势。第三方开发者经过二次开发，满足一小部分的用户的独特需求，即能够使自己获得利益，也能够让数据流动起来，在大平台周围形成一个良性的生态环境，最终达到用户、平台商、第三方开发者共赢。</p></blockquote><p>平台商必须保障对于用户私有数据的访问，均是经过用户授权的合法行为，且不会对第三方泄露类似用户名和密码这样的核心数据。</p><h3 id="OAuth-的介绍"><a href="#OAuth-的介绍" class="headerlink" title="OAuth 的介绍"></a>OAuth 的介绍</h3><p>旨在为用户资源的授权访问提供一个安全、开放的标准。</p><h3 id="Oauth-授权过程"><a href="#Oauth-授权过程" class="headerlink" title="Oauth 授权过程"></a>Oauth 授权过程</h3><p>要获得 OAuth 协议授权，首先需要第三方开发者向平台商申请应用 ID，即 appId，对自己的 APP 进行注册。一次 OAuth 授权涵盖了三个角色：普通用户(consumer)、第三方应用(ISV)、平台商(platform)。</p><p><em>OAuth授权是一个相对较复杂的体系，涵盖系统设计的方方面面，不仅包括之前所说的认证过程，还需要解决开发者入驻、权限粒度的控制、token 生成和校验、分布式 Session、公私钥管理等一系列问题。</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Structure Security" scheme="http://yeonsea.club/tags/Structure-Security/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch概览</title>
    <link href="http://yeonsea.club/2019/09/10/Elasticsearch%E6%A6%82%E8%A7%88/"/>
    <id>http://yeonsea.club/2019/09/10/Elasticsearch概览/</id>
    <published>2019-09-10T08:11:35.000Z</published>
    <updated>2019-09-10T08:13:02.399Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>全文搜索引擎<br>基于 Lucene 构建的开源、分布式、RESTful接口</p><p><a href="还是一个分布式文档数据库">^1</a></p><blockquote><p>Github 的搜索是基于 Elasticsearch 构建的，只索引项目主分支，但包括20亿个索引文档，30TB的索引文件</p></blockquote><p>Shay Banon  失业开发者  给妻子构建食谱搜索引擎  早期版本的 Lucene  为方便Java可以在应用中增加搜索功能  第一个开源项目“Compass”</p><p>重写 Compass 使其成为一个独立的项目，Elasticsearch  </p><ul><li>横向可扩展</li><li>分片机制提供更好的分布性：sharding，类似 HDFS 的块机制</li><li>高可用：replica</li><li>使用简单</li></ul><p>Lucene：最初由 Doug Cutting 开发</p><p><em>倒排索引</em></p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>术语概念</p><ul><li>索引词：term</li><li>文本：text</li><li>分析：Analysis</li><li>集群：Cluster</li><li>节点：node</li><li>路由：routing</li><li>分片：shard</li><li>主分片：primary shard</li><li>副本分片：replica shard</li><li>副本：replica</li><li>索引：index 索引是具有相同结构的文档集合</li><li>类型：type 类型是索引的逻辑分区</li><li>文档：document  存储的一个 JSON 格式的字符串</li><li>映射：mapping</li><li>字段：field</li><li>开源字段：source field</li><li>主键：ID</li></ul><blockquote><p>每个 Elasticsearch 分片是一个 Lucene 的索引，有文档存储数量限制</p></blockquote><p>JSON  轻量级数据交换格式</p><h3 id="对外接口"><a href="#对外接口" class="headerlink" title="对外接口"></a>对外接口</h3><p>curl<br>REST：REpresentational State Transfer  表述性状态传输    一种约定    简化沟通成本</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引管理</p><ul><li>创建</li><li>删除</li><li>获取</li><li>打开 关闭</li></ul><p>索引映射管理</p><ul><li>增加映射</li><li>获取索引</li></ul><p>索引别名</p><ul><li>过滤索引别名</li><li>删除别名</li><li>查询现有的别名</li></ul><p>索引配置</p><ul><li>更新索引配置</li><li>获取配置</li><li>索引分析</li></ul><p>索引模板</p><blockquote><p>索引模板就是创建好一个索引参数设置 settings 和 映射 mapping 的模板，在创建新索引的时候指定模板名称就可以使用模板定义好的参数设置和映射</p><ul><li>创建</li><li>删除</li><li>获取</li></ul></blockquote><p>复制配置</p><p>重建索引</p><h3 id="索引监控"><a href="#索引监控" class="headerlink" title="索引监控"></a>索引监控</h3><ul><li>索引统计</li><li>索引分片</li><li>索引恢复</li><li>索引分片存储</li></ul><h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><ul><li>清除缓存</li><li>索引刷新</li><li>冲洗</li><li>合并索引</li></ul><h3 id="文档管理"><a href="#文档管理" class="headerlink" title="文档管理"></a>文档管理</h3><ul><li>增加文档</li><li>更新删除</li><li>查询</li><li>多文档操作</li><li>索引词频率</li><li>查询更新接口</li></ul><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>映射是定义存储和索引文档以及字段的过程</p><ul><li>字段数据类型</li><li>元字段</li><li>映射参数</li><li>动态映射：在 Elasticsearch 中可以不事先建好索引结构，在使用的时候可以直接插入文档到索引。</li></ul><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="深入搜索"><a href="#深入搜索" class="headerlink" title="深入搜索"></a>深入搜索</h3><h4 id="搜索方式"><a href="#搜索方式" class="headerlink" title="搜索方式"></a>搜索方式</h4><ul><li>URL 搜索 GET方式</li><li>POST 请求参数搜索</li><li>排序 sort</li><li>数据列过滤</li><li>脚本支持<h4 id="重新评分"><a href="#重新评分" class="headerlink" title="重新评分"></a>重新评分</h4>对短语进行重新评分，然后再查询<h4 id="滚动查询请求"><a href="#滚动查询请求" class="headerlink" title="滚动查询请求"></a>滚动查询请求</h4>Elasticsearch 提供了滚动 API 来解决此问题，这有点像数据库中的游标<h4 id="隐藏内容查询"><a href="#隐藏内容查询" class="headerlink" title="隐藏内容查询"></a>隐藏内容查询</h4>inner hits    嵌套结构<h4 id="相关搜索函数"><a href="#相关搜索函数" class="headerlink" title="相关搜索函数"></a>相关搜索函数</h4></li><li>Preference  搜索分片副本执行偏好设置</li><li>索引加权  index_boost</li><li>最小分值  min_score</li><li>分值解释  explain  可以使每个命中的查询解释它的得分是如何计算出来的</li><li>分片情况查询  _search_shards</li><li>总分查询  _count</li><li>是否存在查询</li><li>验证接口<h4 id="搜索模板"><a href="#搜索模板" class="headerlink" title="搜索模板"></a>搜索模板</h4><h3 id="查询DSL"><a href="#查询DSL" class="headerlink" title="查询DSL"></a>查询DSL</h3>Domain-specific Language<br>Elasticsearch 提供了基于 JSON 的完整查询 DSL 来定义查询<h4 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h4></li><li>布尔查询</li><li>短语查询</li><li>短语前缀查询</li><li>多字段查询</li><li>Lucene 语法查询</li><li>简化查询<h4 id="字段查询"><a href="#字段查询" class="headerlink" title="字段查询"></a>字段查询</h4></li><li>单字段查询</li><li>多字段查询</li><li>范围查询<h4 id="复合查询"><a href="#复合查询" class="headerlink" title="复合查询"></a>复合查询</h4></li><li>常数得分查询</li><li>布尔查询</li><li>最大值获取查询</li><li>boosting 查询</li><li>指定索引查询</li><li>过滤查询</li><li>限制查询<h4 id="连接查询"><a href="#连接查询" class="headerlink" title="- 连接查询"></a>- 连接查询</h4></li><li>嵌套查询</li><li>父子文档查询<h4 id="地理查询"><a href="#地理查询" class="headerlink" title="地理查询"></a>地理查询</h4>Elasticsearch 支持两种地理数据类型的字段：地理点类型，支持经度纬度对；地理形状类型，支持点、线、圈、多边形、多边形集合等。</li><li>地理形状查询</li><li>地理范围查询</li><li>地理距离查询</li><li>地理距离范围查询</li><li>多边形地理查询</li><li>地理散列单元查询<h4 id="跨度查询"><a href="#跨度查询" class="headerlink" title="跨度查询"></a>跨度查询</h4></li><li>索引词跨度查询</li><li>多索引词跨度查询</li><li>首跨度查询</li><li>接近跨度查询</li><li>或跨度查询</li><li>非跨度查询</li><li>包含跨度查询</li><li>内部跨度查询<h4 id="高亮显示"><a href="#高亮显示" class="headerlink" title="高亮显示"></a>高亮显示</h4>Elasticsearch 中的高亮显示是来源于 Lucene 的功能，允许一个或者多个字段上突出显示搜索内容<h3 id="简化查询"><a href="#简化查询" class="headerlink" title="简化查询"></a>简化查询</h3>catAPI<br>常用简化查询指标</li><li>indices</li><li>nodes</li><li>recovery</li><li>thread pool</li></ul><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><h3 id="聚合分类"><a href="#聚合分类" class="headerlink" title="聚合分类"></a>聚合分类</h3><h4 id="度量聚合"><a href="#度量聚合" class="headerlink" title="度量聚合"></a>度量聚合</h4><ul><li>平均值聚合</li><li>基数聚合</li><li>最大值聚合</li><li>最小值聚合</li><li>和聚合</li><li>值基数聚合</li><li>统计聚合</li><li>百分比聚合</li><li>百分比分级聚合</li><li>最高命中排行聚合</li><li>脚本度量聚合</li><li>地理边界聚合</li><li>地理重心聚合</li></ul><h3 id="分组聚合"><a href="#分组聚合" class="headerlink" title="分组聚合"></a>分组聚合</h3><ul><li>子聚合</li><li>直方图聚合</li><li>日期直方图聚合</li><li>时间范围聚合</li><li>范围聚合</li><li>过滤聚合</li><li>多重过滤聚合</li><li>空值聚合</li><li>嵌套聚合</li><li>采样聚合</li><li>重要索引词聚合</li><li>索引词聚合</li><li>总体聚合</li><li>地理点距离聚合</li><li>地理散列网格聚合</li><li>IPv4 范围聚合<h3 id="管道聚合"><a href="#管道聚合" class="headerlink" title="管道聚合"></a>管道聚合</h3></li><li>平均分组聚合</li><li>移动平均聚合</li><li>总和分组聚合</li><li>总和累计聚合</li><li>最大分组聚合</li><li>最小分组聚合</li><li>统计分组聚合</li><li>百分位分组聚合</li><li>差值聚合</li><li>分组脚本聚合</li><li>串行差分聚合</li><li>分组选择器聚合</li></ul><h2 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h2><h3 id="集群节点监控"><a href="#集群节点监控" class="headerlink" title="集群节点监控"></a>集群节点监控</h3><blockquote><p>对 Elasticsearch 监控的API 主要有三类：一类是集群相关的，以_cluster开头，第二类是监控节点相关的，以_nodes开头，第三类是任务相关的，以_tasks开头</p><ul><li>集群健康值</li><li>集群状态</li><li>集群统计</li><li>集群任务管理</li><li>待定集群任务</li><li>节点信息</li><li>节点统计</li></ul></blockquote><h3 id="集群分片迁移"><a href="#集群分片迁移" class="headerlink" title="集群分片迁移"></a>集群分片迁移</h3><ul><li>移动  remove</li><li>取消  cancel</li><li>分配  allocate</li><li>集群配置更新<h3 id="集群节点配置"><a href="#集群节点配置" class="headerlink" title="集群节点配置"></a>集群节点配置</h3></li><li>主节点  主要职责是和集群操作相关的内容，如创建或删除索引，跟踪哪些节点是集群的一部分，并决定哪些分片分配给相关的节点。</li><li>数据节点  主要是存储索引数据的节点，主要对文档进行增删改查、聚合操作等。</li><li>客户端节点  当主节点和数据节点配置都设置为 false 时，该节点只能处理路由请求，处理搜索，分发索引操作等，从本质上来说该客户端节点表现为智能负载平衡器。独立的客户端节点在一个比较大的集群中是非常有用的，它协调主节点和数据节点，客户端节点加入集群可以得到集群的状态，根据集群的状态可以直接发送路由请求。</li><li>部落节点  部落节点可以跨越多个集群，它可以接收每个集群的状态，然后合并成一个全局集群的状态，它可以读写所有节点上的数据。<h3 id="节点发现"><a href="#节点发现" class="headerlink" title="节点发现"></a>节点发现</h3></li><li>ping 模块</li><li>单播模块<h4 id="主节点选举"><a href="#主节点选举" class="headerlink" title="主节点选举"></a>主节点选举</h4>在集群中，系统会自动通过 ping 来进行选举节点或者加入主节点，这些都是自动完成的。<h4 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h4><h4 id="集群平衡配置"><a href="#集群平衡配置" class="headerlink" title="集群平衡配置"></a>集群平衡配置</h4></li><li>分片分配设置</li><li>基于磁盘的配置</li><li>分片智能分配</li><li>分片配置过滤</li><li>其他集群配置<h2 id="索引分词器"><a href="#索引分词器" class="headerlink" title="索引分词器"></a>索引分词器</h2><h3 id="分词器的概念"><a href="#分词器的概念" class="headerlink" title="分词器的概念"></a>分词器的概念</h3><em>分词器analyzer的作用是当一个文档被索引的时候，分词器从文档中提取出若干词元token来支持索引的存储和搜索。</em><blockquote><p>分词器 是由一个分解器 tokenizer、零个或多个词元过滤器 token filters 组成。</p></blockquote><h3 id="中文分词器"><a href="#中文分词器" class="headerlink" title="中文分词器"></a>中文分词器</h3></li><li>smartcn</li><li>IKAnanlyzer<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3></li><li>java 插件  jar</li><li>站点插件  js html css</li><li>混合插件<h4 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h4>正常情况下插件位于$ES_HOME/bin 下<br>通过rpm等安装的位置可能会不同<h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4></li><li>查询插件</li><li>删除插件</li><li>Silent/Verbose 参数  更多调试信息</li><li>自定义配置目录</li><li>超时设置</li><li>代理设置</li><li>自定义插件目录</li><li>强制插件</li></ul><h4 id="插件清单"><a href="#插件清单" class="headerlink" title="插件清单"></a>插件清单</h4><ul><li>API 插件</li><li>报警插件</li><li>分词插件</li><li>发现插件</li><li>管理和站点插件</li></ul><h2 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h2><blockquote><p>在Elasticsearch 的配置中，主要有两种配置方式，一种是静态配置，另一种是动态配置。静态配置的参数只能在配置文件中事先写好，动态配置的参数可以通过_cluster/settings进行设置。</p></blockquote><h3 id="网络相关配置"><a href="#网络相关配置" class="headerlink" title="网络相关配置"></a>网络相关配置</h3><ul><li>本地网关配置</li><li>HTTP 配置</li><li>网络配置  常用网络配置，高级网络配置，高级TCP配置，传输和HTTP协议</li><li>传输配置  TCP传输，本地传输，传输追踪<h3 id="脚本配置"><a href="#脚本配置" class="headerlink" title="脚本配置"></a>脚本配置</h3></li><li>脚本使用</li><li>脚本配置  索引脚本，启用动态脚本，脚本自动重载，本地java脚本，lucene表达式脚本，得分，文档字段，保存的字段，在脚本中访问文档的得分，源字段，Groovy内置方法<h3 id="快照和恢复配置"><a href="#快照和恢复配置" class="headerlink" title="快照和恢复配置"></a>快照和恢复配置</h3></li><li>只读仓库</li><li>快照</li><li>恢复</li><li>快照状态<h3 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h3><h4 id="线程池类型"><a href="#线程池类型" class="headerlink" title="线程池类型"></a>线程池类型</h4></li><li>cached 线程池是一个无限的线程池，如果存在挂起的请求时，就会产生一个线程。这个线程池用来防止提交的请求被阻塞或丢弃。</li><li>fixed 线程池拥有固定大小的线程来操作队列中的请求（任意界限）直到请求没有线程提供服务。size参数控制线程的数量，queue_size 参数可以控制没有线程执行的请求队列的大小。默认设置为-1，意味着无限大。当请求到达而且队列已经满了，请求会被终止。</li><li>scaling 线程池拥有动态数量的线程。线程的数量与工作量成正比，并且在1和size参数值之间变化。keep_alive参数决定一个线程的空闲时间。</li></ul><h4 id="处理器设置"><a href="#处理器设置" class="headerlink" title="处理器设置"></a>处理器设置</h4><p>处理器的数量是自动检测的，线程池的设置会基于结果自动设置。有时，处理器的数量会被错误检测，在这种情况下，处理器的数量可以使用 processes进行明确设置。</p><h3 id="索引配置"><a href="#索引配置" class="headerlink" title="索引配置"></a>索引配置</h3><blockquote><p>索引模块是控制每个索引指标的模块。索引模块包括分词、分片控制和分配、字段映射、索引相似性配置、慢查询记录、文件系统配置、控制事务和刷新模块。</p></blockquote><h4 id="缓存配置"><a href="#缓存配置" class="headerlink" title="缓存配置"></a>缓存配置</h4><ul><li>总内存控制</li><li>列数据内存控制</li><li>请求内存控制</li><li>数据缓存</li><li>节点查询缓存</li><li>索引缓冲区</li><li>分片请求缓存</li><li>索引恢复</li><li>TTL区间<h4 id="索引分片分配"><a href="#索引分片分配" class="headerlink" title="索引分片分配"></a>索引分片分配</h4></li><li>碎片分配过滤</li><li>延迟分配</li><li>每个节点的总碎片<h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><blockquote><p>一个 Elasticsearch 分片就是一个 Lucene 索引，Lucene索引被分解为分片。分片是索引的内部存储单元，存储索引数据并且是不变的。周期性合并(merge)小的分片为更大的分片来保持索引大小在范围内。</p></blockquote><h4 id="相似模块"><a href="#相似模块" class="headerlink" title="相似模块"></a>相似模块</h4></li><li>配置相似性</li><li>可用的相似性模块<h4 id="响应慢日志监控"><a href="#响应慢日志监控" class="headerlink" title="响应慢日志监控"></a>响应慢日志监控</h4></li><li>搜索慢日志</li><li>索引慢日志<h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4>支持存储类型</li><li>simplefs  简单文件系统类型</li><li>niofs  NIO 文件系统类型</li><li>mmapfs  MMap 文件系统类型在文件系统上通过映射文件到内存(mmap)存储分片索引</li><li>default_fs  默认类型是 NIO FS 和 MMapFS 的混合，对每个类型的文件选择最佳文件系统<h4 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h4></li><li>冲洗设置</li><li>事务日志设置</li></ul><h2 id="告警、监控和权限管理"><a href="#告警、监控和权限管理" class="headerlink" title="告警、监控和权限管理"></a>告警、监控和权限管理</h2><h3 id="告警"><a href="#告警" class="headerlink" title="告警"></a>告警</h3><p>Watcher 是进行警告和通知的插件，可以根据数据的变化采取行动。它的设计原理是在 Elasticsearch 中执行查询，满足条件的情况下，产生告警。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul><li>Trigger</li><li>Inputs</li><li>Condition</li><li>Transform</li><li>Action<h4 id="告警输出配置"><a href="#告警输出配置" class="headerlink" title="告警输出配置"></a>告警输出配置</h4>告警输出可以为邮件、Webhook、Logging、HipChat、Slack、PagerDuty<h4 id="告警管理"><a href="#告警管理" class="headerlink" title="告警管理"></a>告警管理</h4></li><li>列出警告</li><li>删除警告<h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><blockquote><p>Marvel 是商业监控方案，用来监控 Elasticsearch 集群历史状态的有力工具，便于性能优化以及故障诊断。监控主要分为六个层面，分别是集群层、节点层、索引层、分片层、事件层、Sense。</p></blockquote><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4></li><li>监控参数配置</li><li>监控索引配置</li><li>Kibana 配置相关</li><li>Tribe 部落节点监控配置<h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><blockquote><p>Shield 是商业权限管理插件，它可以保护 Elasticsearch 中的数据，采用加密的通信密码，基于角色的访问控制，IP过滤和审计等。</p></blockquote><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4>Shield 是 Elasticsearch 的一个插件，一旦安装完成，插件将会拦截所有 API 请求，然后对请求进行认证和授权的校验。该插件同时提供 SSL 安全协议来传输网络数据，该插件提供了审计日志记录的能力，用来进行验证和审计。</li><li>用户认证</li><li>授权</li><li>节点认证和信道加密</li><li>IP 过滤</li><li>审计<h4 id="用户认证"><a href="#用户认证" class="headerlink" title="用户认证"></a>用户认证</h4>用户认证方式</li><li>Native  一个内置的本地认证系统，默认可用</li><li>File  一种内置的基于文件的认证系统，默认可用</li><li>LDAP  通过外部轻量级目录协议进行身份验证</li><li>AD  通过外部活动目录服务的身份验证</li><li>PKI  通过使用可信的X.509证书的认证<br>匿名用户访问<h4 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a>角色管理</h4></li><li>增加角色</li><li>查看角色</li><li>删除角色</li></ul><h2 id="ELK-应用"><a href="#ELK-应用" class="headerlink" title="ELK 应用"></a>ELK 应用</h2><ul><li>Logstash  是一个灵活的开放源码的数据收集、处理、传输的工具。Logstash 可以处理日志、事件、非结构化的数据，并把它们输出出来，包括可以输出到 Elasticsearch 中。</li><li>Kibana  是一个开源的数据可视化平台，可以把数据以强大的图形化方式展示出来。从柱状图到地图等，它可以通过多个图表的组合来生成更为强大的仪表面板，帮助人们理解、分析和分享数据。</li></ul><h2 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h2><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><h4 id="配置文件的结构"><a href="#配置文件的结构" class="headerlink" title="配置文件的结构"></a>配置文件的结构</h4><p>配置文件由输入，过滤，输出三部分组成，每部分都是由插件构成的，这些插件负责处理日志的不同过程</p><h4 id="事件相关配置"><a href="#事件相关配置" class="headerlink" title="事件相关配置"></a>事件相关配置</h4><blockquote><p>每个事件都有不同的属性，比如 apache 的访问日志，可以包括状态码、协议、路径、客户端 IP等，在 Logstash 中这些属性叫做 fields。由于它们是事件属性，所以这些配置选项只会在过滤器和输出块中工作。</p></blockquote><h4 id="插件管理-1"><a href="#插件管理-1" class="headerlink" title="插件管理"></a>插件管理</h4><p>插件管理器通过 bin/logstash-plugin 的脚本来管理整个插件的生命周期，通过命令行接口(CLI)调用可以安装、卸载、升级插件。</p><ul><li>输入插件</li><li>过滤插件</li><li>输出插件</li><li>编解码插件<h3 id="Kibana-配置"><a href="#Kibana-配置" class="headerlink" title="Kibana 配置"></a>Kibana 配置</h3>安装比较简单，也是绿色的，解压后直接运行默认端口 5601。<h4 id="Discover"><a href="#Discover" class="headerlink" title="Discover"></a>Discover</h4></li><li>新的搜索</li><li>保存搜索加载保存的搜索</li><li>自动刷新</li><li>查看字段数据统计<h4 id="Visualize"><a href="#Visualize" class="headerlink" title="Visualize"></a>Visualize</h4>视图是定制可视化报表的地方</li></ul><ol><li>选择一个图标类型</li><li>选择一个数据源</li><li>可视化编辑器配置</li><li>保存编辑器<h4 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h4>仪表盘是用一组原始图标根据需要组合成一个丰富的图形报表</li></ol><ul><li>空仪表盘</li><li>创建仪表盘</li><li>保存仪表盘</li><li>加载仪表盘</li><li>共享仪表盘<h4 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h4></li><li>索引设置</li><li>管理字段</li><li>告警设置</li><li>Kibana 服务器配置</li><li>管理搜索，可视化仪表板<h2 id="Elasticsearch-5-0-的特性与改进"><a href="#Elasticsearch-5-0-的特性与改进" class="headerlink" title="Elasticsearch 5.0 的特性与改进"></a>Elasticsearch 5.0 的特性与改进</h2></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于分布式系统的稳定性</title>
    <link href="http://yeonsea.club/2019/08/25/%E5%85%B3%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    <id>http://yeonsea.club/2019/08/25/关于分布式系统的稳定性/</id>
    <published>2019-08-25T10:40:48.000Z</published>
    <updated>2019-09-10T08:05:36.131Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><h3 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h3><ul><li>堆栈信息</li><li>访问用户 IP、请求 URL、应用响应时间</li><li>内存回收信息</li><li>自定义信息</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>通过异常堆栈，可以定位到谁宕机了</li><li>产生问题的程序行，对异常进行修复</li><li>访问 IP 和请求参数，排查是否遭到攻击，以及攻击的形式</li><li>应用的响应时间、垃圾回收以及系统 load 来判断系统负载，是否要增加机器</li><li>线程 dump，判断是否死锁及线程阻塞的原因</li><li>应用的 GC 日志，对系统代码和 JVM 内存参数进行优化，减少 GC 次数与 stop the world 时间，优化应用响应时间</li></ul><h2 id="集群监控"><a href="#集群监控" class="headerlink" title="集群监控"></a>集群监控</h2><p>木桶原理</p><h3 id="监控指标"><a href="#监控指标" class="headerlink" title="监控指标"></a>监控指标</h3><ul><li>load：linux 中，可以通过 top,uptime来查看系统load值，系统load定义为特定时间间隔内运行队列中的平均线程数。</li><li>cpu 利用率</li><li>磁盘剩余空间</li><li>网络 traffic</li><li>磁盘 IO</li><li>内存使用</li><li>qps    query per second</li><li>rt    response time</li><li>select/ps</li><li>update/ps、delete/ps</li><li>GC    JVM 虚拟机开发团队一直致力于消除或者减少工作线程因内存回收而导致的停顿，用户线程的停顿时间在不断地缩短，但是仍然没办法完全消除</li></ul><h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><blockquote><p>对于自治的分布式系统而言，一般都有一整套的集群心跳检测机制，能够实时地移除掉宕机的 Slave，避免路由规则将任务分配给已宕机的机器来处理。<br>而如果是 Master 宕机，集群能够自动地进行 Master 的选举，从而避免由 Master 宕机而导致整个集群不能提供服务的情况发生，这一类系统，如 ZooKeeper，便是一个很好的典范。也有一部分系统可以通过外部干预，使备份机器 stand by，或者是双机互为备份，以实现故障切换，如 MySQL、Nginx等，以避免单点故障的发生。</p></blockquote><p>具体操作：</p><ul><li>ping</li><li>应用层检测    curl 定时访问应用中预留的自检 url</li><li>业务检测    可在 response 的 header 中约定一个值，来标识返回的结果是否正常</li></ul><h3 id="容量评估及应用水位"><a href="#容量评估及应用水位" class="headerlink" title="容量评估及应用水位"></a>容量评估及应用水位</h3><p>当前水位 = 当前总 qps / （单台机器极限 x 机器数）x 100%</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><h3 id="流量控制实施"><a href="#流量控制实施" class="headerlink" title="流量控制实施"></a>流量控制实施</h3><p>多个维度</p><ul><li>对系统的总并发请求数进行限制 - 可以很好地控制系统的负载，避免出现流量突增将系统压垮的情况</li><li>限制单位时间内的请求次数（如限制qps） - 限制调用频次，防止某个外部调用的流量突增影响到服务本身的稳定性</li><li>通过白名单机制来限制每一个接入系统调用的频率等</li></ul><p>超载的部分流量</p><ul><li>直接返回，显示系统繁忙</li><li>通过单机内存队列来进行有限的等待</li><li>通过分布式消息队列来将用户的请求异步化</li></ul><h3 id="服务稳定性"><a href="#服务稳定性" class="headerlink" title="服务稳定性"></a>服务稳定性</h3><h4 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h4><p>服务消费日志</p><h4 id="优雅降级"><a href="#优雅降级" class="headerlink" title="优雅降级"></a>优雅降级</h4><blockquote><p>对于调用超时的非核心服务，可以设定一个阈值，如果调用超时的次数超过这个阈值，便自动将该服务降级。此时服务调用者跳过对该服务的调用，并指定一个休眠的时间点，当时间点过了以后，再次对该服务进行重试，如果服务恢复，则取消降级，否则继续保持该服务的降级状态，直到所依赖的服务故障恢复。</p></blockquote><h4 id="服务分级"><a href="#服务分级" class="headerlink" title="服务分级"></a>服务分级</h4><h4 id="开关"><a href="#开关" class="headerlink" title="开关"></a>开关</h4><blockquote><p>当系统负载较高，即将突破警戒水位时，如何通过实时地屏蔽一些非核心链路的调用来降低系统的负载呢？这时需要系统预先定义一些开关控制程序的服务提供策略。开关通过修改一些预先定义好的全局变量，来控制系统的关键路径和逻辑。</p></blockquote><h4 id="应急预案"><a href="#应急预案" class="headerlink" title="应急预案"></a>应急预案</h4><h3 id="高并发系统设计"><a href="#高并发系统设计" class="headerlink" title="高并发系统设计"></a>高并发系统设计</h3><blockquote><p>高并发系统与普通系统设计的区别在于，既要保障系统的可用性和可扩展性，又要兼顾数据的一致性，还要处理多线程同步的问题。<br><em>任何细微问题，都有可能在高并发环境下被无限地放大，直至系统宕机</em></p></blockquote><h4 id="操作原子性"><a href="#操作原子性" class="headerlink" title="操作原子性"></a>操作原子性</h4><blockquote><p>原子操作指的是不可分割的操作，它要么执行成功，要么执行失败，不会产生中间状态。<br>原子操作也是一些常见的多线程程序bug的源头。<br>并发相关的问题对于测试来说，并不是每次都能重现，因此处理起来十分棘手。<br>JDK5.0 以后开始提供 Atomic Class，支持 CAS compare and set 等一系列原子操作，来帮助我们简化多线程程序设计。<br>数据count统计</p><ul><li>CountDownLatch是做减法，CyclicBarrier是做加法,Semaphor的临界资源可以反复使用</li><li>CountDownLatch不能重置计数，CycliBarrier提供的reset()方法可以重置计数，不过只能等到第一个计数结束。Semaphor可以重复使用。</li><li>CountDownLatch和CycliBarrier不能控制并发线程的数量，Semaphor可以实现控制并发线程的数量。<br>AtomicInteger compareAndSet 方法 调用 Unsafe 对象的 native 方法 compareAndSwapInt 方法，最终通过 Atomic::com::(x, addr, e)来实现原子操作</li></ul></blockquote><p>数据库的事务操作<br>数据库事务具有 ACID 属性<br>导致事务失败的原因有很多：</p><ul><li>修改不符合表的约束规则</li><li>网络异常</li><li>存储介质故障</li></ul><blockquote><p>为了实现数据库状态的恢复，DBMS 系统通常需要维护事务日志以追踪事务中所有影响数据库数据的操作，以便执行失败时进行事务的回滚。<br>事务日志可以提高事务执行的效率，存储引擎只需要将修改行为持久到事务日志当中，便可以只对该数据在内存中的拷贝进行修改，而不需要每次修改都将数据回写到磁盘。<br>日志写入是一小块区域的顺序IO，而数据库数据的磁盘回写则是随机IO，磁头需要不停地移动来寻找需要更新数据的位置。</p></blockquote><h4 id="多线程同步"><a href="#多线程同步" class="headerlink" title="多线程同步"></a>多线程同步</h4><p>多线程同步指的是线程之间执行的顺序，多个线程并发地访问和操作同一数据，并且执行的结果与访问或者操作的次序有关。</p><ul><li>synchronized</li><li>ReentrantLock<blockquote><p>ReentrantLock 的好处是，等待是可以中断的。通过 tryLock(timeout, unit)，可以尝试获得锁，并且指定等待时间。另一个特性是可以在构造 ReentrantLock 时使用公平锁，公平锁指的是多个线程在等待同一个锁时，必须按照申请锁的先后顺序依次获得锁。synchronized 中的锁是非公平的，默认情况下 ReentrantLock 也是非公平的，但是可以在构造函数中指定使用公平锁。<br>对于 ReentrantLock 来说，还有一个十分实用的特性，它可以同时绑定多个 condition 条件，以实现更精细化的同步控制。</p></blockquote></li></ul><h4 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h4><p>分布式系统常常通过复制数据来提高系统的可靠性和容错性，并且将数据的副本存放到不同的机器上。由于多个副本的存在，使得维护副本一致性的代价很高。因此，许多分布式系统都采用弱一致性或者最终一致性，来提高系统的性能和吞吐能力。</p><blockquote><p>最终一致性是弱一致性的一种特殊形式，这种情况下系统保证用户最终能够读取到某个操作对系统的更新，“不一致性窗口”的时间依赖于网络的延迟、系统的负载和副本的个数。<br>最终一致性举例：</p><ul><li>mysql 主从数据同步</li><li>zookeeper 的 leader election 和 atomic broadcas</li></ul></blockquote><h4 id="系统可扩展性"><a href="#系统可扩展性" class="headerlink" title="系统可扩展性"></a>系统可扩展性</h4><p>系统的可扩展性也成为可伸缩性，是一种对软件系统计算处理能力的评价指标。<br>只需要增加相应的机器，便能够使性能平滑地提升。<br><em>水平扩展相对于硬件的垂直扩展来说，对于软件设计的能力要求更高，系统设计更复杂，但却能够使系统处理能力几乎可以无限制扩展</em><br><em>系统的可扩展性也会受到一些因素的制约，CAP理论指出，系统的一致性、可用性和可扩展性三个要素对于分布式系统来说，很难同时满足。因此，在系统设计时，往往得做一些取舍。</em></p><h4 id="并发减库存"><a href="#并发减库存" class="headerlink" title="并发减库存"></a>并发减库存</h4><p>秒杀活动杜绝网络投机者使用工具导致不公平竞争：加速验证码，复杂验证码。</p><p>数据一致性问题：</p><blockquote><p>对于高并发访问的浏览型系统来说，单机数据库如不进行扩展，往往很难支撑。因此常常会采用分库技术来提高数据库的并发能力，并且通过使用分布式缓存技术，将磁盘磁头的机械运动化为内存的高低电平，以降低数据库的压力，加快后端的响应速度。响应的越快，线程释放的也越快，能够支持的单位时间内的查询数qps也越高，并发处理能力就越强。<br><em>带来的问题是跨数据库或者是分布式缓存与数据库之间难以进行事务操作。</em><br>为了避免数据不一致的情况发生，并且保证前端页面能够在高并发情况下正常浏览，可以采用实际库存和浏览库存分离的方式。<br>mysql 中 myisam 是表锁策略，innodb 是行锁策略，innodb 更适合高并发写入的场景</p></blockquote><p>一个线程获得行锁以后，其他并发线程就需要等待它处理完成，这样系统将无法利用多线程并发执行的优势，并且随着并发数的增加，等待的线程会越来越多，rt 急剧飙升，最终导致可用连接数被占满，数据库拒绝服务。</p><p>可以通过将一行库存拆分成多行，便可以解除行锁导致的并发资源利用的问题。<br>路由策略：id取模，随机。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="如何寻找性能的瓶颈"><a href="#如何寻找性能的瓶颈" class="headerlink" title="如何寻找性能的瓶颈"></a>如何寻找性能的瓶颈</h3><blockquote><p>Web 性能优化涉及前端优化、服务端优化、操作系统优化、数据库查询优化、JVM调优等众多领域的知识<br><em>寻找可优化的点是第一步也是最重要的一步，也就是所谓的性能瓶颈，性能瓶颈实际上就是木桶原理中最短的那一块木板</em></p></blockquote><h4 id="前端优化工具-YSlow"><a href="#前端优化工具-YSlow" class="headerlink" title="前端优化工具 YSlow"></a>前端优化工具 YSlow</h4><h4 id="页面响应时间"><a href="#页面响应时间" class="headerlink" title="页面响应时间"></a>页面响应时间</h4><h4 id="方法响应时间"><a href="#方法响应时间" class="headerlink" title="方法响应时间"></a>方法响应时间</h4><p><strong>Java 环境下有一个十分有效的动态跟踪工具，btrace</strong></p><h4 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h4><blockquote><p>GC 日志能够反应出 Java 应用执行内存回收详细情况，如 Minor GC 的频繁程度、Full GC 的频繁程度、GC 所导致应用停止响应的时间、引起 GC 的原因等。<br>在 JVM 启动时加上几个参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-verbose:gc -Xloggc:/gc.log -XX:+PrintGCDetails -XX:+PrintGCDataStamps</span><br></pre></td></tr></table></figure></p></blockquote><p>分别表示日志存放位置，输出 GC 详情，输出 GC 时间戳</p><blockquote><p>CMS 收集器是一款以获取最短回收停顿时间为目的的收集器，它是基于标记清除算法实现的，整个过程大致分为四个步骤： CMS initial mark, CMS concurrent mark, CMS remark, CMS concurrent sweep</p></blockquote><h4 id="数据库查询"><a href="#数据库查询" class="headerlink" title="数据库查询"></a>数据库查询</h4><p>low_slow_query<br>low_query_time<br>通过 MySQL 的配置文件 my.cnf ，可以修改慢查询日志的相关配置</p><h4 id="系统资源使用"><a href="#系统资源使用" class="headerlink" title="系统资源使用"></a>系统资源使用</h4><h3 id="性能测试工具"><a href="#性能测试工具" class="headerlink" title="性能测试工具"></a>性能测试工具</h3><p>性能测试指的是通过一些自动化的测试工具模拟多种正常、峰值，以及异常负载对系统的各项性能指标进行测试。</p><h4 id="ab"><a href="#ab" class="headerlink" title="ab"></a>ab</h4><p>全称为 ApacheBench，专门针对 HTTP 服务器进行性能测试的小工具，可以模拟多个并发请求来对服务器进行压力测试，得出服务器在高负载下能够支持的qps及应用的响应时间，为系统设计者提供参考依据。</p><h4 id="Apache-JMeter"><a href="#Apache-JMeter" class="headerlink" title="Apache JMeter"></a>Apache JMeter</h4><p>开源性能测试工具，比 ab 更为强大，采用纯 Java 实现，支持多种协议的性能基准测试，如HTTP,SOAP,FTP,TCP,SMTP,POP3等。<br>提供了图形化界面</p><p>Tomcat 在启动脚本中加入如下配置，便能通过jconsole,VisualVM等工具查看系统相关信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CATALINA\_OPTS=&quot;$CATALINA_OPTS -Djava.rmi.server.hostname=***.***.***.*** -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=**** -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false&quot;</span><br></pre></td></tr></table></figure></p><h4 id="HP-LoadRunner"><a href="#HP-LoadRunner" class="headerlink" title="HP LoadRunner"></a>HP LoadRunner</h4><p>商业付费，更成熟，更强大，支持的协议更为广泛，用户体验更高。</p><h4 id="反向代理引流"><a href="#反向代理引流" class="headerlink" title="反向代理引流"></a>反向代理引流</h4><blockquote><p>在分布式环境下，流量真正到达服务器之前，一般会经过负载均衡设备进行转发，通过修改负载均衡的策略，可以改变后端服务器所承受的压力。</p></blockquote><p>Nginx 配置权重，新版本灰度发布。</p><h4 id="TCPCopy"><a href="#TCPCopy" class="headerlink" title="TCPCopy"></a>TCPCopy</h4><p>网易技术部2011年9月开源的一个项目，请求复制工具，能够将在线请求复制到测试机器，模拟真实环境，达到程序在不上线的情况下承担线上真实流量的效果。</p><h3 id="性能优化措施"><a href="#性能优化措施" class="headerlink" title="性能优化措施"></a>性能优化措施</h3><h4 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h4><ol><li>页面的 HTTP 请求数量<blockquote><p>新建一个到服务器的HTTP连接需要重新经历TCP协议握手建立连接状态等过程，并且大部分请求和响应都包含了很多相同 header 与 cookie 内容，增加了网络带宽消耗。因此，减少 HTTP 请求的数量能够加速页面的加载，在不改变页面外观的情况下，可以通过采取合并样式和脚本文件等措施，来减少页面加载所需要请求数。</p></blockquote></li><li>是否使用 CDN 网络<blockquote><p>CDN 网络使得用户能够就近取得所需要的资源，降低静态资源传输的网络延迟。可以将图片、样式文件、脚本文件、页面框架等不需要频繁变动的内容推送到 CDN网络，可以提高页面加载的速度。</p></blockquote></li><li>是否使用压缩<blockquote><p>对于前端样式文件与脚本文件，可以将其中空格、注释等不必要的字符去掉，并且通过使用 gzip 压缩来减少网络上传输的字节数。当然，压缩也是有成本的，它会消耗一定的 CPU 资源，但通常情况下来说这种开销都是值得的。</p></blockquote></li></ol><h4 id="Java-程序优化"><a href="#Java-程序优化" class="headerlink" title="Java 程序优化"></a>Java 程序优化</h4><h5 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h5><p>对于 IO 处理、数据库连接、配置文件解析加载等一些非常耗费系统资源的操作，我们必须对这些实例的创建进行限制，或者始终使用一个公用的实例，以节约系统开销，这种情况下就需要用到单例模式。</p><h5 id="Future-模式"><a href="#Future-模式" class="headerlink" title="Future 模式"></a>Future 模式</h5><p>假设一个任务执行起来需要花费一些时间，为了省去不必要的等待时间，可以先获取一个提货单，即 Future ，然后继续处理别的任务，直到货物到达，即任务执行完得到结果，此时便可以用提货单进行提货，即通过 Future 对象得到返回值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class TestFuture &#123;</span><br><span class="line">static class Job&lt;Object&gt; implements Callable&lt;Object&gt; &#123;</span><br><span class="line">@Override</span><br><span class="line">public Object call() throws Exception &#123;</span><br><span class="line">return loadData();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">FutureTask future = new FutureTask(new Job&lt;Object&gt;());</span><br><span class="line">new Thread(future).start();</span><br><span class="line"></span><br><span class="line">// do something else</span><br><span class="line"></span><br><span class="line">Object result = (Object) future.get();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>FutureTask 类实现了 Future 和 Runnable 接口，FutureTask 开始后，loadData()执行时间可能较长，因此可以先处理其他事情，等其他事情处理好以后，再通过 future.get() 来获取结果，如果 loadData() 还未执行完毕，则此线程会阻塞等待。</p></blockquote><h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5><p>使用线程池将互不依赖的几个动作切分，通过多线程对串行工作进行改进，将成倍地提高工作效率。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class TestExecutorService &#123;</span><br><span class="line">static class Job implements Runnable &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">doWork();// 具体工作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void doWork() &#123;</span><br><span class="line">System.out.println(&quot;doing...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ExecutorService exec = Executors.newFixedThreadPool(5);</span><br><span class="line">for (int i = 0; i &lt; 10; i ++) &#123;</span><br><span class="line">exec.execute(new Job());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="选择就绪"><a href="#选择就绪" class="headerlink" title="选择就绪"></a>选择就绪</h5><blockquote><p>JDK自1.4起开始提供全新的 IO 编程类库，简称 NIO，其不但引入了全新高效的 Buffer 和 Channel ，同时还引入了基于 Selector 的非阻塞 IO 机制，将多个异步的 IO 操作集中到一个或几个线程当中进行处理。使用 NIO 代替阻塞 IO 能提高程序的并发吞吐能力，降低系统的开销。</p></blockquote><p><em>对于每一个请求，单独开一个线程进行响应的逻辑处理，如果客户端的数据传递并不是一直进行，而是断断续续的，则相应线程需要 IO 等待，并进行上下文切换。</em></p><p>Selector 机制使得线程不必等待客户端的 IO 就绪，当客户端还没就绪时，可以处理其他请求，提高了服务器的并发吞吐能力，降低了资源消耗。</p><h5 id="减少上下文切换"><a href="#减少上下文切换" class="headerlink" title="减少上下文切换"></a>减少上下文切换</h5><p>进程上下文切换会有一定的调度开销，这个过程中操作系统和JVM会消耗一定的CPU周期，并且由于CPU处理器会缓存一部分数据，当新线程被切换进来时，它所需要的数据可能不在CPU缓存中，因此还会导致CPU缓存的命中率下降。</p><h5 id="降低锁竞争"><a href="#降低锁竞争" class="headerlink" title="降低锁竞争"></a>降低锁竞争</h5><p>降低锁竞争的一种有效的方式是尽可能地缩短锁持有的时间，比如可以将一部分与锁无关的代码移出同步代码块，特别是执行起来开销较大的操作，以及可能使当前线程被阻塞的操作。<br>另一种减小锁持有时间的方式是减小锁的粒度，将原先使用单独锁来保护的多个变量变为采用多个相互独立的锁分别进行保护，这样就能够降低线程请求锁的几率，从而减少竞争发生的可能性。<strong>当然，使用的锁越多，发生死锁的风险也就越高。</strong><br>第三种降低锁竞争的方式就是放弃使用独占锁，而使用其他更友好的并发方式来保障数据的同步，原子变量就是使用读写锁。<br><em>对于多读少写的情况，使用读写锁能够比使用独占锁提供更高的并发数量。</em></p><h4 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h4><p>在进行数据传输之前，可以先将数据进行压缩，以减少网络传输的字节数，提升数据传输的速度。接收端可以将数据进行解压，以还原出传递的数据，并且经过压缩的数据还可以节约所耗费的存储介质(磁盘或内存)的空间与网络带宽，降低成本。<br>当然，压缩需要大量的CPU计算，并且根据压缩算法的不同，计算的复杂度和数据的压缩比也存在较大差异。</p><h4 id="结果缓存"><a href="#结果缓存" class="headerlink" title="结果缓存"></a>结果缓存</h4><p>本地缓存，分布式缓存</p><h4 id="数据库查询性能优化"><a href="#数据库查询性能优化" class="headerlink" title="数据库查询性能优化"></a>数据库查询性能优化</h4><p>以mysql为例</p><h5 id="合理使用索引"><a href="#合理使用索引" class="headerlink" title="合理使用索引"></a>合理使用索引</h5><blockquote><p>对于使用B树或B+树存储的组合索引来说，有一个最基本的原则，即“最左前缀”的原则，如果查询不是按照索引的最左列来开始查询，则无法使用到组合索引。</p></blockquote><h5 id="反范式设计"><a href="#反范式设计" class="headerlink" title="反范式设计"></a>反范式设计</h5><p>范式设计好处:</p><ul><li>冗余数据的减少，无疑节约了存储空间，而且保证了关系的一致性;</li><li>由于冗余数据的减少，当数据需要进行更新时，要修改的数据则变少了，这样会提升更新操作的速度;</li><li>范式化的表通常更小，可以更好地利用表的查询缓存来提高查询速度。<br><em>但是，对于大多数复杂的业务场景来说，数据表现的纬度不可能是单表的。因此在进行查询操作时，需要进行表的关联。这不仅代价高昂，由于查询条件指定的列可能并不在同一个表中，因此也无法使用到索引，这将导致数据库的性能严重下降。</em><blockquote><p>为了尽可能地避免关联查询带来的性能损耗，有人提出了反范式设计，即将一些常用的需要关联查询的列进行冗余存储，以便减少表关联带来的随机IO和全盘扫描。</p></blockquote></li></ul><h5 id="使用查询缓存"><a href="#使用查询缓存" class="headerlink" title="使用查询缓存"></a>使用查询缓存</h5><ul><li>query_cache_type</li><li>query_cache_size</li><li>query_cache_limit</li></ul><h5 id="使用搜索引擎"><a href="#使用搜索引擎" class="headerlink" title="使用搜索引擎"></a>使用搜索引擎</h5><blockquote><p>在分布式环境下，为了便于数据库扩展，提高并发处理能力，相关联的表可能并不在同一个数据库当中，而是分布在多个库当中，并且表也可能已经进行了切分，无法进行复杂的条件查询。这时候就需要搭建搜索引擎，将需要进行查询和展现的列通过一定的规则都建到索引当中，以提供复杂的垮表查询与分组操作。</p></blockquote><h5 id="使用-key-value-数据库"><a href="#使用-key-value-数据库" class="headerlink" title="使用 key-value 数据库"></a>使用 key-value 数据库</h5><blockquote><p>对于保有海量数据的互联网企业来说，多表的关联查询是非常忌讳的。出于性能的考虑，更多时候往往根据表的主键来进行查询，或者进行简单的条件查询。因此，SQL的功能被很大程度地弱化了。</p></blockquote><h5 id="GC-优化"><a href="#GC-优化" class="headerlink" title="GC 优化"></a>GC 优化</h5><p>Parallel Scavenge 垃圾收集器是悲观策略，每次晋升到 OldGen 的平均大小如果大于当前OldGen的剩余空间，则触发一次FullGC。如果频繁发生，可以通过-Xmx与-Xms参数来调整整个堆的大小，以增加OldGen的大小，YoungGen对应的-Xmn保持不变。<br>默认情况下，CMS收集器的垃圾回收会在OldGen使用了68%空间时被激活，可以调大。但如果预留的内存无法满足程序需要，则会出现 concurrent mode failure。</p><p><em>堆设置：</em></p><ul><li>Xms 是指程序启动时初始内存大小（此值可以设置成与-Xmx相同，以避免每次GC完成后 JVM 内存重新分配）。</li><li>Xmx 指程序运行时最大可用内存大小，程序运行中内存大于这个值会 OutOfMemory。</li><li>Xmn 年轻代大小（整个JVM内存大小 = 年轻代 + 年老代 + 永久代）。</li><li>XX:NewRatio 年轻代与年老代的大小比例，-XX:NewRatio=4 设置为4，则年轻代与年老代所占比值为1：4。</li><li>XX:SurvivorRatio 年轻代中Eden区与Survivor区的大小比值，-XX:SurvivorRatio=4，设置为4，则两个Survivor区与一个Eden区的比值为 2:4</li><li>XX:MaxPermSize 设置永久代大小。</li><li>XX:MaxTenuringThreshold 设置垃圾最大年龄。<br>如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</li><li>Xss 设置每个线程的堆栈大小。</li></ul><h5 id="硬件提升性能"><a href="#硬件提升性能" class="headerlink" title="硬件提升性能"></a>硬件提升性能</h5><p>内存越大越好，硬盘读写，避免网卡成为系统吞吐的瓶颈，CPU核数。</p><h2 id="Java-应用故障排查"><a href="#Java-应用故障排查" class="headerlink" title="Java 应用故障排查"></a>Java 应用故障排查</h2><h4 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h4><ul><li>jps  类似 linux 的 ps</li><li>jstat  对虚拟机各种运营状态进行监控的工具，通过它可以查看虚拟机的类加载与卸载情况，管理内存使用和垃圾收集等信息，监视JIT即时编译器的运行情况等。</li><li>jinfo  用于查看应用程序的配置参数，以及打印运行JVM时所指定的JVM参数。</li><li>jstack  用来生成虚拟机当前的线程快照信息，线程快照就是当前虚拟机每一个线程正在执行的方法堆栈的集合。</li><li>jmap  查看等待回收对象的队列，查看堆的概要信息，包括采用的是哪种GC收集器，堆空间的使用情况，以及通过JVM参数指定的各个内存空间的大小。</li><li>BTrace  是一个开源的 Java 程序动态跟踪工具。基本原理是通过Hotspot虚拟机的HotSwap技术将跟踪的代码动态替换到被跟踪的Java程序内，以观察程序运行的细节。通过BTrace脚本，可以在方法执行时，输出传递给方法的参数与方法的返回值。</li><li>JConsole  是一款JDK内置的图形化性能分析工具，它可以用来连接本地或者远程正在运行的JVM，对运行的Java应用程序的性能及资源消耗情况进行分析和监控，并提供可视化的图表对相关数据进行展现。</li><li>Memory Analyzer      Eclipse 插件</li><li>VisualVM  功能强大的 all-in-one 工具</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="调优" scheme="http://yeonsea.club/tags/%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>Writing &amp; Publishing your First NPM Package</title>
    <link href="http://yeonsea.club/2019/08/23/Writing&amp;Publishing_your_First_NPM_Package/"/>
    <id>http://yeonsea.club/2019/08/23/Writing&amp;Publishing_your_First_NPM_Package/</id>
    <published>2019-08-23T05:54:11.000Z</published>
    <updated>2019-08-24T12:16:00.779Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Just-do-it"><a href="#Just-do-it" class="headerlink" title="Just do it"></a>Just do it</h1><h2 id="NPM-account"><a href="#NPM-account" class="headerlink" title="NPM account"></a>NPM account</h2><ol><li><p>Create an NPM account if you don’t yet have one<br><a href="https://www.npmjs.com/" title="npm js" target="_blank" rel="noopener">npm js</a>. </p></li><li><p>Open terminal and …</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm adduser</span><br></pre></td></tr></table></figure></li></ol><p>** If you use taobao mirror, it will show 403 Forbidden. Then …<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry # show the current login source</span><br><span class="line">npm config set registry=http://registry.npmjs.org # change to the npmjs</span><br><span class="line">npm login # relogin</span><br></pre></td></tr></table></figure></p><h2 id="Create-a-component"><a href="#Create-a-component" class="headerlink" title="Create a component"></a>Create a component</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.exports.*** = ***</span><br></pre></td></tr></table></figure><h2 id="Create-a-new-repository-on-GitHub"><a href="#Create-a-new-repository-on-GitHub" class="headerlink" title="Create a new repository on GitHub"></a>Create a new repository on GitHub</h2><h2 id="Init-and-publish"><a href="#Init-and-publish" class="headerlink" title="Init and publish"></a>Init and publish</h2><p>Under the component, open the terminal</p><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">code .</span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin https://github.com/***/***.git</span><br><span class="line">git push -u origin master</span><br><span class="line">sudo git push -u origin master</span><br></pre></td></tr></table></figure><h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure><h2 id="Use-it"><a href="#Use-it" class="headerlink" title="Use it!"></a>Use it!</h2><p>create a new project<br>import<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i ** --save</span><br><span class="line">parser index.html</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Front-end" scheme="http://yeonsea.club/tags/Front-end/"/>
    
  </entry>
  
  <entry>
    <title>西尔维斯特-矩阵</title>
    <link href="http://yeonsea.club/2019/08/19/%E8%A5%BF%E5%B0%94%E7%BB%B4%E6%96%AF%E7%89%B9-%E7%9F%A9%E9%98%B5/"/>
    <id>http://yeonsea.club/2019/08/19/西尔维斯特-矩阵/</id>
    <published>2019-08-19T09:56:10.000Z</published>
    <updated>2019-08-20T09:38:57.123Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>西尔维斯特（James Joseph Sylvester, 1814~1897）</p><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>数量可以用二维数据表格来展示  </p><p>打猎得到的各种猎物和税金之间的关系可以用两个二维数据表格来表示  </p><table><thead><tr><th>00</th><th>兔子</th><th>鹿</th><th>野猪</th></tr></thead><tbody><tr><td>西尔维斯特</td><td>5只</td><td>1只</td><td>0只</td></tr><tr><td>东健</td><td>2只</td><td>0只</td><td>1只</td></tr><tr><td>小彬</td><td>0只</td><td>0只</td><td>2只</td></tr></tbody></table><table><thead><tr><th>猎物</th><th>税金</th></tr></thead><tbody><tr><td>兔子</td><td>20韩元</td></tr><tr><td>鹿</td><td>50韩元</td></tr><tr><td>野猪</td><td>100韩元</td></tr></tbody></table><p>运动器械和自行车的价格与需要购买的数量之间的关系可以用两个二维数据表格来表示  </p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>把数字或字母在括号内排列成二维数据表格就叫作矩阵。矩阵的各个数字或字母叫作元素。横向叫作行，纵向叫作列。  </p><p>矩阵的行数为m，列数为n时，矩阵的大小为m*n，行数和列数数目相等的矩阵叫作方块矩阵。  </p><p>元素都为0的矩阵叫作零矩阵；主对角线元素都为1，其余元素都是0的矩阵叫作单位矩阵。  </p><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>把方程组变成矩阵来解，可以进行一下运算：  </p><ol><li>某一行可以乘以一个常数：相当于一个方程的两边同时乘以一个常数。</li><li>某一行乘以一个常数后可以与另一行相加：相当于一个方程的两边同时乘以一个常数后再与另一个方程相加。</li><li>行与行可以对调：方程的顺序对调后，解不变。</li></ol><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>方程组<br>$$<br>\begin{cases}<br>   ax+by=p \\<br>   cx+dy=q<br>\end{cases}<br>$$<br>用矩阵表达式如下<br>$$<br>\begin{pmatrix}<br>   a &amp; b \\<br>   c &amp; d<br>\end{pmatrix}<br>\begin{pmatrix}<br>   x \\<br>   y<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>   p \\<br>   q<br>\end{pmatrix}<br>$$<br>可以简单表示为<br>$$<br>\begin{pmatrix}<br>   a &amp; b &amp;: &amp;p  \\<br>   c &amp; d &amp;: &amp;q<br>\end{pmatrix}<br>$$</p><hr><p>矩阵的某一行乘以一个常数后形成的新矩阵，求出的解是同一个方程组的解。  </p><p>矩阵的某一行乘以一个常数后与另一行相加形成的新矩阵，求出的解是同一个方程组的解。  </p><p>方程组构成的矩阵，行与行可以对调，对调后方程组的解不变。  </p><h1 id="5"><a href="#5" class="headerlink" title="5"></a>5</h1><p>可以将下面的三元一次方程组变成矩阵来解<br>$$<br>\begin{cases}<br>   a_{11}x+a_{12}y+a_{13}z=p \\<br>   a_{21}x+a_{22}y+a_{23}z=q \\<br>   a_{31}x+a_{32}y+a_{33}z=r<br>\end{cases}<br>$$</p><p>$$<br>\begin{pmatrix}<br>   a_{11} &amp; a_{12} &amp; a_{13} &amp;: &amp;p  \\<br>   a_{21} &amp; a_{22} &amp; a_{23} &amp;: &amp;q  \\<br>   a_{31} &amp; a_{32} &amp; a_{33} &amp;: &amp;r<br>\end{pmatrix}<br>$$</p><h1 id="6"><a href="#6" class="headerlink" title="6"></a>6</h1><p>两个矩阵相等是指两个矩阵中所有的元素对应相等。  </p><p>两个矩阵之间对应的元素相加，可以实现两个矩阵之间的加法运算。</p><p>一个矩阵的各元素可以乘以某个常数。  </p><p>两个矩阵之间对应的元素相减，可以实现两个矩阵之间的减法运算。</p><h1 id="7"><a href="#7" class="headerlink" title="7"></a>7</h1><p>两个矩阵相乘，前面矩阵的列数要与后面矩阵的行数相等。这时乘积的大小由前面矩阵的行数和后面矩阵的列数决定。即<br>$$<br>A_{m×n}B_{n×t}=C_{m×t}<br>$$</p><hr><p>前面矩阵的第i行和后面矩阵的第j列的各对应元素的乘积之和，构成乘积矩阵中的(i, j)元素。  </p><p>寻找日常生活中可以用矩阵乘积表示的问题。</p><h1 id="8"><a href="#8" class="headerlink" title="8"></a>8</h1><p>可求出方块矩阵<br>$$<br>\begin{pmatrix}<br>   a &amp; b \\<br>   c &amp; d<br>\end{pmatrix}<br>$$<br>的逆矩阵  </p><p>$$<br>{\begin{pmatrix}<br>   a &amp; b \\<br>   c &amp; d<br>\end{pmatrix}}^{-1}<br>= {1 \over ad - bc}<br>\begin{pmatrix}<br>   d &amp; -b \\<br>   -c &amp; a<br>\end{pmatrix}<br>(ad-bc \ne 0)<br>$$</p><hr><p>利用逆矩阵求二元一次方程组<br>$$<br>\begin{cases}<br>   ax+by=p \\<br>   cx+dy=q<br>\end{cases}<br>$$<br>的解。首先像下面这样用矩阵表示方程：<br>$$<br>\begin{pmatrix}<br>   a &amp; b \\<br>   c &amp; d<br>\end{pmatrix}<br>\begin{pmatrix}<br>   x \\<br>   y<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>   p \\<br>   q<br>\end{pmatrix}<br>$$<br>然后式子两边靠左的位置写上<br>$$<br>\begin{pmatrix}<br>   a &amp; b \\<br>   c &amp; d<br>\end{pmatrix}<br>$$<br>的逆矩阵，再做乘法运算。<br>$$<br>\begin{pmatrix}<br>   x \\<br>   y<br>\end{pmatrix}<br>=<br>{\begin{pmatrix}<br>   a &amp; b \\<br>   c &amp; d<br>\end{pmatrix}}^{-1}<br>\begin{pmatrix}<br>   p \\<br>   q<br>\end{pmatrix}<br>$$<br>--</p><p>$$<br>\begin{pmatrix}<br>   x \\<br>   y<br>\end{pmatrix}<br>=<br>{1 \over ad - bc}<br>\begin{pmatrix}<br>   d &amp; -b \\<br>   -c &amp; a<br>\end{pmatrix}<br>\begin{pmatrix}<br>   p \\<br>   q<br>\end{pmatrix}<br>=<br>{1 \over ad - bc}<br>\begin{pmatrix}<br>   dp-bq \\<br>   -cp+aq<br>\end{pmatrix}<br>(ad-bc \ne 0)<br>$$<br>--</p><p>$$<br>x={dp-bq \over ad-bc}, y={-cp+aq \over ad-bc}<br>$$</p><h1 id="9"><a href="#9" class="headerlink" title="9"></a>9</h1><p>研究是否可以用矩阵表示身边的实际问题。思考如何确定一个矩阵的各个元素。  </p><p>利用矩阵解决问题，预测未来</p><p><strong>各列元素的和等于1的矩阵用俄国数学家马尔可夫的名字命名为马尔可夫转移矩阵。</strong><br>这个矩阵经常用来表示某种变化的概率，某个地区的人口变化、市场经济的版图变化等，我们周围的各种变化都可以用这样的矩阵表示，帮助我们有效地解决问题。  </p><p>老鼠房间概率<br>城市邻接矩阵  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Math" scheme="http://yeonsea.club/categories/Math/"/>
    
    
      <category term="Basic" scheme="http://yeonsea.club/tags/Basic/"/>
    
  </entry>
  
  <entry>
    <title>布隆过滤器</title>
    <link href="http://yeonsea.club/2019/03/12/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>http://yeonsea.club/2019/03/12/布隆过滤器/</id>
    <published>2019-03-12T01:17:12.000Z</published>
    <updated>2019-08-20T10:11:51.564Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><h2 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器"></a>什么是布隆过滤器</h2><p>布隆过滤器是一种基于概率进行验重的数据结构。它的基本原理是：小概率事件不容易同时发生。</p><p>布隆过滤器使用多个哈希函数把同一个字符串转换成多个不同的哈希值，并记录这些哈希值的特征。下次再面对一个字符串时，布隆过滤器再次使用这些哈希函数把这个字符串转换为多个哈希值。如果这个哈希值全部符合原先那个字符串对应的各个哈希值的特征，则认为这两个字符串是相同的。</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希算法不是一种加密算法，而是一种不可逆的摘要算法。<br>不同的哈希函数可实现不同的哈希算法。<br>使用同一个哈希算法，能够把同一个字符串转成同一个哈希值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">code = <span class="string">'hello'</span></span><br><span class="line">result = hashlib.sha256(code.encode()).hexdigest()</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>结果是一个十六进制的_数_</p><h2 id="布隆过滤器的原理"><a href="#布隆过滤器的原理" class="headerlink" title="布隆过滤器的原理"></a>布隆过滤器的原理</h2><ol><li>假设K个哈希函数，对同一个字符串计算哈希值，得到K个完全不同的哈希值。</li><li>让这K个哈希值同时除以一个数M，就可以得到K个余数。</li><li>对于一个新的字符串，重复这个过程，如果新字符串获得的K个余数与原来的字符串对应的K个余数完全相同，那么就可以说，这两个字符串”很有可能”是同一个字符串。</li></ol><p>$$<br>1-(1-e^{\frac{-KN}{M}})^{K}<br>$$</p><h2 id="如何压缩数据容量"><a href="#如何压缩数据容量" class="headerlink" title="如何压缩数据容量"></a>如何压缩数据容量</h2><p>采用二进制保存数字</p><h2 id="布隆过滤器与Redis结合"><a href="#布隆过滤器与Redis结合" class="headerlink" title="布隆过滤器与Redis结合"></a>布隆过滤器与Redis结合</h2><p>使用Redis字符串的位操作，记录K个余数的位置即可。</p><h2 id="布隆过滤器的弊端"><a href="#布隆过滤器的弊端" class="headerlink" title="布隆过滤器的弊端"></a>布隆过滤器的弊端</h2><p>布隆过滤器只能单向验证重复。<br>随着Redis字符串对应的二进制位越来越多的为被设置为1，布隆过滤器误报的概率越来越大，因为可能其它多个字符串对应的二进制位中越来越多的位被设置为1，其中K个值刚好和一个新来的字符串的K个余数重合。<br>提前规划好数据规模与容忍的误报率。  </p><blockquote><p>最多需要对 n 个字符串进行验证重复操作，能够容忍的最大误报率为 p，那么，布隆过滤器将会使用到的二进制位的数量为：</p></blockquote><p>$$<br>m = -\frac{n\ln{p}}{\ln{2}^{2}}<br>$$</p><blockquote><p>哈希函数的个数为：</p></blockquote><p>$$<br>k = \frac{m}{n}\ln{2}<br>$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Web" scheme="http://yeonsea.club/categories/Web/"/>
    
    
      <category term="Web" scheme="http://yeonsea.club/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>用 Spring Boot 编写 RESTful API</title>
    <link href="http://yeonsea.club/2018/12/23/%E7%94%A8SpringBoot%E7%BC%96%E5%86%99RESTfulAPI/"/>
    <id>http://yeonsea.club/2018/12/23/用SpringBoot编写RESTfulAPI/</id>
    <published>2018-12-23T12:17:58.000Z</published>
    <updated>2018-12-23T12:31:19.484Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2018/12/23/用SpringBoot编写RESTfulAPI/../用SpringBoot编写RESTfulAPI/spring-boot-project-logo.png"></p><h2 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h2><p><a href="https://study.163.com/course/courseMain.htm?courseId=1005213034" target="_blank" rel="noopener">课程</a></p><h2 id="开始一个最简单的RESTFul-API项目"><a href="#开始一个最简单的RESTFul-API项目" class="headerlink" title="开始一个最简单的RESTFul API项目"></a>开始一个最简单的RESTFul API项目</h2><h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><p>Representational State Transfer</p><p>所有的东西都是资源，所有的操作都是通过对资源的增删改查（CRUD）实现</p><p>对资源的增删改查对应对URL的操作（POST,DELETE,PUT,GET）</p><p>无状态的</p><h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><p>大量使用注解，减少配置，无需配置XML<br>自带嵌入式web服务器</p><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><p>pom.xml文件是Maven项目的配置文件<br>几个常用的Maven命令（在pom.xml同级目录下运行）<br>mvn test 编译并运行测试用例<br>mvn spring-boot:run 运行spring-boot项目<br>mvn package 打包项目<br>mvn clean 可以和其它命令一起使用，例如mvn clean package</p><h3 id="日期型转JSON格式"><a href="#日期型转JSON格式" class="headerlink" title="日期型转JSON格式"></a>日期型转JSON格式</h3><p>可以在属性上增加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@JsonFormat(timezone=&quot;GMT+8&quot;, pattern=&quot;yyyy-MM-dd&quot;)</span><br></pre></td></tr></table></figure></p><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@JsonFormat（shape=JsonFormat.Shape.NUMBER）</span><br></pre></td></tr></table></figure><p>全局修改可以在application.yml  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:  </span><br><span class="line">  jackson:  </span><br><span class="line">    date-format: yyyy-MM-dd #如果使用字符串表示，用这行设置格式  </span><br><span class="line">    timezone: GMT+8  </span><br><span class="line">    serialization:   </span><br><span class="line">      write-dates-as-timestamps: true #使用数值timestamp表示日期</span><br></pre></td></tr></table></figure><h2 id="RestController详解"><a href="#RestController详解" class="headerlink" title="RestController详解"></a>RestController详解</h2><h3 id="热部署（Hot-Swapping）"><a href="#热部署（Hot-Swapping）" class="headerlink" title="热部署（Hot Swapping）"></a>热部署（Hot Swapping）</h3><p>pom中加入devtools</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h3><p>Commons-logging or SLF4j</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private static final Log log = LogFactory.getLog(Xxx.class);</span><br><span class="line">private static final Logger log = LoggerFactory.getLogger(Xxx.class);</span><br></pre></td></tr></table></figure><p>日志级别：TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL<br>application.yml配置日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  file: target/app.log</span><br><span class="line">  level: </span><br><span class="line">    ROOT: WARN</span><br><span class="line">    cn.devmgr: TRACE</span><br></pre></td></tr></table></figure></p><h3 id="命令行工具CURL"><a href="#命令行工具CURL" class="headerlink" title="命令行工具CURL"></a>命令行工具CURL</h3><p>测试工具<br><a href="https://www.getpostman.com/" target="_blank" rel="noopener">postman</a></p><h3 id="在RestController中获取各种相关信息的方法"><a href="#在RestController中获取各种相关信息的方法" class="headerlink" title="在RestController中获取各种相关信息的方法"></a>在RestController中获取各种相关信息的方法</h3><table><thead><tr><th>内容</th><th>获取方法</th></tr></thead><tbody><tr><td>URL中路径的一部分</td><td>首先需要在RequestMapping做映射，之后在方法中可以通过注解使用映射的变量。可以写多个，@PutMapping(“/{id}/characters/{cId}”)，还可以使用正则表达式限制类型（不符合要求会返回4xx的错误信息，表示请求参数有问题）此例子表示id必须是数字：@PutMapping(“/{id:\\d+}”)</td></tr><tr><td>POST方法传递过来的JSON</td><td>给参数前增加@RequestBody注解，Spring会自动把POST的Request Body部分的JSON转换成方法声明的类。如果转化失败会返回4xx错误，表示请求参数有问题。</td></tr><tr><td>POST方法传递的是表单数据</td><td>首先声明传入的是application/x-wwww-form-urlencoded的格式，可在RequestMapping增加consumes参数，@PostMapping(value=”/tvseries”, consumes=MediaType.APPLICATION_FORM_URLENCODED_VALUE)，在方法上增加参数，参数使用@RequestParam注解即可，public Object insert(@RequestParam(value=”name”, required=false) String name)，凡是可以通过HttpServletRequest.getParameter(String)方法取到的值，含表单提交的、QueryString附带的，都可以使用@RequestParam注解得到。默认是request=true。</td></tr><tr><td>QueryString的参数</td><td>使用@RequestParam注解，通过参数获得,例如：public Object query(@RequestParam(value=”page”, required=false) Integer page)</td></tr><tr><td>Request Header</td><td>可以使用@Requestheader注解获取Request的头信息,例如public ResultJSON editCompany(@RequestHeader(“user-agent”) String userAgent) 注意：@RequestHeader后面的头名字不区分大小写，但RequestParam, PathVariable等是区分的。如果RequestHeader后面不写参数，会用后面的变量名替代。</td></tr><tr><td>获取cookie值</td><td>使用cookieValue注解，和其它类似，除非为了兼容老现有客户端，新API里不建议用cookie。</td></tr><tr><td>获取当前的Request Response</td><td>直接写参数，例如：public Object doSomething(HttpServletRequest request, HttpServletResponse response)</td></tr><tr><td>获取当前用户</td><td>直接在方法上增加参数，类型为org.springframework.security.core.Authentication, 例如：public TvSeries deleteOne(Authentication auth)，参数auth内会存储有当前的用户信息。</td></tr><tr><td>文件上传</td><td>首先要设置consumes为multipart/form-data，@PostMapping(value=”/files”, consumes=MediaType.MULTIPART_FORM_DATA_VALUE),在方法中写参数 public Map&lt;String, Object&gt; uploadFile(@RequestParam(“file”) MultipartFile file)。在方法中可以直接使用MultipartFile中的流保存文件了。</td></tr></tbody></table><h3 id="对客户端传入数据的校验"><a href="#对客户端传入数据的校验" class="headerlink" title="对客户端传入数据的校验"></a>对客户端传入数据的校验</h3><p>原则：不要相信前端传过来的数据；尽量要前端少传递数据</p><p>Bean Validation: JSR303, Hibernate Validator</p><p>Bean Validation 注解：<br>@Null<br>@NotNull<br>@Min<br>@Max<br>@Size<br>@Past  验证Date<br>@Future<br>@AssertTrue  验证Boolean<br>@AssertFalse<br>@Valid 级联验证注解</p><table><thead><tr><th>类型</th><th>注解</th></tr></thead><tbody><tr><td>任何类型</td><td>NULL, NotNull</td></tr><tr><td>布尔型</td><td>AssertTrue, AssertFalse</td></tr><tr><td>字符串</td><td>NotBlank, Pattern, Size, Email, DecimalMin, Digits</td></tr><tr><td>数值</td><td>DecimalMax, DecimalMin, Digits, Max, Min, NegativeOrZero, Positive, PositiveOrZero</td></tr><tr><td>集合、Map、List</td><td>NotEmpty, Size</td></tr><tr><td>日期</td><td>Future, Past, FutureOrPresent, PastOrPresent</td></tr></tbody></table><blockquote><p>以上注解都指Bean Validation 2.0 定义的注解，在javax.validation.constraints包下。Hibernate有些非JSR标准注解和上面的同名但package不同，功能会和上面这些有些细微差异。</p></blockquote><p>约束规则对子类依旧有效<br>groups参数  </p><ul><li>每个约束用注解都有一个groups参数</li><li>可接收多个class类型（必须是接口）</li><li>不声明groups参数是默认组javax.validation.groups.Default</li><li>声明了groups参数的会从Default组移除，如需加入Default组需要显示声明，例如@Null(groups={Default.class, Step1.class})</li></ul><p>@Valid vs @Validated</p><ul><li>@Valid是JSR标准定义的注解，只验证Default组的约束</li><li>@Validated是Spring定义的注解，可以通过参数来指定验证的组，例如：@Validation({Step1.class,Default.class})表示验证Step1和Default两个组的约束</li><li>@Valid可用在成员变量上，进行级联验证；@Validated只能用在参数上，表示这个参数需要验证<blockquote><p>参数中只用@Validated，通不过校验的参数，不会执行这个方法，加上BindingResult result ，参数通不过校验也会进入方法执行，校验结果会通过result参数传递进来。</p></blockquote></li></ul><p>手动验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 装载验证器</span><br><span class="line">@Autowired Validator validator;</span><br><span class="line">// 验证某个类，下面是执行默认的验证组，如果需要指定验证组，多传一个class参数</span><br><span class="line">Set&lt;ConstraintViolation&lt;?&gt;&gt; result = validator.validate(obj);</span><br><span class="line">// 通不过校验result的集合会有值，可以通过size()判断</span><br></pre></td></tr></table></figure><h2 id="在Spring-Boot项目中使用Mybatis"><a href="#在Spring-Boot项目中使用Mybatis" class="headerlink" title="在Spring Boot项目中使用Mybatis"></a>在Spring Boot项目中使用Mybatis</h2><h3 id="程序的层次结构"><a href="#程序的层次结构" class="headerlink" title="程序的层次结构"></a>程序的层次结构</h3><p>Web前端、App、小程序、其它系统等<br>Web控制层：@RestController @Controller<br>业务逻辑层：@Service<br>数据访问层：@Repository<br>@Component<br>数据库</p><p>PBF: Package by Feature 按功能划分<br>PBL: Package by Layer 按层次划分  </p><h3 id="相邻层次的数据传输"><a href="#相邻层次的数据传输" class="headerlink" title="相邻层次的数据传输"></a>相邻层次的数据传输</h3><ul><li>PO：Persistant Object 持久对象</li><li>DTO：Data Transfer Object 数据传输对象</li><li>VO：Value Object 或 View Object</li><li>POJO：Pure Old Java Object 或 Plain Ordinary Java Object</li><li>DO：Domain Object</li><li>BO：Business Object 处理业务逻辑</li><li>DAO：Data Access Object</li></ul><p>JavaBean:  </p><ul><li>有一个public的无参构造方法</li><li>属性private，且可以通过get、set、is（可以替代get，用在布尔型属性上）方法或遵循特定命名规范的其它方法访问</li><li>可序列化，实现Serializable接口</li></ul><p>POJO vs JavaBean:</p><ul><li>POJO比javabean更简单。POJO严格的遵守简单对象的概念，而一些JavaBean中往往会封装一些简单逻辑。</li><li>POJO主要用于数据的临时传递，它只能装载数据，作为数据存储的载体，不具有业务逻辑处理能力。</li><li>JavaBean虽然数据的获取与POJO一样，但是javabean当中可以有其他方法。</li></ul><p>几种简化方案：  </p><ul><li>一种POJO从web控制层到数据访问层</li><li>用JavaBean代替POJO</li><li>POJO的get,set写起来也麻烦，用public的field代替</li></ul><h3 id="添加Mybatis支持步骤"><a href="#添加Mybatis支持步骤" class="headerlink" title="添加Mybatis支持步骤"></a>添加Mybatis支持步骤</h3><ol><li>修改pom.xml，添加mybatis支持</li><li>修改application.yml添加数据库连接</li><li>修改启动类，增加@MappingScan(“package-of-mapping”)注解</li><li>添加Mybatis Mapping接口</li><li>添加Mapping对应的XML（可选）</li></ol><p>pom.xml中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.postgresql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>application.yml中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    dbcp2.validation-query: select 1</span><br><span class="line">    driverClassName: org.postgresql.Driver</span><br><span class="line">    url: jdbc:postgresql://127.0.0.1:5432/thedb?stringtype=unspecified</span><br><span class="line">    username: </span><br><span class="line">    password:</span><br></pre></td></tr></table></figure><h2 id="Spring-Boot-项目的单元测试"><a href="#Spring-Boot-项目的单元测试" class="headerlink" title="Spring Boot 项目的单元测试"></a>Spring Boot 项目的单元测试</h2><h3 id="Assert-JUnit的断言"><a href="#Assert-JUnit的断言" class="headerlink" title="Assert-JUnit的断言"></a>Assert-JUnit的断言</h3><ul><li>判断某条件是否为真 Assert.assertTrue(条件表达式)；</li><li>判断某条件是否为假 Assert.assertFalse(条件表达式)；</li><li>判断两个变量值是否相同 Assert.assertEquals(val1, val2);</li><li>判断两个变量值是否不相同 Assert.assertNotEquals(val1, val2);</li><li>判断两个数组是否相同 Assert.assertArrayEquals(数组1, 数组2)；</li><li>直接测试失败 Assert.fail()  Assert.fail(message)</li></ul><h3 id="Assert-vs-assert"><a href="#Assert-vs-assert" class="headerlink" title="Assert vs assert"></a>Assert vs assert</h3><ul><li>Assert是JUnit的断言类，全名是org.junit.Assert</li><li>Assert提供了很多静态方法，例如…</li><li>assert是java关键字，使用方法有两种，表达式为false时，jvm会退出；</li><li>assert关键字内表达式是否被检查成立依赖jvm的参数，默认是关闭的<blockquote><p>Java命令行参数：-ea (enableassertions)  -da (disableassertions 默认)</p></blockquote></li></ul><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>驱动模块</li><li>被测模块</li><li>桩模块 使用场景：替代尚未开发完毕的子模块；替代对环境依赖较大的子模块（例如数据访问层）；</li></ul><h3 id="mockito"><a href="#mockito" class="headerlink" title="mockito"></a>mockito</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mockito&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mockito-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="TDD"><a href="#TDD" class="headerlink" title="TDD"></a>TDD</h3><ul><li>Test Driven Development (测试驱动开发)</li><li>先写测试用例，后写实现代码</li><li>重构现有代码时特别好用<blockquote><p>RDD: Resume Driven Development</p></blockquote></li></ul><h2 id="在-Spring-中管理数据库事务"><a href="#在-Spring-中管理数据库事务" class="headerlink" title="在 Spring 中管理数据库事务"></a>在 Spring 中管理数据库事务</h2><h3 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h3><ul><li>name 当在配置文件中有多个TransactionManager,可以用该属性指定选择哪个事务管理器。</li><li>propagation 事务的传播行为，默认值为REQUIRED。</li><li>isolation 事务的隔离度，默认采用DEFAULT。</li><li>timeout 事务的超时时间，默认值为-1,。如果超过该时间限制但事务还没有完成，则自动回滚事务。</li><li>readOnly 指定事务是否为只读事务，默认值为false；为了忽略那些不需要事务的方法，比如读取数据，可以设置readOnly为true。</li><li>rollbackFor 指定能够触发事务回滚的异常类型。</li><li>noRollbackFor 指定的异常类型，不回滚事务<blockquote><p>1.noRollbackFor或子类；2.rollbackFor或子类；3.throws定义的异常或子类；4.其它异常；5.无异常</p></blockquote></li></ul><h3 id="Transactional-propagation-xx"><a href="#Transactional-propagation-xx" class="headerlink" title="@Transactional(propagation=xx)"></a>@Transactional(propagation=xx)</h3><ol><li>propagation.REQUIRED 如果有事务，那么加入事务，没有的话新建一个（默认）</li><li>propagation.NOT_SUPPORTED 容器不为这个方法开启事务</li><li>propagation.REQUIRED_NEW 不管是否存在事务，都创建一个新的事务，原来的挂起，新的执行完毕，继续执行老的事务</li><li>propagation.MANDATORY 必须在一个已有的事务中执行，否则抛出异常</li><li>propagation.NEVER 必须在一个没有的事务中执行，否则抛出异常（与propagation.MANDATORY相反）</li><li>propagation.SUPPORTS 如果其它bean调用这个方法，在其它bean中声明事务，那就用事务，如果其它bean没有声明事务那就不用事务</li><li>propagation.NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与propagation.REQUIRED类似的操作</li></ol><h3 id="Transactional-isolation-xx"><a href="#Transactional-isolation-xx" class="headerlink" title="@Transactional(isolation=xx)"></a>@Transactional(isolation=xx)</h3><ol><li>Isolation.READ_UNCOMMITTED 读未提交数据 （脏读、不可重复读、幻读）</li><li>Isolation.READ_COMMITTED 读已提交数据（不可重复读、幻读）</li><li>Isolation.REPEATABLE_READ 可重复读 （幻读）</li><li>Isolation.SERIALIZATION 串行化 </li><li>Isolation.DEFAULT 使用数据库默认</li></ol><h3 id="Isolation-vs-Lock"><a href="#Isolation-vs-Lock" class="headerlink" title="Isolation vs Lock"></a>Isolation vs Lock</h3><ul><li>两个不同的东西，隔离不是靠锁实现的，是靠对数据的监控实现的。</li><li>锁：表加好锁了，除非出现死锁等特殊情况，事务是不会被数据库主动回滚的。</li><li>隔离：如果发现数据不符合数据库隔离级别，当前事务会出错并回滚。相比锁被回滚可能性较大，需要程序有出错重试的步骤。</li></ul><h3 id="Transactional注解的timeout参数"><a href="#Transactional注解的timeout参数" class="headerlink" title="@Transactional注解的timeout参数"></a>@Transactional注解的timeout参数</h3><ul><li>timeout事务的超时时间，默认值为-1,。如果超过该时间限制但事务还没有完成，则自动回滚事务。</li><li>方法抛出异常，事务被回滚，可能是SQL执行时间过长的异常，也可能是TransactionTimedOutException</li><li>从方法执行开始计算，每个SQL执行前检查一次是否超时，方法全部执行完毕后不检查是否超时</li></ul><h2 id="Mybatis进阶"><a href="#Mybatis进阶" class="headerlink" title="Mybatis进阶"></a>Mybatis进阶</h2><h3 id="复杂类的ORMapping和主子表的同时数据插入"><a href="#复杂类的ORMapping和主子表的同时数据插入" class="headerlink" title="复杂类的ORMapping和主子表的同时数据插入"></a>复杂类的ORMapping和主子表的同时数据插入</h3><p>#{}可转义 ${} 不可转义（可能导致sql注入）  </p><h3 id="使用TypeHandler处理枚举、数组、JSON等特殊类型"><a href="#使用TypeHandler处理枚举、数组、JSON等特殊类型" class="headerlink" title="使用TypeHandler处理枚举、数组、JSON等特殊类型"></a>使用TypeHandler处理枚举、数组、JSON等特殊类型</h3><p>EnumTypeHandler vs EnumOrdinalTypeHandler</p><ul><li>EnumTypeHandler存储的是对应类的名字，可以存储成一个字符串</li><li>EnumOrdinalTypeHandler存储的是枚举类型的顺序</li></ul><p>ArrayTypeHandler<br>自定义JsonTypeHandler</p><h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2><h3 id="安全控制的层级"><a href="#安全控制的层级" class="headerlink" title="安全控制的层级"></a>安全控制的层级</h3><ul><li>基于URL的控制</li><li>基于方法的控制</li><li>程序内</li></ul><h3 id="配置Spring-Security"><a href="#配置Spring-Security" class="headerlink" title="配置Spring Security"></a>配置Spring Security</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSecurity</span><br><span class="line">@EnableGlobalMethodSecurity(prePostEnabled = true, jsr250Enabled = false)</span><br><span class="line">public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    private final static Log log = LogFactory.getLog(WebSecurityConfig.class);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity httpSecurity) throws Exception &#123;</span><br><span class="line">        if (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(&quot;configure httpSecurity...&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //默认的spring-security配置会让所有的请求都必须在已登录的状况下访问；下面这段代码禁止了这种操作。</span><br><span class="line">        httpSecurity.csrf().disable()</span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()</span><br><span class="line">                .authorizeRequests().anyRequest().permitAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-Security-注解"><a href="#Spring-Security-注解" class="headerlink" title="Spring Security 注解"></a>Spring Security 注解</h3><p>@EnableGlobalMethodSecurity(prePostEnable=true, securedEnable=true, jsr250Enabled=true)<br>prePostEnable=true: @PreAuthorize @PostAuthorize @PreFilter @PostFilter<br>securedEnable=true: @Secured<br>jsr250Enable: @RolesRequied (JSR250)  </p><h3 id="PreAuthorize-PostAuthorize-中常用的表达式"><a href="#PreAuthorize-PostAuthorize-中常用的表达式" class="headerlink" title="@PreAuthorize @PostAuthorize 中常用的表达式"></a>@PreAuthorize @PostAuthorize 中常用的表达式</h3><ul><li>hasRole(‘user’, ‘admin’)  hasAnyRole(‘user’, ‘admin’)</li><li>hasAuthority(‘query’, ‘update’)   hasAnyAuthority(‘query’, ‘update’)</li><li>permitAll denyAll</li><li>principal, authentication 当前用户</li></ul><h3 id="Role-vs-Authorization"><a href="#Role-vs-Authorization" class="headerlink" title="Role vs Authorization"></a>Role vs Authorization</h3><ul><li>ROLE_开头则是role</li><li>JSR250 RolesAllowed全部要求是role</li><li>Spring EL中hasRole也要求是role hasAuthority则不用ROLE_开头</li></ul><h3 id="Controller内获取当前用户"><a href="#Controller内获取当前用户" class="headerlink" title="Controller内获取当前用户"></a>Controller内获取当前用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Object doSomething(Authentication auth)&#123;</span><br><span class="line">    User u = (User) auth.getPrincipal();</span><br><span class="line">&#125;</span><br><span class="line">或  </span><br><span class="line">Authentication auth = SecurityContextHolder.getContext().getAuthentication();</span><br></pre></td></tr></table></figure><h3 id="启用Spring-Security"><a href="#启用Spring-Security" class="headerlink" title="启用Spring Security"></a>启用Spring Security</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="OpenId"><a href="#OpenId" class="headerlink" title="OpenId"></a>OpenId</h3><ul><li>提供用户追踪方式</li><li>无需使用用户名密码登录</li><li>协议2.0版提供属性交换功能</li><li>目前已经很少使用</li></ul><h3 id="OAuth开放授权"><a href="#OAuth开放授权" class="headerlink" title="OAuth开放授权"></a>OAuth开放授权</h3><ul><li>目前是OAuth2.0</li><li>2.0不兼容1.0</li><li>密码无需告诉第三方</li><li>为用户提供一个令牌，允许通过令牌访问资源</li></ul><h3 id="OAuth-2-0-Grant-Types"><a href="#OAuth-2-0-Grant-Types" class="headerlink" title="OAuth 2.0 Grant Types"></a>OAuth 2.0 Grant Types</h3><ul><li>授权码模式 Authorization Code</li><li>简化模式 Implicit</li><li>密码模式 Password</li><li>客户端模式 Client Credentials</li><li>Refresh Token</li></ul><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><ul><li>JSON Web Token</li><li>三部分：Header、Playload、Verify Signature</li><li>Header：头部信息，声明类型和加密算法</li><li>Playload：载荷</li><li>Verify Signature：签名，用于验证头部和载荷部分是否被修改过</li></ul><h3 id="JWT的加密方式"><a href="#JWT的加密方式" class="headerlink" title="JWT的加密方式"></a>JWT的加密方式</h3><ul><li>HMAC  共用一个秘钥</li><li>SHA256    公钥私钥分开</li></ul><h3 id="生成JWT和验证JWT的jar"><a href="#生成JWT和验证JWT的jar" class="headerlink" title="生成JWT和验证JWT的jar"></a>生成JWT和验证JWT的jar</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.auth0&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>网站：<a href="https://github.com/auth0/java-jwt" target="_blank" rel="noopener">https://github.com/auth0/java-jwt</a>  </p><h2 id="Spring-Async-Scheduling-amp-Cache"><a href="#Spring-Async-Scheduling-amp-Cache" class="headerlink" title="Spring Async, Scheduling &amp; Cache"></a>Spring Async, Scheduling &amp; Cache</h2><h3 id="Spring-Async-异步执行"><a href="#Spring-Async-异步执行" class="headerlink" title="Spring Async 异步执行"></a>Spring Async 异步执行</h3><p>配置：@EnableAsync (@SpringBootApplication 那里)<br>使用：@Async （方法上）<br>@Async方法返回值：  </p><ul><li>void</li><li>Future<t></t></li><li>其他类型一律返回null；遇到int/double/float/boolean基本类型，执行时会抛出异常：AopInvocationException;</li></ul><h3 id="Spring-Scheduling"><a href="#Spring-Scheduling" class="headerlink" title="Spring Scheduling"></a>Spring Scheduling</h3><p>使用：</p><ul><li>@EnableScheduling 注解启用Scheduling</li><li>方法上加@Scheduled注解，方法会按照参数定期执行<br>@Scheduled 参数：</li><li>cron 值为字符串</li><li>zone 设置时区</li><li>fixedDelay (单位毫秒)，每次方法执行完毕后，休息固定时间后再次启动</li><li>fixedRate (单位毫秒)按照固定频率启动执行<br>-initialDelay (单位毫秒)，和上面三个参数搭配使用，首次执行延时 </li></ul><p>集群/负载均衡环境</p><ul><li>独立出来一个application运行scheduling task</li><li>使用：Quartz Scheduler</li></ul><h3 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h3><p>缓存：  </p><ul><li>利用java程序中的变量（简单；集群环境中多个实例无法同步）</li><li>缓存服务器（Memcached，Redis）<br>Spring中通过注解使用缓存  </li><li>@EnableCaching启用缓存注解</li><li>@Cacheable</li><li>@CacheEvict</li><li>@CachePut</li><li>@CacheConfig</li></ul><h3 id="使用-Redis-缓存服务"><a href="#使用-Redis-缓存服务" class="headerlink" title="使用 Redis 缓存服务"></a>使用 Redis 缓存服务</h3><p>POM中加入依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependecy&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>application.yml 中加入配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cache:</span><br><span class="line">    redis:</span><br><span class="line">      time-to-live: 3306</span><br><span class="line">  redis:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 6379</span><br><span class="line">    pool:</span><br><span class="line">      max-active: 5</span><br><span class="line">      max-idle: 10</span><br><span class="line">      max-wait: 10000</span><br></pre></td></tr></table></figure><h2 id="Websocket-amp-JMS"><a href="#Websocket-amp-JMS" class="headerlink" title="Websocket &amp; JMS"></a>Websocket &amp; JMS</h2><p>Websocket</p><ul><li>全双工通道，数据双向传输</li><li>浏览器和服务器之间的持久性的连接</li><li>比轮询/长轮询大幅节省资源</li><li>使用80/443等HTTP端口</li><li>ws://example.com/wsapi wss://secure.example.com/</li><li>IE10以上浏览器支持</li></ul><p>JMS  </p><ul><li>Java Message Service – Java消息服务</li><li>在两个应用程序或者分布式服务之间提供异步消息通讯</li><li>应用间解耦</li><li>企业应用集成中应用较多</li><li>消息服务器很多，Apache ActiveMQ是比较常见的一个</li></ul><p>JMS消息模式</p><ul><li>点对点（P2P）：每个消息有一个生产者一个消费者</li><li>发布者/订阅者（Pub/Sub）:每个消息一个生产者、多个消费者</li></ul><p>安装ActiveMQ<br>  配置pom文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>  配置application.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  activemq:</span><br><span class="line">    broker-url: tcp://127.0.0.1:61616</span><br></pre></td></tr></table></figure><p>  @EnableJms 注解</p><h2 id="部署Spring-Boot项目"><a href="#部署Spring-Boot项目" class="headerlink" title="部署Spring Boot项目"></a>部署Spring Boot项目</h2><h3 id="Spring-Profile-和配置日志记录框架"><a href="#Spring-Profile-和配置日志记录框架" class="headerlink" title="Spring Profile 和配置日志记录框架"></a>Spring Profile 和配置日志记录框架</h3><ul><li>可以设置不同的配置参数</li><li>可以设置不同的bean的装载</li></ul><p>Active Profile</p><ul><li>同时可以有多个被激活的profile</li><li>有active和default两个概念</li><li>如果没有设置active，则spring使用设置的default，如果没有声明default，则使用那些无显示指定的作为default</li></ul><h3 id="生产环境架构"><a href="#生产环境架构" class="headerlink" title="生产环境架构"></a>生产环境架构</h3><p>性能调优</p><ul><li>前端：数据缓存；加载顺序；显示顺序；预先加载；</li><li>NGINX: 设置客户端缓存；数据压缩传输；HTTP2.0</li><li>应用：优化算法；优化SQL（慢SQL）；避免N+1查询；异步操作；使用缓存；不常修改数据的静态化；集群；</li><li>数据库：索引和统计信息；优化表结构；冗余列和计算列；表拆分；分区表；统计慢SQL（提供程序）；SQL优化建议；升级硬件；</li></ul><h3 id="以服务程序运行（ubuntu）"><a href="#以服务程序运行（ubuntu）" class="headerlink" title="以服务程序运行（ubuntu）"></a>以服务程序运行（ubuntu）</h3><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="在-Spring-Boot-项目中使用Servlet-Filter-Listener等"><a href="#在-Spring-Boot-项目中使用Servlet-Filter-Listener等" class="headerlink" title="在 Spring Boot 项目中使用Servlet,Filter,Listener等"></a>在 Spring Boot 项目中使用Servlet,Filter,Listener等</h3><p>Servlet  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(name=&quot;QrcodeServlet&quot;, urlPatterns=&quot;/servlet/qrcode&quot;)</span><br><span class="line">public class QrcodeServlet extends HttpServlet implements Serializable&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Filter  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@WebFilter</span><br><span class="line">public class LogFilter implements Filter &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@ServletComponentScan 注解<br>@ComponentScan  </p><h3 id="Autowired-的加载规则"><a href="#Autowired-的加载规则" class="headerlink" title="Autowired 的加载规则"></a>Autowired 的加载规则</h3><p>@Autowired</p><ul><li>查找被注解的变量类型，找到所有此类型的构建或此类型子类的构建。</li><li>如果一个也没有找到，看required参数，false则用null，true则失败（默认）。</li><li>如果仅找到一个，则装载这个构件。</li><li>如果找到多个，且只有一个有@Primary注解，使用Primary的。</li><li>如果不符合上述条件，失败。</li></ul><p>@Autowired @Qualifier</p><ul><li>如果属性既有Autowired注解又有Qualifier注解</li><li>在构件中查找名字为Qualifier中指定的名字的注解。</li><li>在构件上指定名字的方法有两个，@Service(“这里写名字”)，@Qualifier(“这里写名字”)。</li></ul><h3 id="API-的版本"><a href="#API-的版本" class="headerlink" title="API 的版本"></a>API 的版本</h3><p>客户端传递版本信息方式</p><ul><li>URL</li><li>RequestHeader</li></ul><p>URL</p><ul><li>部署，通过修改NGINX配置，不同域名，不同前缀。</li><li>修改application.yml中的contextPath，server.servlet.contextPath:/tutorial-v2</li><li>修改@RequestMapping中的参数，例如，@RequestMapping(“/v1/tvseries”)</li><li>增加request的参数，例如：/tvseries?version=2</li></ul><p>Request Header  </p><ul><li>自定义request header，例如：Version:2</li><li>使用Accept  Accept:application/vnd.tutorial.v2 + json</li></ul><p>自定义 RequestMappingHandlerMapping  </p><ul><li>自定义ApiVersion注解</li><li>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</li></ul><h3 id="定制Spring-REST的错误返回信息"><a href="#定制Spring-REST的错误返回信息" class="headerlink" title="定制Spring REST的错误返回信息"></a>定制Spring REST的错误返回信息</h3><p>Controller中单独处理</p><ul><li>把返回值改成ResponseEntity<t></t></li><li>T为要返回的内容</li><li>通过ResponseEntity来设置返回的HttpResponse状态码</li></ul><p>全局的异常处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">public class ExceptionHandler &#123;</span><br><span class="line">    @ExceptionHandler(Throwable.class)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    ResponseEntity&lt;Object&gt; handleControllerException(Throwable ex, WebRequest request) &#123;</span><br><span class="line">        //处理异常，并设置给客户端反馈的信息</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Spring" scheme="http://yeonsea.club/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yeonsea.club/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>赠药山高僧惟俨二首</title>
    <link href="http://yeonsea.club/2018/12/23/%E8%B5%A0%E8%8D%AF%E5%B1%B1%E9%AB%98%E5%83%A7%E6%83%9F%E4%BF%A8%E4%BA%8C%E9%A6%96/"/>
    <id>http://yeonsea.club/2018/12/23/赠药山高僧惟俨二首/</id>
    <published>2018-12-23T11:11:58.000Z</published>
    <updated>2018-12-23T12:11:43.069Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2018/12/23/赠药山高僧惟俨二首/../赠药山高僧惟俨二首/赠药山高僧惟俨二首.jpeg"></p><blockquote><p>练得身形如鹤形，千株松下两函经。我来问道无馀说，云在青霄水在瓶。</p></blockquote><blockquote><p>选得幽居惬野情，终年无送亦无迎。有时直上孤峰顶，月下披云啸一声。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tao" scheme="http://yeonsea.club/categories/Tao/"/>
    
    
      <category term="Tao" scheme="http://yeonsea.club/tags/Tao/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yeonsea.club/2018/12/22/hello-world/"/>
    <id>http://yeonsea.club/2018/12/22/hello-world/</id>
    <published>2018-12-22T15:53:34.885Z</published>
    <updated>2018-12-23T12:12:50.552Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2018/12/22/hello-world/../hello-world/hello-world.jpg"></p><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
</feed>
