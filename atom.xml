<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Đinh Giang</title>
  
  <subtitle>人生は意味が、唯一の生活をすることができますが见つかりました楽しいこと、 のような花が见つかる、あなた様と私が见つかりました</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yeonsea.club/"/>
  <updated>2019-10-14T06:30:20.447Z</updated>
  <id>http://yeonsea.club/</id>
  
  <author>
    <name>J</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式网站数据分析</title>
    <link href="http://yeonsea.club/2019/10/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%AB%99%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    <id>http://yeonsea.club/2019/10/10/分布式网站数据分析/</id>
    <published>2019-10-10T10:01:22.000Z</published>
    <updated>2019-10-14T06:30:20.447Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="日志收集"><a href="#日志收集" class="headerlink" title="日志收集"></a>日志收集</h2><ul><li>PV：Page View，页面浏览量</li><li>UV：Unique visitor，独立访问者</li><li>RT：Response time，响应时间</li></ul><p>一个稳步运行的分布式系统可能包含成百上千台机器，因此，在进行数据分析之前，必须先对各个运行系统上的日志进行收集。再将收集好的数据发送到统一的系统进行分析和处理，筛选出有价值的内容，进行可视化展现。</p><h3 id="inotify-机制"><a href="#inotify-机制" class="headerlink" title="inotify 机制"></a>inotify 机制</h3><p>Linux 内核从 2.6.13 开始，引入了 inotify 机制。<br>通过 inotify 机制，能够对文件系统的变化进行监控，如对文件进行删除、修改等操作，可以及时通知应用程序进行相关事件的处理。<br>这种响应性的处理机制，避免了频繁的文件轮询任务，提高了任务的处理效率。</p><p>通过命令来查看内核版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure></p><p>查看系统是否支持 inotify<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep INOTIFY_USER /boot/config-$(uname -r)</span><br></pre></td></tr></table></figure></p><p>使用 inotify 的第一步便是创建 inotify 实例，每个 inotify 实例对应一个独立的等待队列：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = inotify_init();</span><br></pre></td></tr></table></figure></p><p>为相应的文件添加 watch<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> wd = inotify_add_watch(fd, path, IN_MODIFY | IN_CREATE | IN_DELETE);</span><br></pre></td></tr></table></figure></p><p>inotify_event 结构体：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inotify_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> wd; <span class="comment">/* watch 描述符 */</span></span><br><span class="line"><span class="keyword">unit32_t</span> mask;<span class="comment">/* watch 掩码，标识事件的类型 */</span></span><br><span class="line"><span class="keyword">unit32_t</span> cookie;<span class="comment">/* 用来同步两个事件的 cookie，同步两个事件的状态 */</span></span><br><span class="line"><span class="keyword">unit32_t</span> len;<span class="comment">/* name 的长度 */</span></span><br><span class="line"><span class="keyword">char</span> name __flexarr;<span class="comment">/* 名称 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过 read 系统调用来对事件进行读取：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVENT_SIZE sizeof(struct inotify_event)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_LEN 1024 * (EVENT_SIZE + 256)</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">buffer</span><span class="params">(BUF_LEN)</span></span>;</span><br><span class="line">read(fd, buffer, BUF_LEN);</span><br></pre></td></tr></table></figure></p><p>当程序执行完后，需要对注册的 watch 进行清理：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inotify_rm_watch(fd, wd);</span><br></pre></td></tr></table></figure></p><p>日志一般以追加写入的方式来进行写入，通过 inotify 机制来读取日志修改事件，将日志追加的内容输出。</p><h3 id="ActiveMQ-CPP"><a href="#ActiveMQ-CPP" class="headerlink" title="ActiveMQ-CPP"></a>ActiveMQ-CPP</h3><p>CMS(C++ Message Service)<br>ActiveMQ-CPP 是 CMS 的一种实现，是一个能够与 ActiveMQ 进行通信的 C++ 客户端库。</p><h4 id="ActiveMQ-CPP-的安装"><a href="#ActiveMQ-CPP-的安装" class="headerlink" title="ActiveMQ-CPP 的安装"></a>ActiveMQ-CPP 的安装</h4><ol><li>安装 libuuid</li><li>安装 apr</li><li>安装 apr-util</li><li>安装 apr-iconv</li><li>安装 openssl</li><li>安装 ActiveMQ-CPP</li></ol><h4 id="ActiveMQ-CPP-的使用"><a href="#ActiveMQ-CPP-的使用" class="headerlink" title="ActiveMQ-CPP 的使用"></a>ActiveMQ-CPP 的使用</h4><h3 id="架构和存储"><a href="#架构和存储" class="headerlink" title="架构和存储"></a>架构和存储</h3><p>inotify 解决了日志收集的问题，ActiveMQ 解决了日志数据分发的问题，接下来是日志收集系统架构与存储方案选择的问题。</p><p>一个常见的日志收集系统架构。数据需要经过 inotify 客户端，经由 ActiveMQ 进行转发，通过 Storm 进行实时处理，再存储到 MySQL、HDFS、Hbase或者Memcahce这些存储系统当中，最后再进行深度分析或者实时的展现。</p><h3 id="Chukwa"><a href="#Chukwa" class="headerlink" title="Chukwa"></a>Chukwa</h3><p>另一种解决方案</p><h2 id="离线数据分析"><a href="#离线数据分析" class="headerlink" title="离线数据分析"></a>离线数据分析</h2><p>Hadoop 目前的应用主要集中在大数据的离线批处理分析领域，MapReduce 编程模型在海量数据分析场景下能够体现出较高的效率。而对于数据量不那么大以及实时性要求很高的数据分析场景，使用 Hadoop 的效果并不是很理想。一般来说，离线数据分析所输入的数据都是前一天或者前 N 天的数据，因此，计算得到的结果会滞后于当前时间。</p><p>当然，离线数据分析的结果，可以通过数据回流，重新存储到关系型数据库，提供在线的实时查询服务，如好友推荐、商品推荐、质量评估。</p><h3 id="Hadoop-项目"><a href="#Hadoop-项目" class="headerlink" title="Hadoop 项目"></a>Hadoop 项目</h3><p>Hadoop 是一个提供可伸缩的、可信赖的分布式计算的开源项目，支持 Google 的 MapReduce 编程范式，能够将作业分割成许多小的任务，并将这些任务放到任何的集群节点上执行。用户可以在不了解分布式系统底层细节的情况下，充分利用集群的力量，开发分布式应用程序，实现大规模分布式并行（Parallel）计算、存储和管理海量数据。</p><h4 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h4><h5 id="HDFS-1"><a href="#HDFS-1" class="headerlink" title="HDFS"></a>HDFS</h5><p>分布式文件系统并非传统意义上的文件系统，它工作在操作系统的用户空间，由应用程序来实现，因此并不依赖于底层文件系统的具体实现。分布式文件系统能够对分布在各个存储设备中的文件进行统一的管理，并且提供统一的读、写访问接口。<br>相较于传统的文件系统，它往往更像一个抽象的实现，拥有自己独特的内容组织结构，从而保持了高容错、高可靠、高可扩展、低成本、高吞吐的特性。</p><h5 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h5><p>可分为 map 和 reduce 两个阶段。</p><h2 id="流式数据分析"><a href="#流式数据分析" class="headerlink" title="流式数据分析"></a>流式数据分析</h2><blockquote><p>流式数据的特征是数据会源源不断地从各个地方汇集过来，来源众多，格式复杂，且数据量巨大。对于流式数据的处理，有这样一种观点，即数据的价值将随着时间的流逝而降低，因此数据生成后最好能够尽快地进行处理，实时地响应计算结果，而非等到数据累积以后再定期地进行处理。这样，对应的数据处理工具必须具备高性能、实时性、分布式和易用性几个特征。对于流式数据的处理，更多关心的是数据的整体价值，而非数据的局部特征。</p></blockquote><h3 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>类似于 Hadoop 的 MapReduce 思想，不同的是，MapReduce 执行的是批处理任务，而 Storm 所提出的 Topology 原语，执行的是实时处理任务。<br>批处理任务最终会结束，而 Topology 任务却会永远的运行，知道用户手动 kill 掉。</p><p>应用： </p><ul><li>实时分析</li><li>在线机器学习</li><li>持续计算</li><li>分布式 RPC、ETL</li></ul><p>特点：</p><ul><li>编程模型简单</li><li>高容错性和高可靠性</li><li>高效</li><li>多语言支持</li><li>可扩展性</li></ul><h5 id="Topology"><a href="#Topology" class="headerlink" title="Topology"></a>Topology</h5><p>好比是一张计算图谱，每个节点上都包含有 Topology 的处理逻辑，通过数据的流动将各个节点联系到一起。当某个任务运行异常时，Storm 会重新分配运行失败的任务，并且保证数据不会丢失。</p><h5 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h5><p>stream 是一个没有边界的 tuple（元组） 序列，而 Storm 则提供了在分布式环境中进行可靠的流转换的原语。</p><h2 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h2><p>数据分析过程：<br>首先从线上的 OLTP 库中，以及日志系统当中，提取和清洗所需要的数据到 OLAP 系统，如构建在 Hadoop 系统上的 Hive 平台，然后在 OLAP 系统上进行多维度复杂的数据分析和汇总操作，利用这些数据构建数据报表，提供前端展现。</p><ul><li>OLTP: 是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，如银行交易、电商网站的下单操作等。</li><li>OLAP: 是数据仓库系统的主要应用，支持复杂的数据分析操作，侧重决策支持，并且提供直观易懂的查询结果。</li></ul><p>同步方式：</p><ul><li>全量数据同步：在每天系统负载最低时，将所有在线系统的数据都全量 dump 到离线系统当中来进行分析。</li><li>实时数据变更同步：同步在线系统的每一次变更，实时地将变更反映到接收变更的库。</li></ul><h3 id="离线数据同步"><a href="#离线数据同步" class="headerlink" title="离线数据同步"></a>离线数据同步</h3><p>通过任务调度，将数据同步任务安排在访问量最低时执行。<br>Sqoop 是 Apache 下的一个开源数据同步工具。<br>DataX，淘宝。</p><h3 id="实时数据同步"><a href="#实时数据同步" class="headerlink" title="实时数据同步"></a>实时数据同步</h3><p>可以利用类似 ActiveMQ 的消息系统来进行实时的增量数据同步。<br>在执行数据新增、数据修改、数据删除操作时，同时将信息发布到 ActiveMQ 的 topic，其他相关系统则可以对该 topic 进行订阅，近乎实时地获取到数据变更的信息，将信息进行同步。</p><h2 id="数据报表"><a href="#数据报表" class="headerlink" title="数据报表"></a>数据报表</h2><p>计算机生成的报表的主要特点是数据动态化，格式多样化，并且实现报表数据和报表格式的完全分离，用户可以只修改数据，或者只修改格式。<br>数据报表为企业的业务评估与决策判断提供了重要的参考依据，能够进入洞察和反映企业的运营状况，是企业日常运营的一面无法缺少的镜子。</p><h3 id="报表工具-Higncharts"><a href="#报表工具-Higncharts" class="headerlink" title="报表工具 Higncharts"></a>报表工具 Higncharts</h3><p>包含两部分</p><ul><li>Higncharts：为 Web 站点提供直观的、交互式的图表体验。</li><li>Hignstock：方便用 JavaScript 建立股票或者通用的事件轴图表。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>软件架构设计原则与设计模式</title>
    <link href="http://yeonsea.club/2019/10/09/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yeonsea.club/2019/10/09/软件架构设计原则与设计模式/</id>
    <published>2019-10-09T02:23:12.000Z</published>
    <updated>2019-10-09T02:30:43.430Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="软件架构设计原则"><a href="#软件架构设计原则" class="headerlink" title="软件架构设计原则"></a>软件架构设计原则</h1><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>Open-Closed Principle，OCP<br>是指一个软件实体(如类、模块和函数)应该对扩展开放，对修改关闭。</p><h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>Dependence Inversion Principle，DIP<br>是指设计代码结构时，高层模块不应该依赖低层模块，二者都应该依赖其抽象。<br>抽象不应该依赖细节，细节应该依赖抽象。</p><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>Simple Responsibiy Principle，SRP<br>是指不要存在多于一个导致类变更的原因。<br>总体来说，就是一个类、接口或方法只负责一项职责。</p><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>Interface Segregation Principle，ISP<br>是指用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口。</p><h2 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h2><p>Law of Demeter，LoD<br>是指一个对象应该对其他对象保持最少了解，又叫最少知道原则(Least Knowledge Principle，LKP)，尽量降低类与类之间的耦合度。</p><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>Liskov Substitution Principle，LSP<br>是指如果对每一个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有对象 o1 都替换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。</p><h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>Composite/Aggregate Reuse Principle，CARP<br>是指尽量使用对象组合(has-a)/聚合(contanis-a)而不是继承关系达到软件复用的目的。</p><h1 id="Spring-中常用的设计模式"><a href="#Spring-中常用的设计模式" class="headerlink" title="Spring 中常用的设计模式"></a>Spring 中常用的设计模式</h1><p>设计模式作用：</p><ul><li>写出优雅的代码</li><li>更好地重构项目</li></ul><p>经典框架都在用设计模式解决问题：<br>命名对照：</p><ul><li>工厂模式  BeanFactory</li><li>装饰者模式  BeanWrapper</li><li>代理模式  AopProxy</li><li>委派模式  DispatcherServlet</li><li>策略模式  HandlerMapping</li><li>适配器模式  HandlerAdapter</li><li>模板模式  JdbcTemplate</li><li>观察者模式  ContextLoaderListener</li></ul><p><em>设计模式从来都不是单个模式的独立使用。在实际应用中，通常是将多个设计模式混合使用</em></p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>Simple Factory Pattern<br>是指由一个工厂对象决定创建哪一种产品类的实例，但它不属于 GoF 的 23 种设计模式。</p><p>示例：<br>JDK 的 Calendar#getInstance<br>logback 的 LoggerFactory#getLogger</p><p>总结：<br>适用于工厂类负责创建的对象较少的场景；<br>工厂类的职责相对过重，不易于扩展过于复杂的产品结构。</p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>Factory Method Pattern<br>是指定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法模式让类的实例化推迟到子类中进行。<br><em>在工厂方法模式中用户只需要关心所需产品对应的工厂，无需关心创建细节，而且加入新的产品时符合开闭原则。</em></p><p>示例：<br>logback  ILoggerFactory</p><p>工厂方法模式适用一下场景：</p><ul><li>创建对象需要大量重复的代码</li><li>客户端(应用层)不依赖于产品类实例如何被创建、如何被实现等细节。</li><li>一个类通过其子类来指定创建哪个对象</li></ul><p>工厂方法模式的缺点：</p><ul><li>类的个数容易过多，增加复杂度</li><li>增加了系统的抽象性和理解难度</li></ul><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>Abastract Factory Patten<br>是指创建一系列相关或互相依赖对象的接口，无须指定他们的具体类。</p><p>产品族、产品系列</p><p>抽象工厂模式的缺点：</p><ul><li>规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口</li><li>增加了系统的抽象性和理解难度</li></ul><h3 id="利用工厂模式重构的实践案例"><a href="#利用工厂模式重构的实践案例" class="headerlink" title="利用工厂模式重构的实践案例"></a>利用工厂模式重构的实践案例</h3><p>数据库连接池</p><h2 id="单例模式详解"><a href="#单例模式详解" class="headerlink" title="单例模式详解"></a>单例模式详解</h2><h3 id="单例模式的应用场景"><a href="#单例模式的应用场景" class="headerlink" title="单例模式的应用场景"></a>单例模式的应用场景</h3><p>Singleton Pattern<br>是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。</p><p>示例：</p><ul><li>J2EE 标准中的 ServletContext、ServletContextConfig等</li><li>Spring 框架应用中的 ApplicationContext</li><li>数据库的连接池</li></ul><h3 id="饿汉式单例模式"><a href="#饿汉式单例模式" class="headerlink" title="饿汉式单例模式"></a>饿汉式单例模式</h3><p>饿汉式单例模式在类加载的时候就立即初始化，并且创建单例对象。它绝对线程安全，在线程还没出现以前就实例化了，不可能存在访问安全问题。</p><p>优点：<br>没有加任何锁、执行效率比较高，用户体验比懒汉式单例模式更好。<br>缺点：<br>类加载的时候就初始化，不管用与不用都占着空间，浪费了内存。</p><p>Spring IoC 容器 ApplicationContext</p><p>适用于单例对象较少的情况</p><h3 id="懒汉式单例模式"><a href="#懒汉式单例模式" class="headerlink" title="懒汉式单例模式"></a>懒汉式单例模式</h3><p>被外部类调用的时候内部类才会加载。</p><p>双重加锁<br>静态内部类</p><h3 id="反射破坏单例"><a href="#反射破坏单例" class="headerlink" title="反射破坏单例"></a>反射破坏单例</h3><p>静态内部类 构造方法做限制</p><h3 id="序列化破坏单例"><a href="#序列化破坏单例" class="headerlink" title="序列化破坏单例"></a>序列化破坏单例</h3><p>反序列化后的对象会重新分配内存，即重新创建。<br>ObjectInputStream#readObject</p><p><em>通过 JDK 源码分析可以看出，虽然增加 readResolve() 方法返回实例解决了单例模式被破坏的问题，但是实际上实例化了两次，只不过新创建的对象没有被返回而已。</em></p><h3 id="注册式单例模式"><a href="#注册式单例模式" class="headerlink" title="注册式单例模式"></a>注册式单例模式</h3><p>又称为登记式单例模式，就是将每一个实例都登记到某一个地方，使用唯一的标识获取实例。</p><h4 id="枚举式单例模式"><a href="#枚举式单例模式" class="headerlink" title="枚举式单例模式"></a>枚举式单例模式</h4><p>枚举式单例模式在静态代码块中就给 INSTANCE 进行了赋值，是饿汉式单例模式的实现。</p><p>枚举类型其实通过类名和类对象类找到一个唯一的枚举对象。因此，枚举对象不可能被类加载器加载多次。</p><p><em>JDK 枚举的语法特殊性及反射也为枚举保驾护航，让枚举式单例模式成为一种比较优雅的实现</em></p><h4 id="容器式单例"><a href="#容器式单例" class="headerlink" title="容器式单例"></a>容器式单例</h4><p>容器式单例模式适用于实例非常多的情况，便于管理。但它是非线程安全的。</p><p>示例：<br>spring 中容器式单例模式</p><h3 id="线程单例实现-ThreadLocal"><a href="#线程单例实现-ThreadLocal" class="headerlink" title="线程单例实现 ThreadLocal"></a>线程单例实现 ThreadLocal</h3><p>ThreadLocal 不能保证其创建的对象是全局唯一的，但是能保证在单个线程中是唯一的，天生是线程安全的。</p><p><em>ThreadLocal 将所有的对象全部放在 ThreadLocalMap 中，为每个线程都提供一个对象，实际上是以空间换时间来实现线程隔离的。</em></p><h2 id="原型模式详解"><a href="#原型模式详解" class="headerlink" title="原型模式详解"></a>原型模式详解</h2><h3 id="原型模式的应用场景"><a href="#原型模式的应用场景" class="headerlink" title="原型模式的应用场景"></a>原型模式的应用场景</h3><p>Prototype Pattern<br>是指原型实例指定创建对象的种类，并且通过这些原型创建新的对象。</p><p>适用场景：</p><ul><li>类初始化消耗资源较多</li><li>使用 new 生成一个对象需要非常烦琐的过程(数据准备、访问权限等)</li><li>构造函数比较复杂</li><li>在循环体中产生大量对象</li></ul><p>示例：</p><ul><li>spring scope=“prototype”</li><li>JSON.parseObject()</li></ul><h3 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h3><p>浅克隆复制的不是值，而是引用的地址。<br>浅克隆只是完整复制了值类型数据，没有赋值引用对象。换言之，所有的引用对象仍然指向原来的对象。</p><h3 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h3><p>实现 Cloneabl  Serializable 接口</p><h3 id="克隆破坏单例模式"><a href="#克隆破坏单例模式" class="headerlink" title="克隆破坏单例模式"></a>克隆破坏单例模式</h3><p>A: 要么单例类不实现 Cloneable 接口，要么重写 clone() 方法</p><p>实例：<br>ArrayList#clone()</p><h2 id="代理模式详解"><a href="#代理模式详解" class="headerlink" title="代理模式详解"></a>代理模式详解</h2><h3 id="代理模式的应用场景"><a href="#代理模式的应用场景" class="headerlink" title="代理模式的应用场景"></a>代理模式的应用场景</h3><p>Proxy Pattern<br>是指为其他对象提供一种代理，以控制对这个对象的访问。</p><p>目的：</p><ul><li>保护目标对象</li><li>增强目标对象</li></ul><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><h4 id="JDK-实现方式"><a href="#JDK-实现方式" class="headerlink" title="JDK 实现方式"></a>JDK 实现方式</h4><p>JDK 动态代理采用字节重组，重新生成对象来替代原始对象，以达到动态代理的目的。<br>步骤如下：</p><ol><li>获取被代理对象的引用，并且获取它的所有接口，反射获取</li><li>JDK 动态代理类重新生成一个新的类，同时新的类要实现被代理类实现的所有接口</li><li>动态生成 Java 代码，新加的业务逻辑方法由一定的逻辑代码调用(在代码中体现)</li><li>编译新生成的 Java 代码 .class 文件</li><li>重新加载到 JVM 中运行</li></ol><p>以上过程就叫字节码重组。JDK 中有一个规范，在 ClassPath 下只要是 $ 开头的 .class 文件，一般都是自动生成的。</p><h4 id="CGLib-代理调用-API"><a href="#CGLib-代理调用-API" class="headerlink" title="CGLib 代理调用 API"></a>CGLib 代理调用 API</h4><blockquote><p>CGLib 代理执行代理方法的效率之所以比 JDK 的高，是因为 CGlib 采用了 FastClass 机制，它的原理简单来说就是：为代理类和被代理类各生成一个类，这个类会为代理类或被代理类的方法分配一个 index(int 类型)，这个 index 当做一个入参，FastClass 就可以直接定位到要调用的方法并直接进行调用，省去了反射调用，所以调用效率比 JDK 代理通过反射调用高。</p></blockquote><p>FastClass 并不是跟代理类一起生成的，而是在第一次执行 MethodProxy 的 invoke() 或 invokeSuper() 方法时生成的。</p><h4 id="CGLib-和-JDK-动态代理对比"><a href="#CGLib-和-JDK-动态代理对比" class="headerlink" title="CGLib  和 JDK 动态代理对比"></a>CGLib  和 JDK 动态代理对比</h4><ul><li>JDK 动态代理实现了被代理对象的接口，CGLib 代理继承了被代理对象</li><li>JDK 动态代理和 CGLib 代理都在运行期间生成字节码，JDK 动态代理直接写 Class 字节码，CGLib 代理使用 ASM 框架写 Class 字节码，CGlib 代理实现更复杂，生成代理类比 JDK 动态代理效率低。</li><li>JDK 动态代理调用代理方法是通过反射机制调用的，CGLib 代理是通过 FastClass 机制直接调用方法的，CGLib 执行的效率更高。</li></ul><h3 id="代理模式与-Spring"><a href="#代理模式与-Spring" class="headerlink" title="代理模式与 Spring"></a>代理模式与 Spring</h3><h4 id="代理模式在-Spring-源码中的应用"><a href="#代理模式在-Spring-源码中的应用" class="headerlink" title="代理模式在 Spring 源码中的应用"></a>代理模式在 Spring 源码中的应用</h4><p>Spring 利用动态代理实现 AOP 时有两个非常重要的类：JdkDynamicAopProxy 类和 CglibAopProxy 类。</p><p>Spring 中的代理选择原则</p><ol><li>当 Bean 有实现接口时，Spring 就会用 JDK 动态代理</li><li>当 Bean 没有实现接口时，Spring 就会用 CGLib 代理</li><li>Spring 可以通过配置强制使用 CGLib 代理，需加入配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="静态代理和动态代理的本质区别"><a href="#静态代理和动态代理的本质区别" class="headerlink" title="静态代理和动态代理的本质区别"></a>静态代理和动态代理的本质区别</h3><ol><li>静态代理只能通过手动完成代理操作，如果被代理类增加了新的方法，代理类需要同步增加，违背开闭原则。</li><li>动态代理采用在运行时动态生成代码的方式，取消了被代理类的扩展限制，遵循开闭原则。</li><li>若动态代理要对目标类的增强逻辑进行扩展，结合策略模式，只需要新增策略类便可完成，无语修改代理类的代码。</li></ol><h3 id="代理模式的优缺点"><a href="#代理模式的优缺点" class="headerlink" title="代理模式的优缺点"></a>代理模式的优缺点</h3><p>优点：</p><ol><li>代理模式能将代理对象与真实被调用目标对象分离。</li><li>在一定程度上降低了系统的耦合性，扩展性好。</li><li>可以起到保护目标对象的作用。</li><li>可以增强目标对象的功能。</li></ol><p>缺点：</p><ol><li>代理模式会造成系统设计中类的数量增加。</li><li>在客户端和目标对象中增加一个代理对象，会导致请求处理速度变慢。</li><li>增加了系统的复杂度。</li></ol><h2 id="委派模型详解"><a href="#委派模型详解" class="headerlink" title="委派模型详解"></a>委派模型详解</h2><h3 id="委派模型定义及应用场景"><a href="#委派模型定义及应用场景" class="headerlink" title="委派模型定义及应用场景"></a>委派模型定义及应用场景</h3><p>Delegate Pattern<br>不属于 GoF 23 种设计模式<br>基本作用就是负责任务的调用和分配，跟代理模式很像，可以看作一种特殊情况下的静态的全权代理，但是代理模式注重过程，而委派模式注重结果。</p><p>Spring#DispatcherServlet</p><p>示例：以 Delegate 结尾的地方都实现了委派模式</p><ul><li>BeanDefinitionParserDelegate 根据不同类型委派不同的逻辑解析 BeanDefinition</li></ul><h2 id="策略模式详解"><a href="#策略模式详解" class="headerlink" title="策略模式详解"></a>策略模式详解</h2><p>Strategy Patten<br>是指定义了算法家族并分别封装起来，让他们之间可以互相替换，此模式使得算法的变化不会影响使用算法的用户。</p><h3 id="策略模式应用场景"><a href="#策略模式应用场景" class="headerlink" title="策略模式应用场景"></a>策略模式应用场景</h3><ul><li>系统中有很多类，而他们的区别仅仅在于行为不同</li><li>一个系统需要动态地在几种算法中选择一种</li></ul><h3 id="用策略模式实现选择支付方式的业务场景"><a href="#用策略模式实现选择支付方式的业务场景" class="headerlink" title="用策略模式实现选择支付方式的业务场景"></a>用策略模式实现选择支付方式的业务场景</h3><h3 id="策略模式在-JDK-源码中的体现"><a href="#策略模式在-JDK-源码中的体现" class="headerlink" title="策略模式在 JDK 源码中的体现"></a>策略模式在 JDK 源码中的体现</h3><p>Comparator 接口的 compare 方法</p><ul><li>Arrays类的 parallelSort 方法</li><li>TreeMap 类的构造方法</li></ul><p>Spring</p><ul><li>Spring 中 Resource 接口</li><li>Spring 的初始化，InstantiationStrategy</li></ul><h3 id="策略模式的优缺点"><a href="#策略模式的优缺点" class="headerlink" title="策略模式的优缺点"></a>策略模式的优缺点</h3><p>优点</p><ul><li>策略模式符合开闭原则</li><li>策略模式可避免使用多重条件语句，如 if…else 语句、switch 语句</li><li>使用策略模式可以提高算法的保密性和安全性</li></ul><p>缺点</p><ul><li>客户端必须知道所有的策略，并且自行决定使用哪一个策略类</li><li>代码中会产生非常多的策略类，增加了代码的维护难度</li></ul><h3 id="委派模式与策略模式的综合应用"><a href="#委派模式与策略模式的综合应用" class="headerlink" title="委派模式与策略模式的综合应用"></a>委派模式与策略模式的综合应用</h3><p>DispatcherServlet</p><h2 id="模板模式详解"><a href="#模板模式详解" class="headerlink" title="模板模式详解"></a>模板模式详解</h2><p>又叫模板方法模式<br>Template Method Pattern<br>是指定义一个算法的骨架，并允许子类为一个或者多个步骤提供实现。</p><h3 id="模板模式的应用场景"><a href="#模板模式的应用场景" class="headerlink" title="模板模式的应用场景"></a>模板模式的应用场景</h3><ul><li>一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。</li><li>各子类中公共的行为被提取出来并集中到一个公共的父类中，从而避免代码重复。</li></ul><p>设计钩子方法的主要目的是干预执行流程，使得控制行为更加灵活，更符合实际业务的需求。<br>钩子方法的返回值一般为适合条件分支语句的返回值。</p><h3 id="利用模板模式重构-JDBC-操作业务场景"><a href="#利用模板模式重构-JDBC-操作业务场景" class="headerlink" title="利用模板模式重构 JDBC 操作业务场景"></a>利用模板模式重构 JDBC 操作业务场景</h3><p>JdbcTemplate</p><h3 id="模板模式在源码中的体现"><a href="#模板模式在源码中的体现" class="headerlink" title="模板模式在源码中的体现"></a>模板模式在源码中的体现</h3><ul><li>AbstractList</li><li>AbstractSet</li><li>AbstractMap</li><li>HttpServlet 的 service doGet doPost</li><li>Mybatis 框架中的 BaseExecutor 类</li></ul><h3 id="模板模式的优缺点"><a href="#模板模式的优缺点" class="headerlink" title="模板模式的优缺点"></a>模板模式的优缺点</h3><p>优点</p><ul><li>利用模板模式将相同处理逻辑的代码放到抽象父类中，可以提高代码的复用性。</li><li>将不同的代码放到不同的子类中，通过对子类的扩展增加新的行为，可以提高代码的扩展性。</li><li>把不变的行为写在父类中，去除子类的重复代码，提供了一个很好的代码复用平台，符合开闭原则。</li></ul><p>缺点</p><ul><li>每个抽象类都需要一个子类来实现，导致了类的数量增加。</li><li>类数量的增加间接地增加了系统的复杂性。</li><li>因为继承关系自身的缺点，如果父类添加新的抽象方法，所有子类都要改一遍。</li></ul><h2 id="适配器模式详解"><a href="#适配器模式详解" class="headerlink" title="适配器模式详解"></a>适配器模式详解</h2><p>Adapter Patten<br>是指将一个类的接口转换成用户期望的另一个接口，使原本接口不兼容的类可以一起工作，属于结构型设计模式。</p><h3 id="适配器模式的应用场景"><a href="#适配器模式的应用场景" class="headerlink" title="适配器模式的应用场景"></a>适配器模式的应用场景</h3><ul><li>已经存在的类的方法和需求不匹配(方法结果相同或相似)的情况。</li><li>适配器模式不是软件初始阶段考虑的设计模式，是随着软件的发展，由于不同产品、不同厂家造成功能类似而接口不同的问题的解决方案，有点亡羊补牢的感觉。</li></ul><h3 id="重构第三方登录自由适配的业务场景"><a href="#重构第三方登录自由适配的业务场景" class="headerlink" title="重构第三方登录自由适配的业务场景"></a>重构第三方登录自由适配的业务场景</h3><h3 id="适配器模式在源码中的体现"><a href="#适配器模式在源码中的体现" class="headerlink" title="适配器模式在源码中的体现"></a>适配器模式在源码中的体现</h3><p>Spring AOP 中的 AdvisorAdapter 类有三个实现类：</p><ul><li>MethodBeforeAdviceAdapter</li><li>AfterReturningAdviceAdapter</li><li>ThrowsAdviceAdapter</li></ul><p>Spring MVC 中的 HandlerAdapter 类，调用的关键代码在 DispatcherServlet#doDispatch</p><h3 id="适配器模式的优缺点"><a href="#适配器模式的优缺点" class="headerlink" title="适配器模式的优缺点"></a>适配器模式的优缺点</h3><p>优点：</p><ul><li>能提高类的透明性和复用性，现有的类会被复用但不需要改变</li><li>目标类和适配器类解耦，可以提高程序的扩展性</li><li>在很多业务场景中符合开闭原则</li></ul><p>缺点：</p><ul><li>在适配器代码编写过程中需要进行全面考虑，可能会增加系统的复杂性</li><li>增加了代码的阅读难度，降低了代码的可读性，过多使用适配器会使系统的代码变得凌乱</li></ul><h2 id="装饰者模式详解"><a href="#装饰者模式详解" class="headerlink" title="装饰者模式详解"></a>装饰者模式详解</h2><p>Decorator Paftern<br>是指在不改变原有对象的基础上，将功能附加到对象上，提供了比继承更有弹性的方案(扩展原有对象的功能)，属于结构型模式。</p><h3 id="装饰者模式的应用场景"><a href="#装饰者模式的应用场景" class="headerlink" title="装饰者模式的应用场景"></a>装饰者模式的应用场景</h3><ul><li>扩展一个类的功能或给一个类添加附加职责</li><li>动态给一个对象添加功能，这些功能可以再动态地撤销</li></ul><p><em>装饰者模式最本质的特征是将原有类的附加功能抽离出来，简化原有类的逻辑。</em><br>抽象的装饰者是可有可无的，具体可以根据业务模型来选择。</p><h3 id="装饰者模式和适配器模式对比"><a href="#装饰者模式和适配器模式对比" class="headerlink" title="装饰者模式和适配器模式对比"></a>装饰者模式和适配器模式对比</h3><p>装饰者模式和适配器模式都是包装模式(Wrapper Pattern)，装饰者模式也是一种特殊的代理模式。</p><h3 id="装饰者模式在源码中的应用"><a href="#装饰者模式在源码中的应用" class="headerlink" title="装饰者模式在源码中的应用"></a>装饰者模式在源码中的应用</h3><ul><li>在 JDK 中体现最明显的类就是 IO 相关的类</li><li>Spring 中的 TransactionAwareCacheDecorator 类，这个类主要用来处理事务缓存，是对 Cache 的一个包装。</li><li>MyBatis 的 org.apache.ibatis.cache.Cache 类，比如 FifoCache 是先入先出算法的缓存，LruCache 是最近很少使用的缓存，TransactionalCache 是事务相关的缓存。</li></ul><h3 id="装饰者模式的优缺点"><a href="#装饰者模式的优缺点" class="headerlink" title="装饰者模式的优缺点"></a>装饰者模式的优缺点</h3><p>优点：</p><ul><li>装饰者模式是继承的有力补充，且比继承灵活，可以在不改变原有对象的情况下动态地给一个对象扩展功能，即插即用。</li><li>使用不同的装饰类及这些装饰类的排列组合，可以实现不同的效果。</li><li>装饰者模式完全符合开闭原则。</li></ul><p>缺点：</p><ul><li>会出现更多的代码、更多的类，增加程序的复杂性。</li><li>动态装饰时，多层装饰会更加复杂。</li></ul><h2 id="观察者模式详解"><a href="#观察者模式详解" class="headerlink" title="观察者模式详解"></a>观察者模式详解</h2><p>Observe Patten<br>定义了对象之间的一对多依赖，让多个观察者对象同时监听一个主体对象，当主体对象发生变化时，它的所有依赖者(观察者)都会收到通知并更新，属于行为型模式。</p><h3 id="观察者模式的应用场景"><a href="#观察者模式的应用场景" class="headerlink" title="观察者模式的应用场景"></a>观察者模式的应用场景</h3><p>主要用于在关联行为之间建立一套触发机制的场景。</p><h3 id="观察者模式在源码中的应用"><a href="#观察者模式在源码中的应用" class="headerlink" title="观察者模式在源码中的应用"></a>观察者模式在源码中的应用</h3><p>Spring 中的 ContextLoaderListener 类实现了 ServletContextListener 接口，ServletContextListener 接口又继承了 EventListener 接口</p><h3 id="基于-Guava-API-轻松落地观察者模式"><a href="#基于-Guava-API-轻松落地观察者模式" class="headerlink" title="基于 Guava API 轻松落地观察者模式"></a>基于 Guava API 轻松落地观察者模式</h3><h3 id="观察者模式的优缺点"><a href="#观察者模式的优缺点" class="headerlink" title="观察者模式的优缺点"></a>观察者模式的优缺点</h3><p>优点：</p><ul><li>在观察者和被观察者之间建立了一个抽象的耦合</li><li>观察者模式支持广播通信</li></ul><p>缺点：</p><ul><li>观察者之间有过多的细节依赖、时间消耗多，程序的复杂性更高</li><li>使用不当会出现循环调用</li></ul><h2 id="各种设计模式的总结与对比"><a href="#各种设计模式的总结与对比" class="headerlink" title="各种设计模式的总结与对比"></a>各种设计模式的总结与对比</h2><p><em>设计模式其实是一门艺术。设计模式来源于生活，不要为了套用设计模式而使用设计模式。</em></p><p>设计模式是经验之谈，总结的是前人的经验，提供给后人借鉴使用。</p><p>设计模式可以帮助我们提升代码的可读性、可扩展性，降低维护成本，解决复杂的业务问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://yeonsea.club/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>面向服务的体系架构</title>
    <link href="http://yeonsea.club/2019/09/24/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/"/>
    <id>http://yeonsea.club/2019/09/24/面向服务的体系架构/</id>
    <published>2019-09-24T08:02:37.000Z</published>
    <updated>2019-10-08T05:58:29.142Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>垂直应用架构解决了单一应用架构所面临的扩容问题，流量能够分散到各个子系统当中，且系统的体积可控，一定程度上降低了开发人员之间协同和维护的成本，提升了开发效率。</p></blockquote><p>但是，当垂直应用越来越多，达到一定规模时，应用之间相互交互、相互调用便不可避免。否则，不同系统之间存在着重叠的业务，容易形成信息孤岛，重复造轮子。此时，相对核心的业务将会被抽取出来，作为单独的系统对外提供服务，达成业务之间相互复用，系统也由此演变为分布式应用架构体系。</p><p>分布式应用架构所面临的首要问题，便是如何实现应用之间的远程调用（RPC）。基于 HTTP 协议的系统间的 RPC，具有使用灵活、实现便捷（多种开源的 Web 服务器支持）、开放（国际标准）且天生支持异构平台之间的调用等多个优点，得到了广泛的使用。<br>与之对应的是基于 TCP 协议实现的版本，它效率更高，但实现起来更加复杂，且由于协议和标准的不同，难以进行跨平台和企业间的便捷通信。<br>当服务越来越多时，使得原本基于 F5、LVS 等负载均衡策略、服务地址管理和配置变得相当复杂和繁琐，单点的压力也变得越来越大。服务的动态注册和路由、更加高效的负载均衡的实现，成为了亟待解决的问题。</p><h2 id="基于-TCP-协议的-RPC"><a href="#基于-TCP-协议的-RPC" class="headerlink" title="基于 TCP 协议的 RPC"></a>基于 TCP 协议的 RPC</h2><h3 id="RPC-名称解释"><a href="#RPC-名称解释" class="headerlink" title="RPC 名称解释"></a>RPC 名称解释</h3><p>Remote Process Call，即远程过程调用，拥有 RMI、WebService 等诸多成熟的方案。</p><h3 id="对象的序列化"><a href="#对象的序列化" class="headerlink" title="对象的序列化"></a>对象的序列化</h3><p>无论何种类型的数据，最终都需要转换成二进制流在网络上进行传输，在面向对象的设计中，数据的发送方需要将对象转换成为二进制流，才能在网络上进行传输，而数据的接收方则需要把二进制流再恢复为对象。</p><ul><li>将对象转换为二进制流的过程称为对象的序列化。</li><li>将二进制流恢复为对象的过程称为对象的反序列化。</li></ul><p>常用的解决方案：</p><ul><li>Google 的 Protocol Buffers    性能优异，跨平台，但编程代码侵入性较强，需要编写 proto 文件</li><li>Java 本身内置的序列化方式</li><li>Hessian</li><li>JSON</li><li>XML</li></ul><p>Java 内置的序列化方式所实现的对象序列化和反序列化关键代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个字节数组输出流</span></span><br><span class="line">ByteArrayOutputStream os = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"><span class="comment">// 对象输出流</span></span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(os);</span><br><span class="line"><span class="comment">// 将对象写入到字节数组输出，进行序列化</span></span><br><span class="line">out.writeObject(yeon);</span><br><span class="line"><span class="keyword">byte</span>[] yeonByte = os.toByteArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字节数组输入流</span></span><br><span class="line">ByteArrayInputStream is = <span class="keyword">new</span> ByteArrayInputStream(yeonByte);</span><br><span class="line"><span class="comment">// 执行反序列化，从流中读取对象</span></span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(is);</span><br><span class="line">Person person = (Person) in.readObject();</span><br></pre></td></tr></table></figure></p><p>使用 Hessian 进行序列化，需要引入其提供的 hessian-4.0.7.jar<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayOutputStream os = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"><span class="comment">// Hessian 的序列化输出</span></span><br><span class="line">HessianOutput ho = <span class="keyword">new</span> HessianOutput(os);ni</span><br><span class="line">ho.writeObject(yeon);</span><br><span class="line"><span class="keyword">byte</span>[] yeonByte = os.toByteArray();</span><br><span class="line"></span><br><span class="line">ByteArrayOutputStream os = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"><span class="comment">// Hessian 的反序列化读取对象</span></span><br><span class="line">HessianInput hi = <span class="keyword">new</span> HessianInput(os);</span><br><span class="line">Person person = (Person) hi.readObject();</span><br></pre></td></tr></table></figure></p><h3 id="基于-TCP-协议实现-RPC"><a href="#基于-TCP-协议实现-RPC" class="headerlink" title="基于 TCP 协议实现 RPC"></a>基于 TCP 协议实现 RPC</h3><p>基于 Java 的 Socket API，能够实现一个简单 RPC 调用，包括了服务的接口及接口的远端实现、服务的消费者与远端的提供方。<br>服务接口和实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SayHelloService</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 问候的接口</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> helloArg 参数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String helloArg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SayHelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">SayHelloService</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String helloArg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (helloArg.equals(<span class="string">"hello"</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span>  <span class="string">"hello"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"bye bye"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务消费者 Consumer 类的部分关键代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口名称</span></span><br><span class="line">String interfacename = SayHelloService.class.getName();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要远程执行的方法</span></span><br><span class="line">Method method = SayHelloService.class.getMethod(<span class="string">"sayHello"</span>, java.lang.String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要传递到远端的参数</span></span><br><span class="line">Object[] arguments = &#123;<span class="string">"hello"</span>&#125;;</span><br><span class="line"></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">1234</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将方法名和参数传递到远端</span></span><br><span class="line">ObjectOutputStream output = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream);</span><br><span class="line">output.writeUTF(interfacename);<span class="comment">// 接口名称</span></span><br><span class="line">output.writeUTF(method.getName());<span class="comment">// 方法名称</span></span><br><span class="line">output.writeObject(method.getParameterTypes());</span><br><span class="line">output.writeObject(arguments);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从远端读取方法执行结果</span></span><br><span class="line">ObjectInputStream input = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">Object result = input.readObject();</span><br></pre></td></tr></table></figure></p><p>此处为阻塞IO，实际中应使用非阻塞IO，以提供更大的吞吐量</p><p>服务提供者 Provider 类的部分关键代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">1234</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">Socket socket = server.accept();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取服务信息</span></span><br><span class="line">ObjectInputStream input = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">String interfacename = input.readUTF(); <span class="comment">// 接口名称</span></span><br><span class="line">String methodName = input.readUTF();<span class="comment">// 方法名称</span></span><br><span class="line">Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[]) input.readObject();<span class="comment">// 参数类型</span></span><br><span class="line">Object[] arguments = (Object[]) input.readObject();<span class="comment">// 参数对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行调用</span></span><br><span class="line">Class serviceinterfaceclass = Class.forName(interfacename);<span class="comment">// 得到接口的 Class</span></span><br><span class="line">Object service = services.get(interfacename);<span class="comment">// 取得服务实现的对象</span></span><br><span class="line">Method method = serviceinterfaceclass.getMethod(methodName, parameterTypes);<span class="comment">// 获得要调用的方法</span></span><br><span class="line">Object result = method.invoke(service, arguments);</span><br><span class="line"></span><br><span class="line">ObjectOutputStream output = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">output.writeObject(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务提供端事先将服务实例化好后放在 services 这个 Map (涉及服务的路由被简化处理了)，通过一个 while 循环，不断地接收新到来的请求，得到所需要的参数，包括接口名称、方法名称、参数类型和参数，通过 Java 的反射取得接口中需要调用的方法，执行后将结果返回给服务的消费者。</p><h2 id="基于-HTTP-协议的-RPC"><a href="#基于-HTTP-协议的-RPC" class="headerlink" title="基于 HTTP 协议的 RPC"></a>基于 HTTP 协议的 RPC</h2><h3 id="HTTP-协议栈"><a href="#HTTP-协议栈" class="headerlink" title="HTTP 协议栈"></a>HTTP 协议栈</h3><p>HTTP 协议属于应用层协议，它不需要处理下层协议间诸如丢包补发、握手及数据的分段和重新组装等繁琐的细节，从而使开发人员可以专注于上层应用的设计。</p><p>基于 Java 的 Socket API 接口，设计一个简单的应用层通信协议：<br>协议请求的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 协议编码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span> encode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 命令</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Sting command;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 命令长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> commandLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>协议响应的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 编码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span> encode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 响应</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Sting response;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 响应长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> responseLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求</span></span><br><span class="line">Request request = <span class="keyword">new</span> Request();</span><br><span class="line">request.setCommand(<span class="string">"HELLO"</span>);</span><br><span class="line">request.setCommandLength(request.getCommand().length());</span><br><span class="line">request.setEncode(Encode.UTF8.getValue());</span><br><span class="line"></span><br><span class="line">Scoket client = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">4567</span>);</span><br><span class="line">OutputStream output = client.getOutputStream();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line">ProtocolUtil.writeRequest(output, request);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取响应数据</span></span><br><span class="line">InputStream input = client.getInputStream();</span><br><span class="line">Response response = ProtocolUtil.readResponse(input);</span><br></pre></td></tr></table></figure></p><p>服务端实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">4567</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">Socket client = server.accept();</span><br><span class="line"><span class="comment">// 读取响应数据</span></span><br><span class="line">InputStream input = client.getInputStream();</span><br><span class="line">Request request = ProtocolUtil.readRequest(input);</span><br><span class="line"></span><br><span class="line">OutputStream output = client.getOutputStream();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组装响应</span></span><br><span class="line">Response response = <span class="keyword">new</span> Response();</span><br><span class="line">response.setEncode(Encode.UTF8.getValue());</span><br><span class="line"><span class="keyword">if</span> (request.getCommand().equals(<span class="string">"HELLO"</span>)) &#123;</span><br><span class="line">response.setResponse(<span class="string">"hello!"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">response.setResponse(<span class="string">"bye bye!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">response.setResponseLength(response.getResponse().lenth());</span><br><span class="line"></span><br><span class="line">ProtocolUtil.writeResponse(output, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ProtocolUtil 的部分代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolUtil</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Request <span class="title">readRequest</span><span class="params">(InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 读取编码</span></span><br><span class="line"><span class="keyword">byte</span>[] encodeByte = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span>];</span><br><span class="line">input.read(encodeByte);</span><br><span class="line"><span class="keyword">byte</span> encode = encodeByte[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取命令长度</span></span><br><span class="line"><span class="keyword">byte</span>[] commandLengthBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">input.read(commandLengthBytes);</span><br><span class="line"><span class="keyword">int</span> commandLength = ByteUtil.bytes2Int(commandLengthBytes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取命令</span></span><br><span class="line"><span class="keyword">byte</span>[] commandBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[commandLength];</span><br><span class="line">input.read(commandBytes);</span><br><span class="line">String command = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">if</span> (Encode.GBK.getValue() == encode) &#123;</span><br><span class="line">command = <span class="keyword">new</span> String(commandBytes, <span class="string">"GBK"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">command = <span class="keyword">new</span> String(commandBytes, <span class="string">"UTF8"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组装请求返回</span></span><br><span class="line">Request request = <span class="keyword">new</span> Request();</span><br><span class="line">request.setCommand(command);</span><br><span class="line">request.setEncode(encode);</span><br><span class="line">request.setCommandLength(commandLength);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeResponse</span><span class="params">(OutputStream output, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 将 response 响应返回给客户端</span></span><br><span class="line">output.write(response.getEncode());</span><br><span class="line"><span class="comment">// output.write(response.getResponseLength());// 直接 write 一个 int 类型会截取低 8 位传输，丢弃高 24 位</span></span><br><span class="line">output.write(ByteUtil.int2ByteArray(response.getResponseLength()));</span><br><span class="line"><span class="keyword">if</span> (Encode.GBK.getValue() == response.getEncode()) &#123;</span><br><span class="line">output.write(response.getResponse.getBytes(<span class="string">"GBK"</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">output.write(response.getResponse.getBytes(<span class="string">"UTF8"</span>));</span><br><span class="line">&#125;</span><br><span class="line">out.flush();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Big Endian 字节序转换：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">byte2Int</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = bytes[<span class="number">3</span>] &amp; <span class="number">0xFF</span>;</span><br><span class="line">num |= ((bytes[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) &amp; <span class="number">0xFF00</span>);</span><br><span class="line">num |= ((bytes[<span class="number">1</span>] &lt;&lt; <span class="number">16</span>) &amp; <span class="number">0xFF0000</span>);</span><br><span class="line">num |= ((bytes[<span class="number">0</span>] &lt;&lt; <span class="number">24</span>) &amp; <span class="number">0xFF000000</span>);</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] int2ByteArray(<span class="keyword">int</span> i) &#123;</span><br><span class="line"><span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">result[<span class="number">0</span>] = (<span class="keyword">byte</span>)((i &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">result[<span class="number">1</span>] = (<span class="keyword">byte</span>)((i &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">result[<span class="number">2</span>] = (<span class="keyword">byte</span>)((i &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">result[<span class="number">3</span>] = (<span class="keyword">byte</span>)(i &amp; <span class="number">0xFF</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="HTTP-请求与响应"><a href="#HTTP-请求与响应" class="headerlink" title="HTTP 请求与响应"></a>HTTP 请求与响应</h3><ol><li>首先，用户在浏览器地址栏输入 <a href="http://www.google.com/index.html" target="_blank" rel="noopener">http://www.google.com/index.html</a> 如果不指定端口，浏览器会默认为 80 端口。</li><li>操作系统通过查找 DNS 服务器进行域名解析，得到 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 对应的 IP 地址（74.125.31.147）。</li><li>浏览器发起并建立到 IP 地址的服务器 80 端口的连接，并向其发送 HTTP GET 请求。</li><li>服务端收到客户端发送的 HTTP GET 请求后，会响应一段 HTML 代码。浏览器根据接收到的 HTML 代码，下载相应的资源并进行网页的渲染。</li></ol><h3 id="通过-HTTPClient-发送-HTTP-请求"><a href="#通过-HTTPClient-发送-HTTP-请求" class="headerlink" title="通过 HTTPClient 发送 HTTP 请求"></a>通过 HTTPClient 发送 HTTP 请求</h3><blockquote><p>随着 HTTP 协议的广泛使用，它已经不仅仅局限于原来的 B/S 模式。很多情况下，我们需要自己实现向服务端发送请求，以及解析服务器响应这个过程。但是，像之前一样通过 Socket API 来实现这一切，会带来相当大的工作量，并且这种工作是重复且没有价值的，还有可能导致一些不可预估的风险，比如底层的流处理、并发控制等。HttpClient 的出现，为这一系列问题提供了一个成熟的解决方案。</p></blockquote><p>HTTPClient 是 Apache 下的一个子项目，它对 HTTP 协议通信的过程进行了封装，提供高效且功能丰富的客户端编程工具包。<br>示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// url 前面请加上 HTTP 协议头，标名该请求为 HTTP 请求</span></span><br><span class="line">String url = <span class="string">"http://www.google.com"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组装请求</span></span><br><span class="line">HttpClient httpClient = <span class="keyword">new</span> DefaultHttpClient();</span><br><span class="line">HttpGet httpGet = <span class="keyword">new</span> HttpGet(url);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收响应</span></span><br><span class="line">HttpResponse response = httpClient.execute(httpGet);</span><br><span class="line"></span><br><span class="line">HttpEntity entity = response.getEntity();</span><br><span class="line"><span class="keyword">byte</span>[] bytes = EntityUtils.toByteArray(entity);</span><br><span class="line">String result = <span class="keyword">new</span> String(bytes, <span class="string">"utf8"</span>);</span><br></pre></td></tr></table></figure></p><h3 id="使用-HTTP-协议的优势"><a href="#使用-HTTP-协议的优势" class="headerlink" title="使用 HTTP 协议的优势"></a>使用 HTTP 协议的优势</h3><ul><li>跨平台</li><li>不用关注底层</li></ul><h3 id="JSON-和-XML"><a href="#JSON-和-XML" class="headerlink" title="JSON 和 XML"></a>JSON 和 XML</h3><p>将 Java 对象 person 序列化成为 JSON 对象：<br>使用 jackson-all-1.7.6.jar 工具包<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.setAddress(<span class="string">"shanghai, China"</span>);</span><br><span class="line">person.setAge(<span class="number">18</span>);</span><br><span class="line">person.setBirth(<span class="keyword">new</span> Date());</span><br><span class="line">person.setName(<span class="string">"yeon"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON 对象序列化</span></span><br><span class="line">String personJson = <span class="keyword">null</span>;</span><br><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">StringWriter sw = <span class="keyword">new</span> StringWriter();</span><br><span class="line">JsonGenerator gen = <span class="keyword">new</span> JsonFactory().createJsonGenerator(sw);</span><br><span class="line">mapper.writeValue(gen, person);</span><br><span class="line">gen.close();</span><br><span class="line">personJson = sw.toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON 对象反序列化</span></span><br><span class="line">Person yeon = (Person) mapper.readValue(personJson, Person.class);</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">将 Java 对象序列化成 XML 格式：</span><br><span class="line">使用 xstream-<span class="number">1.4</span>.4.jar 工具包</span><br><span class="line">```java</span><br><span class="line"><span class="comment">// 将 Person 对象序列化为 XML</span></span><br><span class="line">XStream xStream = <span class="keyword">new</span> xStream(<span class="keyword">new</span> DomDriver());</span><br><span class="line"><span class="comment">// 设置 Person 类的别名</span></span><br><span class="line">xStream.alias(<span class="string">"person"</span>, Person.class);</span><br><span class="line">String personXML = xStream.toXML(person);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 XML 反序列化还原为 persion 对象</span></span><br><span class="line">Person yeon = (Person) xStream.fromXML(personXML);</span><br></pre></td></tr></table></figure></p><h3 id="RESTful-和-RPC"><a href="#RESTful-和-RPC" class="headerlink" title="RESTful 和 RPC"></a>RESTful 和 RPC</h3><p>SpringMVC 来实现 RESTful 风格的 URL：</p><blockquote><p>相对来说，RPC 风格的 URL 更接近于传统的设计模式，更容易被开发者所接受和理解，同时也更方便传统应用的接入和使用。而 RESTful 风格的本意是用 HTTP 协议所定义的几种操作方式来代替 RPC 中通过参数传输的操作类型，URL 看起来更加简洁，抽象程度更高，对业务扩展和复用有利，但是理解和实现起来更加复杂，适合简单的数据类服务，而非复杂的非资源操作类服务。</p></blockquote><h3 id="基于-HTTP-协议的-RPC-实现"><a href="#基于-HTTP-协议的-RPC-实现" class="headerlink" title="基于 HTTP 协议的 RPC 实现"></a>基于 HTTP 协议的 RPC 实现</h3><h2 id="服务路由和负载均衡"><a href="#服务路由和负载均衡" class="headerlink" title="服务路由和负载均衡"></a>服务路由和负载均衡</h2><h3 id="服务化的演变"><a href="#服务化的演变" class="headerlink" title="服务化的演变"></a>服务化的演变</h3><blockquote><p>分布式应用架构体系对于业务逻辑复用的需求十分强烈，上层业务都想借用已有的底层服务，来快速搭建更多、更丰富的应用，降低新业务开展的人力和时间成本，快速满足瞬息万变的市场需求。公共的业务被拆分出来，形成可共用的服务，最大程度地保障了代码和逻辑的复用，避免重复建设，这种设计也称为 SOA（Service-Oriented Architecture）。</p></blockquote><p>SOA 架构中，服务消费者通过服务名称，在众多服务中找到要调用的服务的地址列表，称为服务的路由。</p><p>对于负载较高的服务来说，往往对应着由多台服务器组成的集群。在请求到来时，为了将请求均衡地分配到后端服务器，负载均衡程序将从服务对应的地址列表中，通过相应的负载均衡算法和规则，选取一台服务器进行访问，这个过程称为服务的负载均衡。</p><h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><h4 id="轮询法"><a href="#轮询法" class="headerlink" title="轮询法"></a>轮询法</h4><p>Round Robin</p><p>为了避免可能出现的并发问题，如数组越界，通过新建方法内的局部变量 serverMap，先将域变量复制到线程本地，避免被多个线程修改。<br>但在这一轮选择服务器的过程中，新增服务器或者下线服务器，负载均衡算法中将无法获知。</p><p>对于当前轮询的位置变量 pos，为了保证服务器选择的顺序性，需要在操作时对其加上 synchronized 锁，使得在同一时刻只有一个线程能够修改 pos 的值，否则当 pos 变量被并发修改，则无法保证服务器选择的顺序性，甚至可能导致 keyList 数组越界。</p><p>使用轮询策略的目的在于，希望做到请求转移的绝对平衡，但付出的性能代价也是相当大的。为了 pos 保证变量修改的互斥性，需要引入重量级的悲观锁 synchronized，将会导致该段轮询代码的并发吞吐量发生明显的下降。</p><h4 id="随机法"><a href="#随机法" class="headerlink" title="随机法"></a>随机法</h4><p>Random</p><h4 id="源地址哈希法"><a href="#源地址哈希法" class="headerlink" title="源地址哈希法"></a>源地址哈希法</h4><p>源地址哈希法的思想是获取客户端访问的IP地址值，通过哈希函数计算的到一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是要访问的服务器序号。<br>采用 哈希法 进行负载均衡，同一 IP 地址的客户端，当后端服务器列表不变时，它每次都会被映射到同一台后端服务器进行访问。</p><h4 id="加权轮询法"><a href="#加权轮询法" class="headerlink" title="加权轮询法"></a>加权轮询法</h4><p>Weight Round Robin<br>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此他们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请求，而低配置、负载高的机器，则给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</p><h4 id="加权随机法"><a href="#加权随机法" class="headerlink" title="加权随机法"></a>加权随机法</h4><p>Weight Random</p><h4 id="最小连接数法"><a href="#最小连接数法" class="headerlink" title="最小连接数法"></a>最小连接数法</h4><p>Least Connections</p><h3 id="动态配置规则"><a href="#动态配置规则" class="headerlink" title="动态配置规则"></a>动态配置规则</h3><p>固定的策略有些时候还是无力满足千变万化的需求，对于开发者来说，一方面需要支持特定用户的独特需求，另一方面又得尽可能的复用代码，避免重复开发，导致维护成本增加，这边需要将这部分特殊的需求剥离出来，采用动态配置的方式来实现。<br>Groovy 脚本：<br>规则动态加载与执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GroovyClassLoader groovyClassLoader = <span class="keyword">new</span> GroovyClassLoader(Thread.currentThread().getContextClassLoader());c</span><br><span class="line">Class&lt;?&gt; groovyClass = groovyClassLoader.parseClass(sourceCode);</span><br><span class="line">GroovyObject groovyObject = (GroovyObject) groovyClass.newInstance();</span><br><span class="line">String server = (String) groovyObject.invokeMethod(<span class="string">"execute"</span>, serverWeightMap);</span><br></pre></td></tr></table></figure></p><p>Groovy 实现的随机算法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicRule</span> </span>&#123;</span><br><span class="line"><span class="function">def <span class="title">execute</span><span class="params">(serverListMap)</span> </span>&#123;</span><br><span class="line">def serverMap = [:];</span><br><span class="line">serverMap.putAll(serverListMap);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得 IP 地址 list</span></span><br><span class="line">def keySet = serverMap.keySet();</span><br><span class="line">def keyList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">keyList.addAll(keySet);</span><br><span class="line"></span><br><span class="line">def random = <span class="keyword">new</span> Random();</span><br><span class="line">def randomPos = random.nextInt(keyList.size());</span><br><span class="line"></span><br><span class="line">String server = keyList.get(randomPos);</span><br><span class="line"><span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Zookeeper-与-环境搭建"><a href="#Zookeeper-与-环境搭建" class="headerlink" title="Zookeeper 与 环境搭建"></a>Zookeeper 与 环境搭建</h3><p>Zookeeper 是 Hadoop 下的一个子项目，它是一个针对大型分布式系统的可靠的协调系统，提供的功能包括配置维护、名字服务、分布式同步、组服务等。</p><p>ZK 是可以集群复制的，集群间通过 Zab (Zookeeper Atomic Broadcas) 协议来保持数据的一致性。该协议看起来像是 Paxos 协议的某种变形，该协议包括两个阶段：leader election 阶段和 Atomic broadcas 阶段。</p><p>集群中将选举出一个 leader，其他的机器则称为 follower，所有的写操作都传给 leader，并通过 broadcas 将所有的更新告诉 follower。当 leader 崩溃或者 leader 失去大多数的 follower 时，需要重新选举出一个新的 leader，让所有服务器都恢复到一个正确的状态。当 leader 被选举出来，且大多数服务器完成了和 leader 的状态同步后，leader election 的过程就结束了，将进入 Atomic broadcas 的过程。<br>Atomic broadcas 同步 leader 和 follower 之间的信息，保证 leader 和 follower 具有相同的系统状态。</p><h3 id="Zookeeper-API-使用"><a href="#Zookeeper-API-使用" class="headerlink" title="Zookeeper API 使用"></a>Zookeeper API 使用</h3><blockquote><p>Zookeeper 实现了一个层次命名空间的数据模型，也可以认为它就是一个小型的、精简的文件系统。它的每个节点称为 znode，znode 除了本身能够包含一部分数据之外，还能够拥有子节点，当节点上的数据发生变化，或者其子节点发生变化时，基于 watcher 机制，会发出相应的通知给订阅状态变化的客户端。</p></blockquote><h4 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h4><p>创建节点示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Zookeeper zookeeper = <span class="keyword">new</span> Zookeeper(url, sessionTimeOut, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 创建 /root 节点，其包含的数据为“root data”，访问权限开放，所有人均可以访问，创建模式为持久化节点</span></span><br><span class="line">zookeeper.create(<span class="string">"/root"</span>, <span class="string">"root data"</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br></pre></td></tr></table></figure></p><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>删除时需要指定节点的版本号 version，如果设置为 -1，则匹配所有版本，Zookeeper 会比较删除的节点版本是否和服务器上的版本一致，如果不一致则抛出异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zookeeper.delete(<span class="string">"/root"</span>, -<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><h4 id="设置和获取节点内容"><a href="#设置和获取节点内容" class="headerlink" title="设置和获取节点内容"></a>设置和获取节点内容</h4><p>一个 znode 中最多能够保存 1MB 的数据<br>设置和获取节点内容的示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 /root 节点的数据，版本号为-1，如果匹配不到响应的节点，会抛出异常</span></span><br><span class="line">zooKeeper.setData(<span class="string">"/root"</span>, <span class="string">"hello"</span>.getBytes(), -<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 取得 /root 节点的数据，并返回其 stat</span></span><br><span class="line">Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line"><span class="keyword">byte</span>[] data = zooKeeper.getData(<span class="string">"/root"</span>, <span class="keyword">false</span>, stat);</span><br></pre></td></tr></table></figure></p><h4 id="添加子节点"><a href="#添加子节点" class="headerlink" title="添加子节点"></a>添加子节点</h4><p>Zookeeper 支持在已有的节点下添加子节点，同样也是使用 create 方法，但是父节点必须存在，否则会抛出异常。<br>创建子节点的示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zookeeper.create(<span class="string">"/root"</span>, <span class="string">"root data"</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">zookeeper.create(<span class="string">"/root/child"</span>, <span class="string">"child data"</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br></pre></td></tr></table></figure></p><h4 id="判断节点是否存在"><a href="#判断节点是否存在" class="headerlink" title="判断节点是否存在"></a>判断节点是否存在</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stat stat = zooKeeper.exists(<span class="string">"/root/child1"</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (stat == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"节点不存在"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"节点存在"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="watcher-的实现"><a href="#watcher-的实现" class="headerlink" title="watcher 的实现"></a>watcher 的实现</h4><p>当节点的状态发生变化，通过 watcher 机制，可以让客户端得到通知，watcher 需要实现 org.apache.ZooKeeper.Watcher 接口。<br>watcher 实现示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (event.getType() == EventType.NodeDeleted) &#123;</span><br><span class="line">System.out.println(<span class="string">"node delete"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (event.getType() == EventType.NodeChildrenChanged) &#123;</span><br><span class="line">System.out.println(<span class="string">"node NodeChildrenChanged"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (event.getType() == EventType.NodeCreated) &#123;</span><br><span class="line">System.out.println(<span class="string">"node NodeCreated"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (event.getType() == EventType.NodeDataChanged) &#123;</span><br><span class="line">System.out.println(<span class="string">"node NodeDataChanged"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是，ZK 的 watcher 是一次性的，也就是说，每次在处理完状态变化事件之后，需要重新注册 watcher。<br>这个特性使得在处理事件和重新加上 watcher 这段时间发生的节点状态变化将无法被感知。</p><p>ZK 常常发生的两种状态异常：</p><ol><li>org.apache.ZooKeeper.KeeperException.ConnectionLossException，客户端与其中一台服务器 socket 连接出现异常，连接丢失</li><li>org.apache.ZooKeeper.KeeperException.SessionExpiredException，客户端的 session 已经超过 sessionTimeout，未进行任何操作</li></ol><h3 id="zkClient-的使用"><a href="#zkClient-的使用" class="headerlink" title="zkClient 的使用"></a>zkClient 的使用</h3><p>zkClient 解决了 watcher 的一次性注册问题，将 znode 的事件重新定义为子节点的变化、数据的变化、连接及状态的变化三类。<br>zkClient 统一将 watcher 的 WatchedEvent 转换到以上三种情况去处理，watcher 执行后重新读取数据的同时，再注册相同的 watcher。zkClient 在发生 session expire 异常时会自动创建新的 ZooKeeper 实例进行重连。<br>zkClient 对 ZooKeeper 的基本 API 做了一些封装，使用起来更加简洁：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ZkClient zkClient = <span class="keyword">new</span> ZkClient(serverList);</span><br><span class="line"><span class="comment">// 创建节点</span></span><br><span class="line">zkClient.createPersistent(PATH);</span><br><span class="line"><span class="comment">// 创建字节点</span></span><br><span class="line">zkClient.create(PATH + <span class="string">"/child"</span>, <span class="string">"child znode"</span>, CreateMode.EPHEMERAL);</span><br><span class="line"><span class="comment">// 获得子节点</span></span><br><span class="line">List&lt;String&gt; children = zkClient.getChildren(PATH);</span><br><span class="line"><span class="comment">// 获得子节点个数</span></span><br><span class="line"><span class="keyword">int</span> childCount = zkClient.countChildren(PATH);</span><br><span class="line"><span class="comment">// 判断节点是否存在</span></span><br><span class="line">zkClient.exists(PATH);</span><br><span class="line"><span class="comment">// 写入数据</span></span><br><span class="line">zkClient.writeData(PATH + <span class="string">"/child"</span>, <span class="string">"hello everyone"</span>);</span><br><span class="line"><span class="comment">// 读取节点数据</span></span><br><span class="line">Object obj = zkClient.readData(PATH + <span class="string">"/child"</span>);</span><br><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line">zkClient.delete(PATH + <span class="string">"/child"</span>);</span><br></pre></td></tr></table></figure></p><h3 id="路由和负载均衡的实现"><a href="#路由和负载均衡的实现" class="headerlink" title="路由和负载均衡的实现"></a>路由和负载均衡的实现</h3><blockquote><p>一旦服务器与 ZooKeeper 集群断开连接，节点也就不存在了，通过注册相应的 watcher，服务消费者能够第一时间获知服务提供者机器信息的变更。利用其 znode 的特点和 watcher 机制，将其作为动态注册和获取服务信息的配置中心，统一管理服务名称和其服务器对应的服务器列表信息，我们能够近乎实时地感知到后端服务器的状态（上线、下线、宕机）。ZooKeeper 集群间通过 Zab 协议，服务器配置信息能够保持一致，而 ZooKeeper 本身容错特性和 leader 选举机制，能保障我们方便地进行扩容。</p></blockquote><p>基于 ZooKeeper 所实现的服务消费者获取服务提供者地址列表的部分关键代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">String serviceName = <span class="string">"service-B"</span>;</span><br><span class="line">String zkServerList = <span class="string">"192.168.136.130:2181"</span>;</span><br><span class="line">String SERVICE_PATH = <span class="string">"/configcenter/"</span> + serviceName;<span class="comment">// 服务节点路径</span></span><br><span class="line">ZkClient zkClient = <span class="keyword">new</span> ZkClient(zkServerList);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> serviceExists = zkClient.exists(SERVICE_PATH);</span><br><span class="line"><span class="keyword">if</span> (serviceExists) &#123;<span class="comment">// 服务存在，取地址列表</span></span><br><span class="line">serverList = zkClient.getChildren(SERVICE_PATH);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"service not exist!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册时间监听</span></span><br><span class="line">zkClient.subscribeChildChanges(SERVICE_PATH, <span class="keyword">new</span> IZkChildListener()) &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleChildChange</span><span class="params">(String parentPath, List&lt;String&gt; currentChilds)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">serverList = currentChilds;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务提供者向 ZooKeeper 集群注册服务的部分关键代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String serverList = <span class="string">"192.168.136.130:2181"</span>;</span><br><span class="line">String PATH = <span class="string">"/configcenter"</span>;<span class="comment">// 根节点路径</span></span><br><span class="line">ZkClient zkClient = <span class="keyword">new</span> ZkClient(serverList);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> rootExists = zkClient.exists(PATH);</span><br><span class="line"><span class="keyword">if</span>(!rootExists) &#123;</span><br><span class="line">zkClient.createPersistent(PATH);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> serviceExists = zkClient.exists(PATH + <span class="string">"/"</span> + serviceName);</span><br><span class="line"><span class="keyword">if</span>(serviceExists) &#123;</span><br><span class="line">zkClient.createPersistent(PATH + <span class="string">"/"</span> + serviceName);<span class="comment">// 创建服务节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册当前服务器，可以在节点的数据里面存放节点的权重</span></span><br><span class="line">InetAddress addr = InetAddress.getLocalHost();</span><br><span class="line">String ip = addr.getHostAddress().toString();<span class="comment">// 获得本机 IP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建当前服务器节点</span></span><br><span class="line">zkClient.createEphemeral(PATH + <span class="string">"/"</span> + serviceName + <span class="string">"/"</span> + ip);</span><br></pre></td></tr></table></figure></p><h2 id="HTTP-服务网关"><a href="#HTTP-服务网关" class="headerlink" title="HTTP 服务网关"></a>HTTP 服务网关</h2><p>网关（gateway）接收外部各种 APP 的 HTTP 请求，完成相应的权限与安全校验。当校验通过后，根据传入的服务名称，到服务配置中心找到相应的服务名称节点，并加载对应服务提供者的地址列表，通过前面所提到的负载均衡算法，选取服务器发起远程调用，将客户端参数传递到后端服务端。服务提供方根据所传入的参数，给出正确的响应，当 gateway 接收到响应后，再将响应输出给客户端 APP。</p><ul><li>Gateway 能够很好地解决安全问题，在恶意请求或者非授权请求到达后端服务器之前进行拦截和过滤。</li><li>Gateway 通过服务名称进行服务的路由和负载均衡调度，使得不同的平台之间能够很好地复用公共的业务逻辑，降低了开发和运维成本。</li></ul><blockquote><p>对于外部的 APP 来说，它依赖 gateway 进行服务的路由以及请求的转发，gateway 是整个网络的核心节点，一旦 gateway 失效，所有依赖它的外部 APP 都将无法使用。并且，由于所有的请求均经过 gateway 进行安全校验和请求转发，其流量是整个后端集群流量之和。因此，在设计之初，就需要考虑到系统流量的监控和容量规划，以及 gateway 集群的可扩展性，以便在流量达到极限之前，能够快速方便地进行系统扩容。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="SOA" scheme="http://yeonsea.club/tags/SOA/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统基础设施</title>
    <link href="http://yeonsea.club/2019/09/18/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/"/>
    <id>http://yeonsea.club/2019/09/18/分布式系统基础设施/</id>
    <published>2019-09-18T06:49:09.000Z</published>
    <updated>2019-09-24T07:29:03.056Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>一个大型、稳健、成熟的分布式系统的背后，往往会涉及众多的支撑系统，我们将这些支撑系统称为分布式系统的基础设施。</p></blockquote><h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><p>由于单台机器的内存资源和承载能力有限，并且如果大量使用本地缓存，也会使相同的数据被不同的节点存储多份，对内存资源造成较大的浪费，因此才催生出了分布式缓存。</p><h3 id="memcache"><a href="#memcache" class="headerlink" title="memcache"></a>memcache</h3><p>用于在应用中减少对数据库的访问，提高应用的访问速度，并降低数据库的负载。<br>memcache 使用 key-value 形式存储和访问数据，在内存中维护一张巨大的 HashTable。<br>memcache 使用了 libevent 来进行高效的网络连接处理。</p><h3 id="memcache-API-与分布式"><a href="#memcache-API-与分布式" class="headerlink" title="memcache API 与分布式"></a>memcache API 与分布式</h3><p>memcache 客户端与服务端通过构建在 TCP 协议之上的 memcache 协议来进行通信，协议支持两种数据的传递，这两种数据分别为文本行和非结构化数据。</p><ul><li>文本行：主要用来承载客户端的命令及服务端的响应。</li><li>非结构化数据：主要用于客户端和服务端数据的传递。采用字节流的形式。</li></ul><p>memcache 协议支持通过如下几种方式来读取写入失效数据：</p><ul><li>set  如果存在同样的 key ，替换</li><li>add  如果存在同样的 key ，失败</li><li>replace  如果不存在 key ，失败</li><li>append</li><li>prepend</li><li>cas  提供对变量的 cas 操作，它将保证数据更新之前，数据没有被其他人修改;</li><li>get</li><li>incr</li><li>decr</li><li>delete</li></ul><p>memcache 官方提供的 Memcache-Java-Client 工具包含了对 memcache 协议的 Java 封装，使用它可以比较方便地与缓存服务端进行通信，它的初始化方式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String[] servers = &#123;</span><br><span class="line"><span class="string">"192.168.136.135:11211"</span></span><br><span class="line">&#125;;</span><br><span class="line">SockIOPool pool = SockIOPool.getInstance();</span><br><span class="line">pool.setServers(servers); <span class="comment">// 设置服务器</span></span><br><span class="line">pool.setFailover(<span class="keyword">true</span>); <span class="comment">// 容错</span></span><br><span class="line">pool.setInstance(<span class="number">10</span>); <span class="comment">// 设置初始连接数</span></span><br><span class="line">pool.setMinConn(<span class="number">25</span>); <span class="comment">// 设置最小连接数</span></span><br><span class="line">pool.setMaxConn(<span class="number">25</span>); <span class="comment">// 设置最大连接数</span></span><br><span class="line">pool.setMaintSleep(<span class="number">30</span>); <span class="comment">// 设置连接池维护线程的睡眠时间</span></span><br><span class="line">pool.setNagle(<span class="keyword">false</span>); <span class="comment">// 设置是否使用 Nagle 算法</span></span><br><span class="line">pool.setSocketTO(<span class="keyword">true</span>); <span class="comment">// 设置 socket 的读取等待超时时间</span></span><br><span class="line">pool.setAliveCheck(<span class="keyword">true</span>); <span class="comment">// 设置连接心跳检测开关</span></span><br><span class="line">pool.setHashingAlg(SockIOPool.CONSISTENT_HASH); <span class="comment">// 设置 Hash 算法</span></span><br><span class="line">pool.initialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>memcache 本身并不是一种分布式缓存系统，它的分布式是由访问它的客户端来实现的。</p><p>一种比较简单的实现方式是根据缓存的 key 来进行 Hash ，当后端有 N 台缓存服务器时，访问的服务器为 hash(key)%N，这样可以将前端的请求均衡地映射到后端的缓存服务器。</p><p>但如果考虑缓存实例变动（增删）的情况：<br>某一缓存实例宕机，需要将该实例从集群中摘除，则映射公式变为 hash(object) % (N - 1)<br>增加一台缓存实例，将该实例加入集群，则映射公式变为 hash(object) % (N + 1)<br>对于以上情况，无论新增还是移除，大部分object所映射的缓存实例均会改变，缓存命中率大幅度降低从而回源到服务器，短时间内造成缓存雪崩现象。</p><p><em>使用 consistent Hash 算法能够在一定程度上改善上述问题。</em></p><ul><li>环形结构</li><li>虚拟节点</li></ul><h3 id="分布式-session"><a href="#分布式-session" class="headerlink" title="分布式 session"></a>分布式 session</h3><blockquote><p>传统的应用服务器，如 tomcat、jboss 等，其自身所实现的 session 管理大部分都是基于单机的。对于大型分布式网站来说，支撑其业务的远远不止一台服务器，而是一个分布式集群，请求在不同服务器之间跳转。<br>传统网站一般将一部分数据存储在 cookie 中，来规避分布式环境下 session 的操作。这样做的弊端很多，一方面 cookie 的安全性一直广为诟病，另一方面 cookie 存储数据的大小是有限制的。</p></blockquote><ul><li>将 session 持久化到 DB 中，可以保证宕机时会话不易丢失，但系统的整体吞吐将受到很大的影响。</li><li>将session 统一存储在缓存集群上，可以保证较高的读写性能，可以利用缓存的失效机制，但一旦缓存重启，里面保存的会话也就丢失了。</li></ul><p>通过将 session 以 sessionid 作为 key，保存到后端的缓存集群中，使得不管请求如何分配，即便是 Web Server 宕机，也不会影响其他 Web Server 通过 sessionid 从 Cache Server 中获得 session，这样既实现了集群间的 session 同步，又提高了 Web Server 的容错性。</p><p>memcache-session-manager 是一个开源的高可用的 Tomcat session 共享解决方案，支持 Sticky 模式和 Non-Sticky 模式。<br>以 Non-Sticky 模式为例，它需要给 Tomcat 的 $CATALINA_HOME/conf/context.xml 文件配置 SessionManager，具体配置如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">"de.javakaffee.web.msm.MemcachedBackupSessionManager"</span></span></span><br><span class="line"><span class="tag"><span class="attr">memcachedNodes</span>=<span class="string">"n1:192.168.0.100,:11211, n2:192.168.0.101:11211"</span></span></span><br><span class="line"><span class="tag"><span class="attr">Sticky</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag"><span class="attr">sessionBackupAsync</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag"><span class="attr">lockingNode</span>=<span class="string">"auto"</span></span></span><br><span class="line"><span class="tag"><span class="attr">requestUriIgnorePattern</span>=<span class="string">".*\.(ico|png|gif|jpg|css|js)$"</span></span></span><br><span class="line"><span class="tag"><span class="attr">transcoderFactoryClass</span> = <span class="string">"de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h2><p>面对并发访问量的激增和数据几何级的增长，如何存储正在迅速膨胀并且不断累积的数据，以及应对日益增长的用户访问频次，称为亟待解决的问题。</p><p>传统IOE解决方案，使用和扩展的成本越来越高，使得互联网企业不得不思考新的解决方案。开源软件加廉价PC Server的分布式架构，得益于社区的支持。在节约成本的同时，也给系统带来了良好的扩展能力，并且由于开源软件的代码透明，使得企业能够以更低的代价定制更符合自身使用场景的功能，以提高系统的整体性能。</p><h3 id="MySQL-扩展"><a href="#MySQL-扩展" class="headerlink" title="MySQL 扩展"></a>MySQL 扩展</h3><h4 id="业务拆分"><a href="#业务拆分" class="headerlink" title="业务拆分"></a>业务拆分</h4><blockquote><p>业务发展初期为了便于快速迭代，很多应用都采用集中式的架构。随着业务规模的扩展，使系统变得越来越复杂，越来越难以维护，开发效率越来越低，并且系统的资源消耗也越来越大，通过硬件提升性能的成本也越来越高。因此，系统业务的拆分是难以避免的。</p></blockquote><p>业务拆分不仅仅提高了系统的可扩展性，也带来了开发工作效率的提升。</p><h4 id="复制策略"><a href="#复制策略" class="headerlink" title="复制策略"></a>复制策略</h4><p>要实现数据库的复制，需要开启 Master 服务器端的 Binary log。数据复制的过程实际上就是 Slave 从 Master 获取 binary log，然后再在本地镜像的执行日志中记录的操作。<br>由于复制过程是异步的，只能够保证数据最终一致性。<br>MySQL 的复制可以基于一条语句(statement level)，也可以基于一条记录(row level)。</p><blockquote><p>前段服务器通过 Master 来执行数据写入的操作，数据的更新通过 Binary log 同步到 Slave 集群，而对于数据读取的请求，则交由 Slave 来处理，这样 Slave 集群可以分担数据库读的压力，并且读、写分离保障了数据能够达到最终一致性。</p></blockquote><p>Q:<br>Master-Slaves 复制架构存在一个问题，即所谓的单点故障。当 Master 宕机时，系统将无法写入，而在某些特定的场景下，也可能需要 Master 停机，以便进行系统维护、优化或者升级。<br>A:<br>最佳的方式就是采用 Dual-Master 架构，即 Master-Master 架构。<br>MySQL 不会将复制产生的变更记录到 Binary log ，这样就避免了服务器间数据的循环复制。</p><p><em>仅开启一台 Master 的写入，另一台 Master 仅仅 stand by 或者作为读库开放，这样可以避免数据写入的冲突，防止数据不一致的情况发生。</em></p><p>如需进行停机维护，可按如下步骤执行 Master 的切换操作：</p><ol><li>停止当前 Master 的所有写入操作。</li><li>在 Master 上执行 set global read_only=1，同时更新 MySQL 配置文件中相应的配置，避免重启时失效。</li><li>在 Master 上执行 show Master status，以记录 Binary log 坐标。</li><li>使用 Master 上的 Binary log 坐标，在 stand by 的 Master 上执行 select Master_pos_wait()，等待 stand by Master 的 Binary log 跟上 Master 的 Binary log。</li><li>在 stand by Master 开启写入时，设置 read_only=0。</li><li>修改应用程序的配置，使其写入到新的 Master。</li></ol><blockquote><p>假如 Master 意外宕机，处理过程要稍微复杂一点，因为此时 Master 与 stand by Master 上的数据并不一定同步，需要将 Master 上没有同步到 stand by Master 的 Binary log 复制到 Master 上进行 replay，直到 stand by Master 与 原 Master 上的 Binary log 同步，才能够开启写入；否则，这一部分不同步的数据就有可能导致数据不一致。</p></blockquote><h4 id="分表与分库"><a href="#分表与分库" class="headerlink" title="分表与分库"></a>分表与分库</h4><p>对于访问极为频繁且数据量巨大的单表来说，我们首先要做的就是减少单表的记录条数，以便减少数据查询所需要的时间，提高数据库的吞吐，这就是所谓的分表。</p><p>用户 id 是最常用的分表字段。</p><blockquote><p>假设有一张记录用户购买信息的订单表 order，由于 order 表记录条数太多，将被拆分成 256 张表。拆分的记录根据 user_id%256，找到对应订单存储的表进行访问。</p></blockquote><p>分表能够解决单表数据量过大带来查询效率下降的问题，但是，却无法给数据库的并发处理能力带来质的提升。<br>与分表策略相似，分库也可以采用通过一个关键字取模的方式，来对数据访问进行路由。</p><blockquote><p>有时数据库可能既面临着高并发访问的压力，又需要面对海量数据的存储问题，这时需要对数据库即采用分库策略，又采用分表策略，以便同时扩展系统的并发处理能力，以及提升单表的查询能力，这就是所谓的分库分表。</p></blockquote><p>一般分库分表的路由策略：</p><ul><li>中间变量=user_id%(库数量*每个库的表数量)</li><li>库=取整(中间变量/每个库的表数量)</li><li>表=中间变量%每个库的表数量</li></ul><p><em>业务拆分及分库分表带来的问题：</em></p><ul><li>原本跨表的事务上升为分布式事务；</li><li>由于记录被切分到不同的库与不同的表当中，难以进行多表关联查询，并且不能不指定路由字段对数据进行查询。</li><li>如果需要对系统进行进一步扩容(路由策略变更)，将变得非常不方便，需要重新进行数据迁移。</li></ul><h3 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h3><p>Apache Hadoop 项目下的一个子项目，它以 Google BigTable 为原型，设计实现了高可靠性、高可扩展性、实时读写的列存储数据库。</p><blockquote><p>本质实际上是一张稀疏的大表，用来存储粗粒度的结构化数据，并且能够通过简单地增加节点来实现系统的线性扩展。</p></blockquote><p>HBase 运行在分布式文件系统 HDFS 之上，利用它可以在廉价的 PC Server 上搭建大规模结构化存储集群。</p><p>HBase 集群中通常包含两种角色，HMaster 和 HRegionServer。当表随着记录条数的增加而不断变大后，将会分裂成一个个Region，每个 Region 可以由(startkey，endkey)来表示，它包含一个 startkey 到 endkey 的半闭区间。<br>一个 HRegion 可以管理多个 Region，并由 HMaster 来负责 HRegionServer 的调度及集群状态的监管。</p><h4 id="HBase-安装"><a href="#HBase-安装" class="headerlink" title="HBase 安装"></a>HBase 安装</h4><ol><li>下载</li><li>编辑 hbase-env.sh ，设置 JAVA_HOME</li><li>编辑 hbase-site.xml 文件</li><li>启动 HBase  先启动 Hadoop 再启动 HBase</li></ol><h4 id="HBase-API"><a href="#HBase-API" class="headerlink" title="HBase API"></a>HBase API</h4><p>以 Java 为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 配置 HBase 的 HMaster 服务器地址和对应的端口（默认为60000），以及对应的 ZooKeeper 服务器地址和端口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Configuration conf = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">conf = HBaseConfiguration.create();</span><br><span class="line">conf.set(<span class="string">"hbase.ZooKeeper.property.clientPort"</span>, <span class="string">"2181"</span>);</span><br><span class="line">conf.set(<span class="string">"hbase.ZooKeeper.quorum"</span>, <span class="string">"192.168.136.135:60000"</span>);</span><br><span class="line">conf.set(<span class="string">"hbase.master"</span>, <span class="string">"192.168.136.135:60000"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 通过程序增加 user 表，包含三个列族，分别为 info、class、parent，如果该表已经存在，则先删除该表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createTable</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String tableName = <span class="string">"user"</span>;</span><br><span class="line">HBaseAdmin hBaseAdmin = <span class="keyword">new</span> hBaseAdmin(conf);</span><br><span class="line"><span class="keyword">if</span> (hBaseAdmin.tableExists(tableName)) &#123;</span><br><span class="line">hBaseAdmin.disableTable(tableName);</span><br><span class="line">hBaseAdmin.deleteTable(tableName);</span><br><span class="line">&#125;</span><br><span class="line">HTableDescriptor tableDescriptor = <span class="keyword">new</span> HTableDescriptor(tableName.valueOf(tableName));</span><br><span class="line">tableDescriptor.addFamily(<span class="keyword">new</span> HColumnDescriptor(<span class="string">"info"</span>));</span><br><span class="line">tableDescriptor.addFamily(<span class="keyword">new</span> HColumnDescriptor(<span class="string">"class"</span>));</span><br><span class="line">tableDescriptor.addFamily(<span class="keyword">new</span> HColumnDescriptor(<span class="string">"parent"</span>));</span><br><span class="line">hBaseAdmin.createTable(tableDescriptor);</span><br><span class="line">hBaseAdmin.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将数据添加到 user 表，每个列族指定一个列 col, 并给该列赋值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putRow</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String tableName = <span class="string">"user"</span>;</span><br><span class="line">String[] familyNames = &#123;<span class="string">"info"</span>, <span class="string">"class"</span>, <span class="string">"parent"</span>&#125;;</span><br><span class="line">HTable table = <span class="keyword">new</span> HTable(conf, tableName);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; familyNames.length; j++) &#123;</span><br><span class="line">Put put = <span class="keyword">new</span> Put(Bytes.toBytes(i + <span class="string">""</span>));</span><br><span class="line">put.add(Bytes.toBytes(familyNames[j]),</span><br><span class="line">Bytes.toBytes(<span class="string">"col"</span>),</span><br><span class="line">Bytes.toBytes(<span class="string">"value_"</span> + i + <span class="string">"_"</span> + j));</span><br><span class="line">table.put(put);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">table.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 取得 rowkey 为 1 的行，并将该行打印出来</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getRow</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String tableName = <span class="string">"user"</span>;</span><br><span class="line">String rowKey = <span class="string">"1"</span>;</span><br><span class="line">HTable table = <span class="keyword">new</span> HTable(conf, tableName);</span><br><span class="line">Get g = <span class="keyword">new</span> Get(Bytes.toBytes(rowKey));</span><br><span class="line">Result r = table.get(g);</span><br><span class="line">outputResult(r);</span><br><span class="line">table.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outputResult</span><span class="params">(Result rs)</span> </span>&#123;</span><br><span class="line">List&lt;Cell&gt; list = rs.listCells();</span><br><span class="line">System.out.println(<span class="string">"row key: "</span> + <span class="keyword">new</span> String(rs.getRow()));</span><br><span class="line"><span class="keyword">for</span> (Cell cell : list) &#123;</span><br><span class="line">System.out.println(<span class="string">"family: "</span> + <span class="keyword">new</span> String(cell.getFamily()) </span><br><span class="line">+ <span class="string">", col: "</span> + <span class="keyword">new</span> String(cell.getQualifier())</span><br><span class="line">+ <span class="string">", value: "</span> + <span class="keyword">new</span> String(cell.getValue()) );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* scan 扫描 user 表，并将查询结果打印出来</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scanTable</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String tableName = <span class="string">"user"</span>;</span><br><span class="line">HTable table = <span class="keyword">new</span> HTable(conf, tableName);</span><br><span class="line">Scan a = <span class="keyword">new</span> Scan();</span><br><span class="line">ResultScanner rs = table.getScanner(s);</span><br><span class="line"><span class="keyword">for</span> (Result r : rs) &#123;</span><br><span class="line">outputResult(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 startrow 和 endrow 进行查询</span></span><br><span class="line">s = <span class="keyword">new</span> Scan(<span class="string">"2"</span>.getBytes(), <span class="string">"6"</span>.getBytes());</span><br><span class="line">rs = table.getScanner(s);</span><br><span class="line"><span class="keyword">for</span> (Result r : rs) &#123;</span><br><span class="line">outputResult(r);</span><br><span class="line">&#125;</span><br><span class="line">table.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 删除 rowkey 为 1 的记录</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteRow</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String tableName = <span class="string">"user"</span>;</span><br><span class="line">String rowKey = <span class="string">"1"</span>;</span><br><span class="line">HTable table = <span class="keyword">new</span> HTable(conf, tableName);</span><br><span class="line">List&lt;Delete&gt; list = <span class="keyword">new</span> ArrayList&lt;Delete&gt;();</span><br><span class="line">Delete d = <span class="keyword">new</span> Delete(rowkey.getBytes());</span><br><span class="line">list.add(d);</span><br><span class="line">table.delete(list);</span><br><span class="line">table.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="rowkey-设计"><a href="#rowkey-设计" class="headerlink" title="rowkey 设计"></a>rowkey 设计</h4><p>要想访问 HBase 的行，只有三种方式，一种是通过指定 rowkey 进行访问，另一种是指定 rowkey 的 range 进行 scan，再者就是全盘扫描。</p><blockquote><p>关系型数据库能够很好地支持多条件查询，但对于 HBase 来说，实现起来并不是那么的容易。基本的思路就是建立一张二级索引表，将查询条件设计成二级索引表的rowkey，而存储的数据则是数据表的rowkey，这样就可以在一定程度上实现多个条件的查询。但是二级索引表也会引入一系列的问题，多表的插入将降低数据写入的性能，并且由于多表之间无事务保障，可能会带来数据一致性问题。(华为提供了 hindex 的二级索引解决方案)</p></blockquote><p>与传统的关系型数据库相比，HBase 有更好的伸缩能力，更适合于海量数据的存储和处理。由于多个 Region Server 的存在，使得 HBase 能够多个节点同时写入，显著提高了写入性能，并且是可扩展的。</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>与其他很多 key-value 数据库的不同之处在于，Redis 不仅支持简单的键值对类型的存储，还支持其他一系列丰富的数据存储结构，并在这些数据结构类型上定义了一套强大的 API。</p><h4 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a>安装 Redis</h4><h4 id="使用-Redis-API"><a href="#使用-Redis-API" class="headerlink" title="使用 Redis API"></a>使用 Redis API</h4><p>Redis 的 Java client 有很多，比较常用的是 Jedis。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"192.168.136.135"</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line">redis.set(<span class="string">"name"</span>, <span class="string">"yeonsea"</span>);<span class="comment">// 设置 key-value</span></span><br><span class="line">redis.setex(<span class="string">"content"</span>, <span class="number">5</span>, <span class="string">"hello"</span>);<span class="comment">// 设置 key-value 有效期为 5 秒</span></span><br><span class="line">redis.mset(<span class="string">"class"</span>, <span class="string">"a"</span>, <span class="string">"age"</span>, <span class="string">"25"</span>);<span class="comment">// 一次设置多个 key-value</span></span><br><span class="line">redis.append(<span class="string">"content"</span>, <span class="string">" lucy"</span>);<span class="comment">// 给字符串追加内容</span></span><br><span class="line">String content = redis.get(<span class="string">"content"</span>);<span class="comment">// 根据 key 获取 value </span></span><br><span class="line">List&lt;String&gt; list = redis.mget(<span class="string">"class"</span>, <span class="string">"age"</span>);<span class="comment">// 一次获取多个 key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hashs 操作</span></span><br><span class="line">redis.hset(<span class="string">"url"</span>, <span class="string">"google"</span>, <span class="string">"www.google.com"</span>);<span class="comment">// 给 Hash 添加 key-value</span></span><br><span class="line">redis.hset(<span class="string">"url"</span>, <span class="string">"taobao"</span>, <span class="string">"www.taobao.com"</span>);</span><br><span class="line">redis.hset(<span class="string">"url"</span>, <span class="string">"sina"</span>, <span class="string">"www.sina.com.cn"</span>);</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">map.put(<span class="string">"name"</span>, <span class="string">"yeon"</span>);</span><br><span class="line">map.put(<span class="string">"sex"</span>, <span class="string">"male"</span>);</span><br><span class="line">map.put(<span class="string">"age"</span>, <span class="string">"100"</span>);</span><br><span class="line">redis.hmset(<span class="string">"userinfo"</span>, map);<span class="comment">// 批量设置值</span></span><br><span class="line"></span><br><span class="line">String name = redis.hget(<span class="string">"userinfo"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取 Hash 的多个 key 的值</span></span><br><span class="line">List&lt;String&gt; urlist = redis.hmget(<span class="string">"url"</span>, <span class="string">"google"</span>, <span class="string">"taobao"</span>, <span class="string">"sina"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取 Hash 的所有 key 的值</span></span><br><span class="line">Map&lt;String, String&gt; userinfo = redis.hgetAll(<span class="string">"userinfo"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// lists 操作</span></span><br><span class="line">redis.lpush(<span class="string">"charlist"</span>, <span class="string">"abc"</span>);<span class="comment">// 在 list 首部添加元素</span></span><br><span class="line">redis.rpush(<span class="string">"charlist"</span>, <span class="string">"hij"</span>);<span class="comment">// 在 list 尾部添加元素</span></span><br><span class="line">List&lt;String&gt; charlist = redis.lrange(<span class="string">"charlist"</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">redis.lpop(<span class="string">"charlist"</span>);<span class="comment">// 在 list 首部删除元素</span></span><br><span class="line">redis.rpop(<span class="string">"charlist"</span>);<span class="comment">// 在 list 尾部删除元素</span></span><br><span class="line">Long charlistSize = redis.llen(<span class="string">"charlist"</span>);<span class="comment">// 获得 list 的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sets</span></span><br><span class="line">redis.sadd(<span class="string">"SetMem"</span>, <span class="string">"s1"</span>);<span class="comment">// 给 set 添加元素</span></span><br><span class="line">redis.srem(<span class="string">"SetMem"</span>, <span class="string">"s1"</span>); <span class="comment">// 从 set 中移除元素</span></span><br><span class="line">Set&lt;String&gt; set = redis.smember(<span class="string">"SetMem"</span>);<span class="comment">// 枚举出 set 的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sorted sets 是 set 的一个升级版本</span></span><br><span class="line">redis.zadd(<span class="string">"SortSetMem"</span>, <span class="number">1</span>, <span class="string">"5th"</span>);<span class="comment">// 插入 sort set，并指定元素的序号</span></span><br><span class="line">redis.zadd(<span class="string">"SortSetMem"</span>, <span class="number">2</span>, <span class="string">"4th"</span>);</span><br><span class="line">redis.zadd(<span class="string">"SortSetMem"</span>, <span class="number">3</span>, <span class="string">"3th"</span>);</span><br><span class="line">redis.zadd(<span class="string">"SortSetMem"</span>, <span class="number">4</span>, <span class="string">"2th"</span>);</span><br><span class="line">redis.zadd(<span class="string">"SortSetMem"</span>, <span class="number">5</span>, <span class="string">"1th"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据范围取 set</span></span><br><span class="line">Set&lt;String&gt; sorted = redis.zrange(<span class="string">"SortSetMem"</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据范围反向取 set</span></span><br><span class="line">Set&lt;String&gt; revsorset = redis.zrevrange(<span class="string">"SortSetMem"</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><h2 id="消息系统"><a href="#消息系统" class="headerlink" title="消息系统"></a>消息系统</h2><blockquote><p>在分布式系统中，消息系统的应用十分广泛，消息可以作为应用间通信的一种方式，消息被保存在队列中，直到被接收者取出。<br>由于消息发送者不需要同步等待消息接收者的响应，消息的异步接收降低了系统集成的耦合度，提升了分布式系统的协作效率，使得系统能够更快的响应用户，提供更高的吞吐。当系统处于峰值压力时，避免整个系统被压垮。</p></blockquote><h3 id="ActiveMQ-amp-JMS"><a href="#ActiveMQ-amp-JMS" class="headerlink" title="ActiveMQ &amp; JMS"></a>ActiveMQ &amp; JMS</h3><p>ActiveMQ 是 Apache 所提供的一个开源的消息系统，安全采用 Java 实现，因此，它能够很好地支持 J2EE 提出的 JMS 规范。</p><blockquote><p>JMS（Java Message Service，即 Java 消息服务）是一组 Java 应用程序接口，它提供消息的创建、发送、接收、读取等一系列服务。JMS 定义了一组公共应用程序接口和响应的语法，类似于 Java 数据库的统一访问接口 JDBC，它是一种与厂商无关的 API ，使得 Java 程序能够与不同厂商的消息组件很好地进行通信。</p></blockquote><p>JMS 支持的消息类型：</p><ul><li>简单文本（TextMessage）</li><li>可序列化的对象（ObjectMessage）</li><li>键值对（MapMessage）</li><li>字节流（BytesMessage）</li><li>流（StreamMessage）</li><li>无有效负载的消息（Message）</li></ul><p>JMS 支持两种消息发送和接收模型：</p><ul><li>Point-to-Point（P2P）模型：基于queue</li><li>Pub/Sub(发布/订阅)模型：定义了如何向一个内容节点发布/订阅消息，这个内容节点称为 topic（主题）</li></ul><h4 id="安装-ActiveMQ"><a href="#安装-ActiveMQ" class="headerlink" title="安装 ActiveMQ"></a>安装 ActiveMQ</h4><h4 id="通过-JMS-访问-ActiveMQ"><a href="#通过-JMS-访问-ActiveMQ" class="headerlink" title="通过 JMS 访问 ActiveMQ"></a>通过 JMS 访问 ActiveMQ</h4><p>使用 JMS 来完成 ActiveMQ 基于 queue 的点对点消息发送：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(</span><br><span class="line">ActiveMQConnection.DEFAULT_USER,</span><br><span class="line">ActiveMQConnection.DEFAULT_PASSWORD,</span><br><span class="line"><span class="string">"tcp://192.168.136.135:61616"</span>);</span><br><span class="line">Connection connection = connectionFactory.createConnection();</span><br><span class="line">connection.start();</span><br><span class="line">Session session = connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">Destination destination = session.createQueue(<span class="string">"MessageQueue"</span>);</span><br><span class="line">MessageProducer producer = session.createProducer(destination);</span><br><span class="line">producer.setDeliveryMode(DeliveryMode.NON_PERISTENT);</span><br><span class="line"></span><br><span class="line">ObjectMessage message = session.createObjectMessage(<span class="string">"hello everyone!"</span>);</span><br><span class="line">producer.send(message);</span><br><span class="line">session.commit();</span><br></pre></td></tr></table></figure></p><p>基于 queue 的点对点消息接收<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(</span><br><span class="line">ActiveMQConnection.DEFAULT_USER,</span><br><span class="line">ActiveMQConnection.DEFAULT_PASSWORD,</span><br><span class="line"><span class="string">"tcp://192.168.136.135:61616"</span>);</span><br><span class="line">Connection connection = connectionFactory.createConnection();</span><br><span class="line">connection.start();</span><br><span class="line">Session session = connection.createSession(Boolean.FALSE, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">Destination destination = session.createQueue(<span class="string">"MessageQueue"</span>);</span><br><span class="line">MessageConsumer consumer = session.createConsumer(destination);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">// 取出消息</span></span><br><span class="line">ObjectMessage message = (ObjectMessage) consumer.receive(<span class="number">10000</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != messgae) &#123;</span><br><span class="line">String messageContent = (String) message.getObject();</span><br><span class="line">System.out.println(messageContent);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过 JMS 来创建 ActiveMQ 的 topic，并给 topic 发送消息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(</span><br><span class="line">ActiveMQConnection.DEFAULT_USER,</span><br><span class="line">ActiveMQConnection.DEFAULT_PASSWORD,</span><br><span class="line"><span class="string">"tcp://192.168.136.135:61616"</span>);</span><br><span class="line">Connection connection = connectionFactory.createConnection();</span><br><span class="line">connection.start();</span><br><span class="line">Session session = connection.createSession(Boolean.FALSE, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">Topic topic = session.createTopic(<span class="string">"MessageTopic"</span>);</span><br><span class="line">MessageProducer producer = session.createProducer(topic);</span><br><span class="line">producer.setDeliveryMode(DeliveryMode.NON_PERISTENT);</span><br><span class="line">TextMessage message = session.createTextMessage();</span><br><span class="line">message.setText(<span class="string">"message_hello_yeon"</span>);</span><br><span class="line">producer.send(message);</span><br></pre></td></tr></table></figure></p><p>消息发送到对应的 topic 后，需要将 listener 注册到需要订阅的 topic 上，以便能够接收该 topic 的消息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(</span><br><span class="line">ActiveMQConnection.DEFAULT_USER,</span><br><span class="line">ActiveMQConnection.DEFAULT_PASSWORD,</span><br><span class="line"><span class="string">"tcp://192.168.136.135:61616"</span>);</span><br><span class="line">Connection connection = connectionFactory.createConnection();</span><br><span class="line">connection.start();</span><br><span class="line">Session session = connection.createSession(Boolean.FALSE, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">Topic topic = session.createTopic(<span class="string">"MessageTopic"</span>);</span><br><span class="line"></span><br><span class="line">MessageConsumer consumer = session.createConsumer(topic);</span><br><span class="line">consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">TextMessage tm = (TextMessage) message;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(tm.getText());</span><br><span class="line">&#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="ActiveMQ-集群部署"><a href="#ActiveMQ-集群部署" class="headerlink" title="ActiveMQ 集群部署"></a>ActiveMQ 集群部署</h4><p>当一个应用被部署到生产环境中，进行容错和避免单点故障是十分重要的，这样可以避免因为单个节点的不可用而导致整个系统的不可用。目前 ActiveMQ 所提供的高可用方案主要是基于 Master-Slave 模式实现的冷备方案，较为常用的包括基于共享文件系统的 Master-Slave 架构和基于共享数据库的 Master-Slave 架构。</p><blockquote><p>当 Master 启动时，它会获得共享文件系统的排它锁，而其他 slave 则 stand-by，不对外提供服务，同时等待获取 Master 的排它锁。假如 Master 连接中断或者发生异常，那么它的排它锁则会立即释放，此时便会有另外一个 Slave 能够争夺到 Master 的排它锁，从而成为 Master，对外提供服务。当之前的故障或者连接中断而丢失排它锁的 Master 重新连接到共享文件系统时，排它锁已经被抢占了，它将作为 Slave 等待，直到 Master 再一次发生异常。<br>基于共享数据库的 Master-Slave 架构同基于共享文件系统的 Master-Slave 架构类似。<br>当 Master 启动时，会先获取数据库某个表的排它锁，而其他 Slave 则 stand-by，等待表锁，直到 Master 发生异常，连接丢失。这时表锁将释放，其他 Slave 将获得表锁，从而成为 Master 并对外提供服务，Master 与 Slave 自动完成切换，完全不需要人工干预。</p></blockquote><p>系统扩展：</p><ul><li>垂直扩展：可以提升单 Broker 的处理能力。最直接的方法就是提升硬件性能，再者就是通过调节 ActiveMQ 本身的一些配置来提升系统并发处理的能力，如使用 nio 替代阻塞 I/O，提高系统处理并发请求的能力，或者调整 JVM 与 ActiveMQ 可用的内存空间等。</li><li>水平扩展：对于 ActiveMQ 来说，可以采用 broker 拆分的方式，将不相关的 queue 和 topic 拆分到多个 broker，来达到提升系统吞吐能力的目的。</li></ul><h2 id="垂直化搜索引擎"><a href="#垂直化搜索引擎" class="headerlink" title="垂直化搜索引擎"></a>垂直化搜索引擎</h2><p>垂直化的搜索引擎主要针对企业内部的自有数据的检索，而不像 Google 和 Baidu 等搜索引擎平台，采用网络爬虫对全网数据进行抓取，从而建立索引并提供给用户进行检索。<br>在分布式系统中，垂直化的搜索引擎是一个非常重要的角色，它既能满足用户对于全文检索、模糊匹配的需求，解决数据库 like 查询效率低下的问题，又能够解决分布式环境下，由于采用分库分表或者使用 NoSQL 数据库，导致无法进行多表关联或者进行复杂查询的问题。</p><h3 id="Lucene-简介"><a href="#Lucene-简介" class="headerlink" title="Lucene 简介"></a>Lucene 简介</h3><p>几个重要概念：</p><ul><li>倒排索引：invert index，也称为反向索引，它将文档中的词作为关键字，建立词与文档的映射关系，通过对倒排索引的检索，可以根据词快速获取包含这个词的文档列表。</li><li>分词，又称切词，就是将句子或者段落进行切割，从中提取出包含固定语义的词。对于支持中文搜索的搜索引擎来说，需要一个合适的中文分词工具，以便建立倒排索引。</li><li>停止词，这些词没有具体意义，区分度低，搜索引擎对这些词进行索引没有任何意义，因此，停止词需要被忽略掉。</li><li>排序，需要将相关度更大的内容排在前面，以便用户能够更快地筛选出有价值的内容。</li></ul><p>Lucene 的几个概念：</p><ul><li>文档（Document）</li><li>域（Field）</li><li>词（Term）</li><li>查询（Query），最基本的查询可能是一系列 Term 的条件组合，称为TermQuery，但也有可能是短语查询（PhraseQuery）、前缀查询（PrefixQuery）、范围查询（包括 TermRangeQuery、NumericRangeQuery等）</li><li>分词器（Analyzer），文档被索引之前，需要经过分词器处理，以提取关键的语义单元，建立索引，并剔除无用的信息，如停止词等，以提高查询的准确性。</li></ul><h3 id="Lucene-的使用"><a href="#Lucene-的使用" class="headerlink" title="Lucene 的使用"></a>Lucene 的使用</h3><h4 id="构建索引"><a href="#构建索引" class="headerlink" title="构建索引"></a>构建索引</h4><p>在执行搜索之前，先要构建搜索的索引：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Directory dir = FSDirectory.open(<span class="keyword">new</span> File(indexPath));</span><br><span class="line">Analyzer analyzer = <span class="keyword">new</span> StandardAnalyzer();</span><br><span class="line">Document doc = <span class="keyword">new</span> Document();</span><br><span class="line">doc.add(<span class="keyword">new</span> Field(<span class="string">"name"</span>, <span class="string">"yeon"</span>, Store.YES, Index.ANALYZED));<span class="comment">// 需要对该字段进行全文检索</span></span><br><span class="line">doc.add(<span class="keyword">new</span> Field(<span class="string">"address"</span>, <span class="string">"kk"</span>, Store.YES, Index.ANALYZED));</span><br><span class="line">doc.add(<span class="keyword">new</span> Field(<span class="string">"sex"</span>, <span class="string">"male"</span>, Store.YES, Index.NOT_ANALYZED));<span class="comment">// 不进行全文检索</span></span><br><span class="line">doc.add(<span class="keyword">new</span> Field(<span class="string">"introduce"</span>, <span class="string">"xxxxxxxx"</span>, Store.YES, Index.NO));<span class="comment">// 不进行检索</span></span><br><span class="line">IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(dir, analyzer, MaxFieldLength.LIMITED);</span><br><span class="line">indexWriter.addDocument(doc);</span><br><span class="line">indexWriter.close();</span><br></pre></td></tr></table></figure></p><h4 id="索引更新与删除"><a href="#索引更新与删除" class="headerlink" title="索引更新与删除"></a>索引更新与删除</h4><p>Lucene 暂时还不支持对于 Document 单个 Field 或者整个 Document 的更新。因此这里的更新，实际上是删除旧的 Document ，然后再向索引中添加新的 Document。所添加的新的 Document 必须包含所有的 Field，包括没有更改的 Field。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(dir, analyzer, MaxFieldLength.LIMITED);</span><br><span class="line">indexWriter.deleteDocuments(<span class="keyword">new</span> Term(<span class="string">"name"</span>, <span class="string">"yeon"</span>));<span class="comment">// 一个不正确的 Term 可能导致搜索引擎的大量索引被误删</span></span><br><span class="line">indexWriter.addDocument(doc);</span><br></pre></td></tr></table></figure></p><p>Lucene 也提供经过封装的 updateDocument 方法，实质还是一样。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">indexWriter.updateDocument(<span class="keyword">new</span> Term(<span class="string">"name"</span>, <span class="string">"yeon"</span>), doc);</span><br></pre></td></tr></table></figure></p><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String queryStr = <span class="string">"yeon"</span>;</span><br><span class="line">String[] fields = &#123;<span class="string">"name"</span>, <span class="string">"introduce"</span>&#125;;</span><br><span class="line"></span><br><span class="line">Analyzer analyzer = <span class="keyword">new</span> StandardAnalyzer();</span><br><span class="line">QueryParser queryParser = <span class="keyword">new</span> MultiFieldQueryParser(fields, analyser);</span><br><span class="line">Query query = queryParser.parse(queryStr);</span><br><span class="line"></span><br><span class="line">IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(indexPath);</span><br><span class="line">Filter filter = <span class="keyword">null</span>;</span><br><span class="line">TopDocs topDocs = indexSearcher.search(query, filter, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"hits :"</span> + topDocs.totalHits);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(ScoreDoc scoreDoc : topDocs.scoreDocs) &#123;</span><br><span class="line"><span class="keyword">int</span> docNum = scoreDoc.doc;</span><br><span class="line">Document doc = indexSearcher.doc(docNum);</span><br><span class="line">printDocumentInfo(doc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对某个 Field 关键字查询：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Term term = <span class="keyword">new</span> Term(<span class="string">"name"</span>, <span class="string">"yeon"</span>);</span><br><span class="line">Query termQuery = <span class="keyword">new</span> TermQuery(term);</span><br></pre></td></tr></table></figure></p><p>针对某个范围对 Field 的值进行区间查询：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NumericRangeQuery numericRangeQuery = NumericRangeQuery.newIntRange(<span class="string">"size"</span>, <span class="number">2</span>, <span class="number">100</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p><p>通过通配符来对 Field 进行查询<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Term wildcardTerm = <span class="keyword">new</span> Term(<span class="string">"name"</span>, <span class="string">"yeo?"</span>); <span class="comment">// ? 0个或1个字母；* 0个或多个字母</span></span><br><span class="line">WildCardQuery wildCardQuery = <span class="keyword">new</span> WildCardQuery(wildcardTerm);</span><br></pre></td></tr></table></figure></p><p>通过关键字查询<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PhraseQuery phraseQuery = <span class="keyword">new</span> PhraseQuery();</span><br><span class="line">phraseQuery.add(<span class="keyword">new</span> Term(<span class="string">"content"</span>, <span class="string">"dog"</span>));</span><br><span class="line">phraseQuery.add(<span class="keyword">new</span> Term(<span class="string">"content"</span>, <span class="string">"cat"</span>));</span><br><span class="line">phraseQuery.setSlop(<span class="number">5</span>);<span class="comment">// 两个短语之间最多不超过 5 个单词</span></span><br></pre></td></tr></table></figure></p><p>将不同条件组合起来进行复杂查询<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PhraseQuery query1 = <span class="keyword">new</span> PhraseQuery();</span><br><span class="line">query1.add(<span class="keyword">new</span> Term(<span class="string">"content"</span>, <span class="string">"dog"</span>));</span><br><span class="line">query1.add(<span class="keyword">new</span> Term(<span class="string">"content"</span>, <span class="string">"cat"</span>));</span><br><span class="line">query1.setSlop(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">Term wildTerm = <span class="keyword">new</span> Term(<span class="string">"name"</span>, <span class="string">"yeo?"</span>);</span><br><span class="line">WildCardQuery query2 = <span class="keyword">new</span> WildCardQuery(wildTerm);</span><br><span class="line">BooleanQuery booleanQuery = <span class="keyword">new</span> BooleanQuery();</span><br><span class="line">booleanQuery.add(query1, Occur.MUST);</span><br><span class="line">booleanQuery.add(query2, Occur.MUST); <span class="comment">// 表示符合条件的 Document 才被包含在结果中</span></span><br></pre></td></tr></table></figure></p><h4 id="结果排序"><a href="#结果排序" class="headerlink" title="结果排序"></a>结果排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String queryStr = <span class="string">"lishi"</span>;</span><br><span class="line">String[] fields = &#123;<span class="string">"name"</span>, <span class="string">"address"</span>, <span class="string">"size"</span>&#125;;</span><br><span class="line">Sort sort = <span class="keyword">new</span> Sort();</span><br><span class="line">SortField field = <span class="keyword">new</span> SortField(<span class="string">"size"</span>, SortField.INT, <span class="keyword">true</span>);</span><br><span class="line">sort.setSort(field);</span><br><span class="line">Analyzer analyzer = <span class="keyword">new</span> StandardAnalyzer();</span><br><span class="line">QueryParser queryParser = <span class="keyword">new</span> MultiFieldQueryParser(fields, analyzer);</span><br><span class="line">Query query = queryParser.parse(queryStr);</span><br><span class="line">IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(indexPath);</span><br><span class="line">Filter filter = <span class="keyword">null</span>;</span><br><span class="line">TopDocs topDocs = indexSearcher.search(query, filter, <span class="number">100</span>, sort);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(ScoreDoc scoreDoc : topDocs.scoreDocs) &#123;</span><br><span class="line"><span class="keyword">int</span> docNum = scoreDoc.doc;</span><br><span class="line">Document doc = indexSearcher.doc(docNum);</span><br><span class="line">printDocumentInfo(doc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果多个 Field 同时进行查询，可以指定每个 Field 拥有不同的权重，以便匹配时可以按照 Document 的相关度进行排序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String queryStr = <span class="string">"zhangsan shanghai"</span>;</span><br><span class="line">String[] fields = &#123;<span class="string">"name"</span>, <span class="string">"address"</span>, <span class="string">"size"</span>&#125;;</span><br><span class="line">Map&lt;String, Float&gt; weights = <span class="keyword">new</span> HashMap&lt;String, Float&gt;();</span><br><span class="line">map.put(<span class="string">"name"</span>, <span class="number">4f</span>);</span><br><span class="line">map.put(<span class="string">"address"</span>, <span class="number">2f</span>);</span><br><span class="line"></span><br><span class="line">Analyzer analyzer = <span class="keyword">new</span> StandardAnalyzer();</span><br><span class="line">QueryParser queryParser = <span class="keyword">new</span> MultiFieldQueryParser(fields, analyzer, weights);</span><br><span class="line">Query query = queryParser.parse(queryStr);</span><br><span class="line">IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(indexPath);</span><br><span class="line">Filter filter = <span class="keyword">null</span>;</span><br><span class="line">TopDocs topDocs = indexSearcher.search(query, filter, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(ScoreDoc scoreDoc : topDocs.scoreDocs) &#123;</span><br><span class="line"><span class="keyword">int</span> docNum = scoreDoc.doc;</span><br><span class="line">Document doc = indexSearcher.doc(docNum);</span><br><span class="line">printDocumentInfo(doc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h4><p>查询到匹配的文档后，需要对匹配的内容进行突出展现，最直接的方式就是对匹配的内容高亮显示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Formatter formatter = <span class="keyword">new</span> SimpleHTMLFormater(<span class="string">"&lt;font color='red'&gt;"</span>, <span class="string">"&lt;/font&gt;"</span>);</span><br><span class="line">Scorer scorer = <span class="keyword">new</span> QueryScorer(query);</span><br><span class="line">Highlighter highLight = <span class="keyword">new</span> Highlighter(formatter, scorer);</span><br><span class="line">Fragmenter fragmenter = <span class="keyword">new</span> SimpleFragmenter(<span class="number">20</span>);</span><br><span class="line">highLight.setTextFragmenter(fragmenter);</span><br><span class="line">String hi = highLight.getBestFragmenter(analyzer, <span class="string">"introduce"</span>, doc.get(<span class="string">"introduce"</span>));</span><br></pre></td></tr></table></figure></p><h4 id="中文分词"><a href="#中文分词" class="headerlink" title="中文分词"></a>中文分词</h4><p>Lucene 提供的标准中文分词器 StandardAnalyzer 只能够进行简单的一元分词。<br>常用的中文分词器包括 Lucene 自带的中日韩文分词器 CJKAnalyzer，国内也有一些开源的中文分词器，包括 IK 分词、MM 分词、以及庖丁分词、imdict 分词器等。<br>假设有下面一段文字：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String zhContent = <span class="string">"我是一个中国人，我热爱我的国家"</span>;</span><br></pre></td></tr></table></figure></p><p>分词之后，通过下面一段代码可以将分词的结果打印输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"\n 分词器："</span> + analyze.getClass());</span><br><span class="line">TokenStream tokenStream = analyze.tokenStream(<span class="string">"content"</span>, <span class="keyword">new</span> StringReader(text));</span><br><span class="line">Token token = tokenStream.next();</span><br><span class="line"><span class="keyword">while</span> (token != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(token);</span><br><span class="line">token = tokenStream.next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分词器</span></span><br><span class="line">Analyzer standardAnalyzer = <span class="keyword">new</span> StandardAnalyzer(Version.LUCENE_CURRENT);</span><br><span class="line">Analyzer cjkAnalyzer = <span class="keyword">new</span> CJKAnalyzer();</span><br><span class="line">Analyzer ikAnalyzer = <span class="keyword">new</span> IKAnalyzer();</span><br><span class="line">Analyzer mmAnalyzer = <span class="keyword">new</span> MMAnalyzer();</span><br></pre></td></tr></table></figure></p><h4 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h4><p>Lucene 的索引是由段（segment）组成的，每个段可能又包含多个索引文件，即每个段包含了一个或多个 Document；段结构使得 Lucene 可以很好地支持增量索引，新增的 Document 将被添加到新的索引段当中。<br>一般来说，操作系统对于进程打开的文件句柄是有限的，当一个进程打开太多的文件时，会抛出 too many open files 异常，并且执行搜索任务时，Lucene 必须分别搜索每个段，然后将各个段的搜索结果合并，这样查询的性能就会降低。</p><blockquote><p>一般来说，在分布式环境下，会安排专门的集群来生成索引，并且生成索引的集群不负责处理前台的查询请求。当索引生成以后，通过索引优化，对索引的段进行合并。合并完以后，将生成好的索引文件分发到提供查询服务的机器供前台应用查询。</p></blockquote><h4 id="分布式扩展"><a href="#分布式扩展" class="headerlink" title="分布式扩展"></a>分布式扩展</h4><p>与其他应用不同的是，搜索应用大部分场景都能够接受一定时间内的数据延迟，对于数据一致性的要求并不那么高，大部分情况下只要能保障数据的最终一致性，可以容忍一定时间上的数据不同步。</p><h3 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h3><p>Solr 是一个基于 Lucene 、功能强大的搜索引擎工具，它对 Lucene 进行了扩展，提供一系列功能强大的 HTTP 操作接口，支持通过 Data Scheme 来定义字段、类型和设置文本分析，使得用户可以通过 HTTP POST 请求，向服务器提交 Document，生成索引，以及进行索引的更新和删除操作。对于复杂的查询条件，Solr 提供了强大的可配置能力，以及功能完善的后台管理系统。</p><h4 id="Solr-的配置"><a href="#Solr-的配置" class="headerlink" title="Solr 的配置"></a>Solr 的配置</h4><p>修改 Tomcat 的 conf/server.xml 中的 Connector 配置，将 URIEncoding 编码设置为 UTF-8，否则中文将会乱码，从而导致搜索查询不到结果。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag"><span class="attr">redirectPort</span>=<span class="string">"8443"</span> <span class="attr">URIEncoding</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>将 Solr 的 dist 目录下的 solr-{version}.war 包复制到 tomcat 的 webapps 目录下，并且重命名为 solr.war。<br>配置 Solr 的 home 目录，包括 scheme 文件、solrconfig 文件及索引文件。</p><h4 id="构建索引-1"><a href="#构建索引-1" class="headerlink" title="构建索引"></a>构建索引</h4><h4 id="条件查询-1"><a href="#条件查询-1" class="headerlink" title="条件查询"></a>条件查询</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="SOA" scheme="http://yeonsea.club/tags/SOA/"/>
    
  </entry>
  
  <entry>
    <title>互联网安全架构</title>
    <link href="http://yeonsea.club/2019/09/11/%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84/"/>
    <id>http://yeonsea.club/2019/09/11/互联网安全架构/</id>
    <published>2019-09-11T02:18:19.000Z</published>
    <updated>2019-09-18T06:40:16.452Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>随着移动互联网的兴起，以及 RESTful 和 Web Service 等技术的大规模使用，HTTP 协议因其使用方便及跨平台的特性，在 Web 开发和 SOA 领域得到了广泛使用。但其所涵盖的信息，大都是未经加密的明文，信息获取门槛的降低，也为应用架构的安全性与稳定性带来了挑战。</p></blockquote><h2 id="常见的-Web-攻击手段"><a href="#常见的-Web-攻击手段" class="headerlink" title="常见的 Web 攻击手段"></a>常见的 Web 攻击手段</h2><p>XSS, CSRF, SQL注入更多需要从开发流程上来予以保障，而DDoS，攻击手段多样，产生的影响及危害巨大。</p><h3 id="XSS-攻击"><a href="#XSS-攻击" class="headerlink" title="XSS 攻击"></a>XSS 攻击</h3><p>跨站脚本攻击(Cross Site Scripting)</p><h4 id="XSS-原理"><a href="#XSS-原理" class="headerlink" title="XSS 原理"></a>XSS 原理</h4><p>表单，URL中带有恶意脚本</p><h4 id="XSS-防范"><a href="#XSS-防范" class="headerlink" title="XSS 防范"></a>XSS 防范</h4><p>XSS 之所以会发生，是因为用户输入的数据变成了代码。因此，我们需要对用户输入的数据进行HTML转义处理。<br>如今很多开源的开发框架本身默认就提供HTML代码转义的功能，如流行的jstl,struts等，不需要开发人员再进行过多的开发。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">escapeXml=&quot;true&quot;</span><br></pre></td></tr></table></figure></p><h3 id="CRSF-攻击"><a href="#CRSF-攻击" class="headerlink" title="CRSF 攻击"></a>CRSF 攻击</h3><p>跨站请求伪造(cross site request forgery)，是一种对网站的恶意利用。<br><strong>XSS 利用的是站点内的信任用户，而CSRF则是通过伪装来自受信任用户的请求来利用受信任的网站。</strong></p><h4 id="CRSF-攻击原理"><a href="#CRSF-攻击原理" class="headerlink" title="CRSF 攻击原理"></a>CRSF 攻击原理</h4><p>受害者只需要做下面两件事情，攻击者就能够完成CSRF攻击：</p><ul><li>登录受信任站点A，并在本地生成cookie;</li><li>在不登出站点A(清除站点A的cookie)的情况下，访问恶意站点B</li></ul><p><strong>很多情况下所谓的恶意站点，很有可能是一个存在其他漏洞(如XSS)的受信任且被很多人访问的站点，这样，普通用户可能在不知不觉中便成为了受害者。</strong></p><h4 id="攻击举例"><a href="#攻击举例" class="headerlink" title="攻击举例"></a>攻击举例</h4><p>银行转账<br><strong>正常银行的交易付款会有USB key，验证码，登录密码和支付密码等一系列屏障，流程上复杂的多，安全系数也高得多。</strong></p><h4 id="CSRF-的防御"><a href="#CSRF-的防御" class="headerlink" title="CSRF 的防御"></a>CSRF 的防御</h4><ul><li>将 cookie 设置为 HttpOnly<br>在Java的Servlet的API中设置cookie为HostOnly的代码如下</li></ul><p><code>response.setHeader(“Set-Cookie”, “cookiename=cookievalue;HttpOnly&quot;);</code></p><ul><li>增加 token<br>攻击者可以在不知道用户验证信息的情况下直接利用用户的cookie来通过安全验证。由此可知，抵御CSRF攻击的关键在于：在请求中放入攻击者所不能伪造的信息。<br>token 的值通过服务端生成，表单提交后token的值通过post请求与参数一同带到服务端，每次会话可以使用相同的token，会话过期，则token失效，攻击者无法获取到token，也就无法伪造请求。<br>在 session 中添加 token 的实现代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpSesssion session = request.getSession();</span><br><span class="line">Object token = session.getAttribute(<span class="string">"_token"</span>);</span><br><span class="line"><span class="keyword">if</span> (token == <span class="keyword">null</span> || <span class="string">""</span>.equals(token)) &#123;</span><br><span class="line">session.setAttribute(<span class="string">"_token"</span>, UUID.randomUUID().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 Referer 识别<br>根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。在通常情况下，访问一个安全受限的页面的请求都来自于同一个网站。</li></ul><p><code>String referer = request.getHeader(&quot;Referer&quot;);</code></p><h3 id="SQL-注入攻击"><a href="#SQL-注入攻击" class="headerlink" title="SQL 注入攻击"></a>SQL 注入攻击</h3><blockquote><p>所谓 SQL 注入，就是通过把 SQL 命令伪装成正常的 HTTP 请求参数，传递到服务端，欺骗服务器最终执行恶意的 SQL 命令，达到入侵目的。</p></blockquote><h4 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h4><h4 id="SQL-注入的防范"><a href="#SQL-注入的防范" class="headerlink" title="SQL 注入的防范"></a>SQL 注入的防范</h4><ul><li>使用预编译语句  PreparedStatement</li><li>使用 ORM 框架  防止SQL注入的关键在于对一些关键字符进行转义 需要一些简单的配置</li><li>避免密码明文存放  哈希加盐</li><li>处理好相应的异常  后台的系统异常，很可能包含了一些如服务器版本、数据库版本、编程语言等信息，甚至是数据库连接的地址与用户名密码，攻击者可以按图索骥，找到对应版本的服务器漏洞或者数据库漏洞进行攻击。<h3 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h3><blockquote><p>在上网的过程中，我们经常会将一些图片、压缩包之类的文件上传到远端服务器进行保存。文件上传攻击指的是恶意攻击者利用一些站点没有对文件的类型做很好的检验，上传了可以执行的文件或者脚本，并且通过脚本获得服务器上响应的权利，或者是通过诱导外部用户访问，下载上传的病毒或木马文件，达到攻击的目的。<br>很多类型的文件，起始的几个字节内容是固定的，因此，根据这几个字节的内容，就可以确定文件类型，这几个字节也被称为“魔数”。</p></blockquote></li><li>通过魔数来判断文件类型</li><li>imagemagick 针对图片处理的开发工具包  没有提供 jni 对应的头文件(对缩放好的图像进行保存的图片水印生成，锐化，截取，图像格式转换等一系列复杂的操作)</li><li>jmagic  Java 通过它对imagemagick进行调用 (so文件放在/usr/lib下，用jar进行调用)</li></ul><p>代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取文件头</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getFileHeader</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 这里需要注意的是，每个文件的魔数的长度都不相同，因此需要使用 startwith</span></span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">28</span>];</span><br><span class="line">InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">inputStream = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">inputStream.read(b, <span class="number">0</span>, <span class="number">28</span>);</span><br><span class="line">inputStream.close();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bytes2hex(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断文件类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FileType <span class="title">getType</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String fileHead = getFileHeader(filePath);</span><br><span class="line"><span class="keyword">if</span> (fileHead == <span class="keyword">null</span> || fileHead.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">fileHead = fileHead.toUpperCase();</span><br><span class="line">FileType[] fileTypes = FileType.values();</span><br><span class="line"><span class="keyword">for</span> (FileType type : fileTypes) &#123;</span><br><span class="line"><span class="keyword">if</span> (fileHead.startsWith(type.getValue())) &#123;</span><br><span class="line"><span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="DDoS-攻击"><a href="#DDoS-攻击" class="headerlink" title="DDoS 攻击"></a>DDoS 攻击</h3><p>Distribute Denial of Service 分布式拒绝服务攻击</p><h4 id="SYN-Flood"><a href="#SYN-Flood" class="headerlink" title="SYN Flood"></a>SYN Flood</h4><p>SYN Flood 利用了TCP协议三次握手的过程来达成攻击的目的。攻击者伪造大量的IP地址给服务器发送SYN报文，但是由于伪造的IP地址几乎不可能存在，也就不可能从客户端得到任何回应，服务端将维护一个非常大的半连接等待列表，并且不断对这个列表中的IP地址进行遍历和重试，占用了大量的系统资源。<br>更为严重的是，由于服务器资源有限，大量的恶意客户端信息占满了服务器的等待队列，导致服务器不再接收新的SYN请求，正常用户无法完成三次握手与服务器进行通信，这便是SYN Flood攻击。</p><h4 id="DNS-Query-Flood"><a href="#DNS-Query-Flood" class="headerlink" title="DNS Query Flood"></a>DNS Query Flood</h4><p>是 UDP Flood 攻击的一种变形，攻击方式是向被攻击的服务器发送海量的域名解析请求。</p><h4 id="CC-攻击"><a href="#CC-攻击" class="headerlink" title="CC 攻击"></a>CC 攻击</h4><p>Challenge Collapsar 是基于应用层 HTTP 协议发起的 DDoS 攻击，也称为 HTTP Flood。<br><strong>控制大量肉鸡或HTTP代理，有意避开CDN以及分布式缓存，多次DB，从而拖垮后端的业务处理系统。</strong></p><h3 id="其他攻击手段"><a href="#其他攻击手段" class="headerlink" title="其他攻击手段"></a>其他攻击手段</h3><p>DNS域名劫持、CDN回源攻击、服务器权限提升、缓冲区溢出，平台或软件漏洞。</p><h2 id="常用的安全算法"><a href="#常用的安全算法" class="headerlink" title="常用的安全算法"></a>常用的安全算法</h2><h3 id="数字摘要"><a href="#数字摘要" class="headerlink" title="数字摘要"></a>数字摘要</h3><p>也称消息摘要，由一个单向 Hash 函数对消息进行计算而产生。<br><strong>一个 Hash 函数的好坏是由发生碰撞的概率决定的，如果攻击者能够轻易地构造出两个具有相同 Hash 值的消息，那么这样的 Hash 函数是很危险的。可以认为，摘要的长度越长，算法也就越安全。</strong></p><p>摘要的特点:</p><ul><li>无论输入的消息有多长，计算出来的消息摘要长度总是固定的。</li><li>一般只要输入的消息不同，对其进行摘要以后产生的摘要消息也不相同，但输入相同必会产生相同的输出。</li><li>由于消息摘要并不包含原文的信息，因此只能进行正向的信息摘要，而无法从摘要中恢复出原来的消息，甚至根本就找不到任何与原消息相关的信息。</li></ul><h4 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h4><p>Message Digest Algorithm 5(信息摘要算法5)，是数字摘要算法的一种实现，用于确保信息传输完整性和一致性，摘要长度为 128 位。<br>MD5由MD4，MD3，MD2改进而来，主要增强了算法复杂度和不可逆性。<br>基于 Java 的 MD5 算法的使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] testMD5(String content) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">MessageDigest md = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = md.digest(content.getBytes(<span class="string">"utf8"</span>));</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h4><p>Secure Hash Algorithm，即安全散列算法。<br>SHA1 是基于 MD4 算法的，现在已成为公认的最安全的散列算法之一。<br><strong>SHA-1 算法生成的摘要信息长度为160位，由于生成的摘要信息更长，运算的过程更加复杂，在相同的硬件上，SHA-1 的运行速度比MD5更慢，但是也更为安全。</strong>  </p><p>基于 Java 的 SHA-1 算法的使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] testSHA1(String content) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">MessageDigest md = MessageDigest.getInstance(<span class="string">"SHA-1"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = md.digest(content.getBytes(<span class="string">"utf8"</span>));</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>由于计算出的摘要转换成字符串，可能会生成一些无法显示和网络传输的控制字符，因此，需要对生成的摘要字符串进行编码，常用的编码方式包括十六进制编码与 Base64 编码。</em></p><h4 id="十六进制编码"><a href="#十六进制编码" class="headerlink" title="十六进制编码"></a>十六进制编码</h4><p>基于 Java 的十六进制编码与解码的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">bytes2hex</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">StringBuilder hex = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="keyword">byte</span>[i];</span><br><span class="line"><span class="keyword">boolean</span> negative = <span class="keyword">false</span>; <span class="comment">// 是否为负数</span></span><br><span class="line"><span class="keyword">if</span> (b &lt; <span class="number">0</span>) negative = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">int</span> inte = Math.abs(b);</span><br><span class="line"><span class="keyword">if</span> (negative) inte = inte | <span class="number">0x80</span>; </span><br><span class="line"><span class="comment">// 负数会转成正数（最高位的负号变成数值计算），再转十六进制</span></span><br><span class="line">String temp = Integer.toHexString(inte &amp; <span class="number">0xFF</span>); <span class="comment">// &amp;0xff可以将高的24位置为0，低8位保持原样</span></span><br><span class="line"><span class="keyword">if</span> (temp.length() == <span class="number">1</span>) &#123;</span><br><span class="line">hex.append(<span class="string">"0"</span>);</span><br><span class="line">&#125;</span><br><span class="line">hex.append(temp.toLowerCase());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hex.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] hex2bytes(String hex) &#123;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[hex.length()/<span class="number">2</span>]; <span class="comment">// 8位二进制可以转换为两位16进制</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hex.length(); i = i + <span class="number">2</span>) &#123;</span><br><span class="line">String subStr = hex.substring(i, i + <span class="number">2</span>);</span><br><span class="line"><span class="keyword">boolean</span> negative = <span class="keyword">false</span>; <span class="comment">// 是否为负数</span></span><br><span class="line"><span class="keyword">int</span> inte = Integer.parseInt(subStr, <span class="number">16</span>);</span><br><span class="line"><span class="keyword">if</span> (inte &gt; <span class="number">127</span>) negative = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (inte == <span class="number">128</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> = -<span class="number">128</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line">inte = <span class="number">0</span> - (inte &amp; <span class="number">0x7F</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)inte;</span><br><span class="line">bytes[i/<span class="number">2</span>] = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>由于 Java 中没有无符号整型，解码时需要先将符号位进行还原，再对数值进行转换。</strong></p><h4 id="Base64-编码"><a href="#Base64-编码" class="headerlink" title="Base64 编码"></a>Base64 编码</h4><p>是一个基于 64 个可打印字符来表示二进制数据的方法，每6位为一个单元。<br>Base64编码要求把3个8位字节（38=24）转化为4个6位的字节（46=24），之后在6位的前面补两个0，形成8位一个字节的形式。<br><strong>Base64不是一种加密算法，仅仅是一种编码算法而已。它可以将一组二进制信息编码成可打印的字符，在网络上传输与展现。</strong></p><p>基于 Java 的 Base64 算法的使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">byte2base64</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">BASE64Encoder base64Encoder = <span class="keyword">new</span> BASE64Encoder();</span><br><span class="line"><span class="keyword">return</span> base64Encoder.encode(bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] base642byte(String base64) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">BASE64Decoder base64Decoder = <span class="keyword">new</span> BASE64Decoder();</span><br><span class="line"><span class="keyword">return</span> base64Decoder.decodeBuffer(base64);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="彩虹表破解-Hash-算法"><a href="#彩虹表破解-Hash-算法" class="headerlink" title="彩虹表破解 Hash 算法"></a>彩虹表破解 Hash 算法</h4><p>Rainbow Table 法是一种破解哈希算法的技术，从原理上来说能够对任何一种 Hash 算法进行攻击。<br>采用穷举法，理论上彩虹的大小是可以无穷大的。</p><h3 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h3><p>加密和解密方事先都必须知道加密的密钥。</p><blockquote><p>对称加密算法的特点是算法公开、计算量小、加密速度快、加密速率高。优势在于加解密的高速度和使用长密钥时的难破解性，但是，对称加密算法的安全性依赖于密钥，泄露密钥就意味着任何人都可以对加密的密文进行解密。</p></blockquote><h4 id="DES-算法"><a href="#DES-算法" class="headerlink" title="DES 算法"></a>DES 算法</h4><p>DES 算法属于对称加密算法，明文按 64 位进行分组，密钥长 64 位，但事实上只有 56 位参与DES运算(8的倍数位为校验位)，分组后的明文和56位的密钥按位替代或交换的方法形成密文。<br>3DES 是DES向AES过渡的加密算法，它使用3条56位的密钥对数据进行3次加密，是DES的一个更安全的变形。<br>基于 Java 的 DES 算法的使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 生成 DES 密钥</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">genKeyDES</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">KeyGenerator keyGen = keyGenerator.getInstance(<span class="string">"DES"</span>);</span><br><span class="line">keyGen.init(<span class="number">56</span>);</span><br><span class="line">SecretKey key = keyGen.generateKey();</span><br><span class="line">String base64Str = byte2base64(key.getEncoded());</span><br><span class="line"><span class="keyword">return</span> base64Str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecretKey <span class="title">loadKeyDES</span><span class="params">(String base64Key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = base642byte(base64Key);</span><br><span class="line">SecretKey key = <span class="keyword">new</span> SecretKeySpec(bytes, <span class="string">"DES"</span>);</span><br><span class="line"><span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 加密与解密</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encryptDES(<span class="keyword">byte</span>[] source, SecretKey key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">Cipher cipher = Cipher.getInstance(<span class="string">"DES"</span>);</span><br><span class="line">cipher.init(Cipher.ENCRYPT_MODE, key);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = cipher.doFinal(source);</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decryptDES(<span class="keyword">byte</span>[] source, SecretKey key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">Cipher cipher = Cipher.getInstance(<span class="string">"DES"</span>);</span><br><span class="line">cipher.init(Cipher.DECRYPT_MODE, key);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = cipher.doFinal(source);</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="AES-算法"><a href="#AES-算法" class="headerlink" title="AES 算法"></a>AES 算法</h4><p>Advanced Encryption Standard，即高级加密标准。<br>AES 算法作为新一代的数据加密标准，汇聚了强安全性、高性能、高效率、易用和灵活等优点，设计有三个密钥长度(128，192，256位)，比 DES 算法的加密强度更高，更为安全。<br>基于 Java 的AES 算法的使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 生成 AES 密钥</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">genKeyAES</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">KeyGenerator keyGen = keyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">keyGen.init(<span class="number">128</span>);</span><br><span class="line">SecretKey key = keyGen.generateKey();</span><br><span class="line">String base64Str = byte2base64(key.getEncoded());</span><br><span class="line"><span class="keyword">return</span> base64Str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecretKey <span class="title">loadKeyAES</span><span class="params">(String base64Key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = base642byte(base64Key);</span><br><span class="line">SecretKey key = <span class="keyword">new</span> SecretKeySpec(bytes, <span class="string">"AES"</span>);</span><br><span class="line"><span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 加密与解密</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encryptAES(<span class="keyword">byte</span>[] source, SecretKey key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">Cipher cipher = Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">cipher.init(Cipher.ENCRYPT_MODE, key);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = cipher.doFinal(source);</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decryptDES(<span class="keyword">byte</span>[] source, SecretKey key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">Cipher cipher = Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">cipher.init(Cipher.DECRYPT_MODE, key);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = cipher.doFinal(source);</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>由于美国对于加密软件出口的控制，如果使用192位和256位的密钥，则需要另外下载无政策和司法限制的文件，否则程序运行时会出现异常。</strong></p><h3 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h3><p>如果使用公钥对数据进行加密，只有用对应的私钥才能进行解密，而如果使用私钥对数据进行加密，那么只有用对应的公钥才能进行解密。因为加密和解密使用的是两个不同的密钥，所以这种算法称为非对称加密算法。</p><h4 id="RSA-算法"><a href="#RSA-算法" class="headerlink" title="RSA 算法"></a>RSA 算法</h4><blockquote><p>RSA 是目前最有影响力的非对称加密算法，它能够抵抗到目前为止已知的所有密码攻击，已被 ISO 推荐为公钥数据加密标准。<br>RSA 算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但反过来对其乘积进行因式分解却及其困难，因此可以将乘积公开作为加密密钥。<br>基于Java 的 RSA 算法的使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 生成公钥与私钥</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KeyPair <span class="title">getKeyPair</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">keyPairGenerator.initialize(<span class="number">512</span>);</span><br><span class="line">KeyPair keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line"><span class="keyword">return</span> keyPair;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPublicKey</span><span class="params">(KeyPair keyPair)</span> </span>&#123;</span><br><span class="line">PrivateKey publicKey = KeyPair.getPublic();</span><br><span class="line"><span class="keyword">byte</span>[] bytes = publicKey.getEncoded();</span><br><span class="line"><span class="keyword">return</span> byte2base64(bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPrivateKey</span><span class="params">(KeyPair keyPair)</span> </span>&#123;</span><br><span class="line">PrivateKey privateKey = KeyPair.getPrivate();</span><br><span class="line"><span class="keyword">byte</span>[] bytes = privateKey.getEncoded();</span><br><span class="line"><span class="keyword">return</span> byte2base64(bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将 String 类型的密钥转换为 PublicKey 和 PrivateKey 对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PublicKey <span class="title">string2PublicKey</span><span class="params">(String pubStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] keyBytes = base642byte(pubStr);</span><br><span class="line">X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(keyBytes);</span><br><span class="line">KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">PublicKey publickey = KeyFactory.generatePublic(keySpec);</span><br><span class="line"><span class="keyword">return</span> publicKey;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PrivateKey <span class="title">string2PrivateKey</span><span class="params">(String priStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] keyBytes = base642byte(priStr);</span><br><span class="line">X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(keyBytes);</span><br><span class="line">KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">PrivateKey privatekey = KeyFactory.generatePrivate(keySpec);</span><br><span class="line"><span class="keyword">return</span> privatekey;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用公钥加密，私钥解密</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] publicEncrypt(<span class="keyword">byte</span>[] content, publicKey) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = cipher.doFinal(content);</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] privateEncrypt(<span class="keyword">byte</span>[] content, privateKey) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = cipher.doFinal(content);</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><blockquote><p>签名认证是非对称加密技术与数字摘要技术的综合运用，指的是将通信内容的摘要信息使用发送者的私钥进行加密，然后将密文与原文一起传输给信息的接收者，接受者通过发送者的公钥解密被加密的摘要信息，然后使用与发送者相同的摘要算法，对接收到的内容采用相同的方式产生摘要串，与解密的摘要串进行对比，如果相同，则说明接收到的内容是完整的，在传输过程中没有受到第三方篡改，否则说明通信内容已被第三方修改。</p></blockquote><h4 id="MD5withRSA"><a href="#MD5withRSA" class="headerlink" title="MD5withRSA"></a>MD5withRSA</h4><p>算法实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] sign(<span class="keyword">byte</span>[] content, PrivateKey privateKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">MessageDigest md = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = md.digest(content);</span><br><span class="line">Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">cipher.init(Cipher.ENCRYPT_MODE, privateKey);</span><br><span class="line"><span class="keyword">byte</span>[] encryptBytes = cipher.doFinal(bytes);</span><br><span class="line"><span class="keyword">return</span> encryptBytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(<span class="keyword">byte</span>[] content, <span class="keyword">byte</span>[] sign, PublicKey publicKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">MessageDigest md = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = md.digest(content);</span><br><span class="line">Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">cipher.init(Cipher.DECRYPT_MODE, publicKey);</span><br><span class="line"><span class="keyword">byte</span>[] decryptBytes = cipher.doFinal(sign);</span><br><span class="line"><span class="keyword">if</span> (byte2base64(decryptBytes).equals(byte2base64(bytes))) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>基于 Java 的 Signature API 的使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] sign(<span class="keyword">byte</span>[] content, PrivateKey privateKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">Signature signature = Signature.getInstance(<span class="string">"MD5withRSA"</span>);</span><br><span class="line">signature.initSign(privateKey);</span><br><span class="line">signature.update(content);</span><br><span class="line"><span class="keyword">return</span> signature.sign();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(<span class="keyword">byte</span>[] content, <span class="keyword">byte</span>[] sign, PublicKey publicKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Signature signature = Signature.getInstance(<span class="string">"MD5withRSA"</span>);</span><br><span class="line">signature.initSign(publicKey);</span><br><span class="line">signature.update(content);</span><br><span class="line"><span class="keyword">return</span> signature.verify(sign);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="SHA1withRSA"><a href="#SHA1withRSA" class="headerlink" title="SHA1withRSA"></a>SHA1withRSA</h4><p>算法实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] sign(<span class="keyword">byte</span>[] content, PrivateKey privateKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">MessageDigest md = MessageDigest.getInstance(<span class="string">"SHA1"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = md.digest(content);</span><br><span class="line">Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">cipher.init(Cipher.ENCRYPT_MODE, privateKey);</span><br><span class="line"><span class="keyword">byte</span>[] encryptBytes = cipher.doFinal(bytes);</span><br><span class="line"><span class="keyword">return</span> encryptBytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(<span class="keyword">byte</span>[] content, <span class="keyword">byte</span>[] sign, PublicKey publicKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">MessageDigest md = MessageDigest.getInstance(<span class="string">"SHA1"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = md.digest(content);</span><br><span class="line">Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">cipher.init(Cipher.DECRYPT_MODE, publicKey);</span><br><span class="line"><span class="keyword">byte</span>[] decryptBytes = cipher.doFinal(sign);</span><br><span class="line"><span class="keyword">if</span> (byte2base64(decryptBytes).equals(byte2base64(bytes))) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>基于 Java 的 Signature API 的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] sign(<span class="keyword">byte</span>[] content, PrivateKey privateKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">Signature signature = Signature.getInstance(<span class="string">"SHA1withRSA"</span>);</span><br><span class="line">signature.initSign(privateKey);</span><br><span class="line">signature.update(content);</span><br><span class="line"><span class="keyword">return</span> signature.sign();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(<span class="keyword">byte</span>[] content, <span class="keyword">byte</span>[] sign, PublicKey publicKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Signature signature = Signature.getInstance(<span class="string">"SHA1withRSA"</span>);</span><br><span class="line">signature.initSign(publicKey);</span><br><span class="line">signature.update(content);</span><br><span class="line"><span class="keyword">return</span> signature.verify(sign);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>Digital Certificate 也称电子证书。集合了多种密码学的加密算法，证书自身带有公钥信息，可以完成相应的加密，解密操作，同时，还拥有自身信息的数字签名，可以鉴别证书的颁发机构，以及证书内容的完整性。由于证书本身含有用户的认证信息，因此可以作为用户身份识别的依据。<br>内容：</p><ul><li>对象的名称(人，组织，服务器)</li><li>证书的过期时间</li><li>证书的颁发机构(谁为证书担保)</li><li>证书颁发机构对证书信息的数字签名</li><li>签名算法</li><li>对象的公钥</li></ul><p><strong>数字证书一般采用 Base64 编码后再进行存储</strong></p><h4 id="X-509"><a href="#X-509" class="headerlink" title="X.509"></a>X.509</h4><p>提供了一种标准的方式，将证书信息规范地存储到一系列可解析的字段当中。</p><h4 id="证书签发"><a href="#证书签发" class="headerlink" title="证书签发"></a>证书签发</h4><p>需要由数字证书认证机构(Certificate Authority，CA)来进行颁发，只有经过 CA 颁发的数字证书在网络中才具备可认证性。</p><blockquote><p>数字证书的签发过程实际上就是对数字证书的内容，包括证书代表对象的公钥进行数字签名，而验证证书的过程，实际上是验证证书的数字签名，包含了对证书有效期的验证。</p></blockquote><h4 id="证书检验"><a href="#证书检验" class="headerlink" title="证书检验"></a>证书检验</h4><p>客户端接收到数字证书时，首先会检查证书的认证机构，如果该机构是权威的证书认证机构，则通过该权威认证机构的根证书获得证书颁发者的公钥，通过该公钥，对证书的数字签名进行检验，并验证证书的有效时间是否过期。</p><blockquote><p>根证书是证书认证机构给自己颁发的数字证书，是证书信任链的起始点，安装根证书则意味着对这个证书认证机构的信任。<br>证书链的终点就是根证书。</p></blockquote><h4 id="证书管理"><a href="#证书管理" class="headerlink" title="证书管理"></a>证书管理</h4><p>任何机构或者个人都可以申请数字证书。</p><h5 id="keytool"><a href="#keytool" class="headerlink" title="keytool"></a>keytool</h5><p>是 Java 的数字证书管理工具，用于数字证书的生成、导入、导出与撤销等操作。</p><ol><li>构建自签名证书</li><li>证书导出</li><li>导出CSR</li><li>导入数字证书<h5 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h5>OpenSSL 包含一个开源的 SSL 协议的实现，虽然 OpenSSL 使用 SSL 作为其名字的重要组成部分，到实现的功能却远远超出了 SSL 协议本身。<br>包含三个组成部分：</li></ol><ul><li>SSL协议库</li><li>密码算法库</li><li>各种与之相关的应用程序</li></ul><ol><li>安装</li><li>配置</li><li>生成 OpenSSL 根证书</li><li>OpenSSL 签发服务端证书</li><li>OpenSSL 签发客户端证书</li></ol><h5 id="证书的使用"><a href="#证书的使用" class="headerlink" title="证书的使用"></a>证书的使用</h5><p>证书除包含一些认证信息以外，还包含了证书持有人的公钥，外界获得证书以后，可以使用对相关信息进行加密，而信息接收方则使用私钥进行解密。</p><h2 id="摘要认证"><a href="#摘要认证" class="headerlink" title="摘要认证"></a>摘要认证</h2><blockquote><p>相对于基于 TCP 协议层面的通信方式，针对 HTTP 协议的攻击门槛更低，因此，基于 HTTP 协议的 Web 与 SOA 架构，在应用的安全性方面需要更加重视。</p></blockquote><h3 id="摘要认证的原理"><a href="#摘要认证的原理" class="headerlink" title="摘要认证的原理"></a>摘要认证的原理</h3><blockquote><p>鉴于使用 HTTPS 性能上的成本以及需要额外申请 CA 证书，在这种情况下，一般采用对参数和响应进行摘要的方法，即能够满足需求。<br>由于传递端和接收端都认为 HTTP 协议的请求参数是无序的，因此客户端与服务端双方需要约定好参数的排序方式。请求的参数经过排序后，再将参数名称和值经过一定的策略组织起来，加上一个密钥 secret，也就是所谓的盐，然后通过约定的摘要算法生成数字摘要，传递给服务端。<br>但是，摘要的安全性取决于secret的安全性。</p></blockquote><h3 id="摘要认证的实现"><a href="#摘要认证的实现" class="headerlink" title="摘要认证的实现"></a>摘要认证的实现</h3><h4 id="客户端参数摘要生成"><a href="#客户端参数摘要生成" class="headerlink" title="客户端参数摘要生成"></a>客户端参数摘要生成</h4><p>基于 Java 客户端参数摘要生成的部分关键代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getDigest</span><span class="params">(Map&lt;String, String&gt; params)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String secret = <span class="string">"abcdefjhijklmn"</span>;</span><br><span class="line">Set&lt;String&gt; keySet = params.keySet();</span><br><span class="line"><span class="comment">// 使用 treeSet 排序</span></span><br><span class="line">TreeSet&lt;String&gt; sortSet = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">sortSet.addAll(keySet);</span><br><span class="line">String keyvalueStr = <span class="string">""</span>;</span><br><span class="line">Iterator&lt;String&gt; it = sortSet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">String key = it.next();</span><br><span class="line">String value = params.get(key);</span><br><span class="line">keyvalueStr += key + value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">keyvalueStr += secret;</span><br><span class="line">String base64Str = byte2base64(getMD5(keyvalueStr));</span><br><span class="line"><span class="keyword">return</span> base64Str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="服务端参数摘要校验"><a href="#服务端参数摘要校验" class="headerlink" title="服务端参数摘要校验"></a>服务端参数摘要校验</h4><p>基于 Java 服务端参数摘要校验的部分关键代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(Map params, String digest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String secret = <span class="string">"abcdefjhijklmn"</span>;</span><br><span class="line">Set&lt;String&gt; keySet = params.keySet();</span><br><span class="line"><span class="comment">// 使用 treeSet 排序</span></span><br><span class="line">TreeSet&lt;String&gt; sortSet = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">sortSet.addAll(keySet);</span><br><span class="line">String keyvalueStr = <span class="string">""</span>;</span><br><span class="line">Iterator&lt;String&gt; it = sortSet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">String key = it.next();</span><br><span class="line">String value = params.get(key);</span><br><span class="line">keyvalueStr += key + value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">keyvalueStr += secret;</span><br><span class="line">String base64Str = byte2base64(getMD5(keyvalueStr));</span><br><span class="line"><span class="keyword">if</span>(base64Str.equals(digest)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="服务端响应摘要生成"><a href="#服务端响应摘要生成" class="headerlink" title="服务端响应摘要生成"></a>服务端响应摘要生成</h4><p>基于 Java 服务端响应摘要生成的部分关键代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getDigest</span><span class="params">(String content)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String secret = <span class="string">"abcdefjhijklmn"</span>;</span><br><span class="line">content += secret;</span><br><span class="line">String base64Str = byte2base64(getMD5(content));</span><br><span class="line"><span class="keyword">return</span> base64Str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="客户端响应摘要校验"><a href="#客户端响应摘要校验" class="headerlink" title="客户端响应摘要校验"></a>客户端响应摘要校验</h4><p>基于 Java 客户端响应摘要校验的部分关键代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String responseContent, String digest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String secret = <span class="string">"abcdefjhijklmn"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = getMD5(responseContent + secret);</span><br><span class="line">String responseDigest = byte2base64(bytes);</span><br><span class="line"><span class="keyword">if</span> (responseDigest.equals(digest)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="签名认证"><a href="#签名认证" class="headerlink" title="签名认证"></a>签名认证</h2><h3 id="签名认证的原理"><a href="#签名认证的原理" class="headerlink" title="签名认证的原理"></a>签名认证的原理</h3><p>类似摘要认证，但签名认证不再加上 secret ，而是直接通过约定的摘要算法来生成数字摘要，并且使用客户端私钥对数字摘要进行加密，将加密的密文传递给服务端。</p><h3 id="签名认证的实现"><a href="#签名认证的实现" class="headerlink" title="签名认证的实现"></a>签名认证的实现</h3><h4 id="客户端参数签名生成"><a href="#客户端参数签名生成" class="headerlink" title="客户端参数签名生成"></a>客户端参数签名生成</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getSign</span><span class="params">(Map&lt;String, String&gt; params)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Set&lt;String&gt; keySet = params.keySet();</span><br><span class="line"><span class="comment">// 使用 treeSet 排序</span></span><br><span class="line">TreeSet&lt;String&gt; sortSet = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">sortSet.addAll(keySet);</span><br><span class="line">String keyvalueStr = <span class="string">""</span>;</span><br><span class="line">Iterator&lt;String&gt; it = sortSet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext) &#123;</span><br><span class="line">String key = it.next();</span><br><span class="line">String value = params.get(key);</span><br><span class="line">keyvalueStr += key + value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] md5Bytes = getMD5(keyvalueStr);</span><br><span class="line">PrivateKey privateKey = AsymmetricalUtil.string2PrivateKey(consumerPrivateKey);</span><br><span class="line"><span class="keyword">byte</span>[] encryptBytes = AsymmetricalUtil.privateEncrypt(md5Bytes, privateKey);</span><br><span class="line">String hexStr = byte2hex(encryptBytes);</span><br><span class="line"><span class="keyword">return</span> hexStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用 Java API 对客户端请求进行数字签名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getSign</span><span class="params">(Map&lt;String, String&gt; params)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Set&lt;String&gt; keySet = params.keySet();</span><br><span class="line"><span class="comment">// 使用 treeSet 排序</span></span><br><span class="line">TreeSet&lt;String&gt; sortSet = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">sortSet.addAll(keySet);</span><br><span class="line">String keyvalueStr = <span class="string">""</span>;</span><br><span class="line">Iterator&lt;String&gt; it = sortSet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">String key = it.next();</span><br><span class="line">String value = params.get(key);</span><br><span class="line">keyvalueStr += key + value;</span><br><span class="line">&#125;</span><br><span class="line">PrivateKey privateKey = AsymmetricalUtil.string2PrivateKey(consumerPrivateKey);</span><br><span class="line">Signature signature = Signature.getInstance(<span class="string">"MD5withRSA"</span>);</span><br><span class="line">signature.initSign(privateKey);</span><br><span class="line">signature.update(keyvalueStr.getBytes());</span><br><span class="line"><span class="keyword">return</span> byte2hex(signature.sign());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务端参数签名校验"><a href="#服务端参数签名校验" class="headerlink" title="服务端参数签名校验"></a>服务端参数签名校验</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(Map params, String digest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Set&lt;String&gt; keySet = params.keySet();</span><br><span class="line"><span class="comment">// 使用 treeSet 排序</span></span><br><span class="line">TreeSet&lt;String&gt; sortSet = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">sortSet.addAll(keySet);</span><br><span class="line">String keyvalueStr = <span class="string">""</span>;</span><br><span class="line">Iterator&lt;String&gt; it = sortSet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">String key = it.next();</span><br><span class="line">String value = params.get(key);</span><br><span class="line">keyvalueStr += key + value;</span><br><span class="line">&#125;</span><br><span class="line">String hexStr = byte2hex(getMD5(keyvalueStr));</span><br><span class="line">PublicKey publickey = AsymmetricalUtil.string2PublicKey(consumerPublicKey);</span><br><span class="line"><span class="keyword">byte</span>[] decryptBytes = AsymmetricalUtil.publicDecrypt(hex2bytes(digest), publickey);</span><br><span class="line">String decryptDigest = bytes2hex(decryptBytes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(hexStr.equals(decryptDigest)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用 Java 数字签名 API 对客户端进行数字签名校验</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(Map params, String sign)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Set&lt;String&gt; keySet = params.keySet();</span><br><span class="line"><span class="comment">// 使用 treeSet 排序</span></span><br><span class="line">TreeSet&lt;String&gt; sortSet = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">sortSet.addAll(keySet);</span><br><span class="line">String keyvalueStr = <span class="string">""</span>;</span><br><span class="line">Iterator&lt;String&gt; it = sortSet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">String key = it.next();</span><br><span class="line">String value = params.get(key);</span><br><span class="line">keyvalueStr += key + value;</span><br><span class="line">&#125;</span><br><span class="line">PublicKey publickey = AsymmetricalUtil.string2PublicKey(consumerPublicKey);</span><br><span class="line">Signature signature = Signature.getInstance(<span class="string">"MD5withRSA"</span>);</span><br><span class="line">signature.initVerify(publickey);</span><br><span class="line">signature.update(keyvalueStr.getBytes());</span><br><span class="line"><span class="keyword">return</span> signature.verify(hex2bytes(sign));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务端响应签名生成"><a href="#服务端响应签名生成" class="headerlink" title="服务端响应签名生成"></a>服务端响应签名生成</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getSign</span><span class="params">(String content)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] md5Bytes = getMD5(content);</span><br><span class="line">PrivateKey privatekey = AsymmetricalUtil.string2PrivateKey(providePrivateKey);</span><br><span class="line"><span class="keyword">byte</span>[] encryptBytes = AsymmetricalUtil.privateEncrypt(md5Bytes, privateKey);</span><br><span class="line">String hexStr = bytes2hex(encryptBytes);</span><br><span class="line"><span class="keyword">return</span> hexStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用 Java 数字签名 API 生成服务器端响应的数字签名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getSign</span><span class="params">(String content)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">PrivateKey privatekey = AsymmetricalUtil.string2PrivateKey(providePrivateKey);</span><br><span class="line">Signature signature = Signature.getInstance(<span class="string">"MD5withRSA"</span>);</span><br><span class="line">signature.initSign(privateKey);</span><br><span class="line">signature.update(content.getBytes());</span><br><span class="line">String hexStr = bytes2hex(signature.sign());</span><br><span class="line"><span class="keyword">return</span> hexStr;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">#### 客户端响应签名校验</span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String responseContent, String digest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = getMD5(responseContent);</span><br><span class="line">String responseDigest = bytes2hex(bytes);</span><br><span class="line"></span><br><span class="line">PublicKey publickey = AsymmetricalUtil.string2PublicKey(providerPublicKey);</span><br><span class="line"><span class="keyword">byte</span>[] decryptBytes = AsymmetricalUtil.publicDecrypt(hex2bytes(digest), publickey);</span><br><span class="line">String decryptDigest = byte2hex(decryptBytes);</span><br><span class="line"><span class="keyword">if</span>(responseContent.equals(decryptBytes)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用 Java 数字签名 API 对服务端响应数字签名的校验</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String responseContent, String sign)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">PublicKey publickey = AsymmetricalUtil.string2PrivateKey(providePublicKey);</span><br><span class="line">Signature signature = Signature.getInstance(<span class="string">"MD5withRSA"</span>);</span><br><span class="line">signature.initVerify(publickey);</span><br><span class="line">signature.update(content.getBytes());</span><br><span class="line">String hexStr = bytes2hex(responseContent.getBytes());</span><br><span class="line"><span class="keyword">return</span> signature.verify(hex2bytes(sign));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="HTTPS 协议"></a>HTTPS 协议</h2><h3 id="HTTPS-协议原理"><a href="#HTTPS-协议原理" class="headerlink" title="HTTPS 协议原理"></a>HTTPS 协议原理</h3><p>Hypertext Transfer Protocol over Secure Socket Layer，即基于 SSL 的 HTTP 协议。<br>HTTPS 协议在 HTTP 协议与 TCP 协议增加了一层安全层，所有请求和响应数据在经过网络传输之前，都会先进行加密，然后再进行传输。<br>HTTPS 既支持单向认证，也支持双向认证。</p><h3 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL TLS"></a>SSL TLS</h3><p>Secure Sockets Layer，即安全套接层。<br>SSL 协议的优势在于它与应用层协议独立无关，高层的应用协议如 HTTP、SSH、FTP等等，能透明的建立于 SSL 协议之上，在应用层通信之前就已经完成加密算法、通信密钥的协商以及服务端及客户端的认证工作，在此之后所有应用层协议所传输的数据都会被加密，从而保证通信的私密性。<br>SSL 的继任者是 TLS 协议，全称为 Transport Layer Security，即传输层安全协议，是基于 SSL 协议的通用化协议。</p><p>SSL TLS协议均可分为两层：</p><ul><li>Record Protocol 记录协议 建立在可靠的传输协议(如TCP)之上，提供数据封装、加密解密、数据压缩、数据校验等基本功能。</li><li>Handshake Protocol 握手协议 在实际的数据传输开始前，进行加密算法的协商，通过密钥的交换，通信双方身份的认证等工作。</li></ul><blockquote><p>JSSE(Java Security Socket Extension)是 sun 公司为了解决互联网信息安全传输提出的一个解决方案，它实现了 SSL 和 TSL 协议，包含了数据加密、服务器验证、消息完整性和客户端验证等技术。</p></blockquote><p>首先，将生成的客户端私钥和数字证书进行导出，生成 Java 环境可用的 keystore 文件。<br>Java 实现的通信客户端<br>SSLSocket 初始化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String host = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="keyword">int</span> port = <span class="number">1234</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含客户端的私钥与服务端的证书</span></span><br><span class="line">String keystorePath = <span class="string">"/home/user/temp/testssl/client.keystore"</span>;</span><br><span class="line">String trustKeystorePath = <span class="string">"home/user/temp/testssl/ca-trust.keystore"</span>;</span><br><span class="line">String keystorePassword = <span class="string">"123456"</span>;</span><br><span class="line"></span><br><span class="line">SSLContext sslContext = sslContext.getInstance(<span class="string">"SSL"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 密钥库</span></span><br><span class="line">KeyManagerFactory kmf = KeyManagerFactory.getInstance(<span class="string">"sunx509"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信任库</span></span><br><span class="line">TrustManagerFactory tmf = TrustManagerFactory.getInstance(<span class="string">"sunx509"</span>);</span><br><span class="line"></span><br><span class="line">KeyStore keyStore = KeyStore.getInstance(<span class="string">"pkcs12"</span>);</span><br><span class="line">KeyStore trustKeystore = KeyStore.getInstance(<span class="string">"jks"</span>);</span><br><span class="line"></span><br><span class="line">FileInputStream keystoreFis = <span class="keyword">new</span> FileInputStream(keystorePath);</span><br><span class="line">keystore.load(keystoreFis, keystorePassword.toCharArray);</span><br><span class="line"></span><br><span class="line">FileInputStream trustKeystoreFis = <span class="keyword">new</span> FileInputStream(trustKeystorePath);</span><br><span class="line">trustKeystore.load(trustKeystoreFis, keystorePassword.toCharArray());</span><br><span class="line"></span><br><span class="line">kmf.init(keystore, keystorePassword.toCharArray());</span><br><span class="line">tmf.init(trustKeystore);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文初始化</span></span><br><span class="line">sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// SSLSocket 初始化</span></span><br><span class="line">sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket(host, port);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>进行 SSL 通信：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String hello = <span class="string">"hello yeonsea!"</span>;</span><br><span class="line">OutputStream output = sslSocket.getOutputStream();</span><br><span class="line">output.write(hello.getBytes(), <span class="number">0</span>, hello.getBytes().length);</span><br><span class="line">output.flush();</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] inputBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">InputStream input = sslSocket.getInputStream();</span><br><span class="line">input.read(inputBytes);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(inputBytes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Java 实现的通信服务端<br>SSLServerSocket 初始化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">int</span> port = <span class="number">1234</span>;</span><br><span class="line"><span class="comment">// keystore 中包含服务端的私钥与服务端的证书</span></span><br><span class="line">String keystorePath = <span class="string">"/home/user/temp/testssl/server.keystore"</span>;</span><br><span class="line">String trustKeystorePath = <span class="string">"/home/user/temp/testssl/ca-trust.keystore"</span>;</span><br><span class="line">String keystorePassword = <span class="string">"123456"</span>;</span><br><span class="line"></span><br><span class="line">SSLContext sslContext = SSLContext.getInstance(<span class="string">"SSL"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 密钥库</span></span><br><span class="line">KeyManagerFactory kmf = KeyManagerFactory.getInstance(<span class="string">"sunx509"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信任库</span></span><br><span class="line">TrustManagerFactory tmf = TrustManagerFactory.getInstance(<span class="string">"sunx509"</span>);</span><br><span class="line"></span><br><span class="line">KeyStore keyStore = KeyStore.getInstance(<span class="string">"pkcs12"</span>);</span><br><span class="line">KeyStore trustKeystore = KeyStore.getInstance(<span class="string">"jks"</span>);</span><br><span class="line"></span><br><span class="line">FileInputStream keystoreFis = <span class="keyword">new</span> FileInputStream(keystorePath);</span><br><span class="line">keystore.load(keystoreFis, keystorePassword.toCharArray);</span><br><span class="line"></span><br><span class="line">FileInputStream trustKeystoreFis = <span class="keyword">new</span> FileInputStream(trustKeystorePath);</span><br><span class="line">trustKeystore.load(trustKeystoreFis, keystorePassword.toCharArray());</span><br><span class="line"></span><br><span class="line">kmf.init(keystore, keystorePassword.toCharArray());</span><br><span class="line">tmf.init(trustKeystore);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文初始化</span></span><br><span class="line">sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">serverSocket =(SSLServerSocket).getSocketFactory().createServerSocket(port);</span><br><span class="line">serverSocket.setNeedClientAuth(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>处理 SSL 请求：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String bye = <span class="string">"bye bye"</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">Socket socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] inputBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">InputStream input = socket.getInputStream();</span><br><span class="line">input.read(inputBytes);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(inputBytes));</span><br><span class="line"></span><br><span class="line">OutputStream output = socket.getOutputStream();</span><br><span class="line">output.write(bye.getBytes, <span class="number">0</span>, bye.getBytes().length);</span><br><span class="line">output.flush;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="部署-HTTPS-Web"><a href="#部署-HTTPS-Web" class="headerlink" title="部署 HTTPS Web"></a>部署 HTTPS Web</h3><p>以 Tomcat 为例</p><h4 id="Tomcat-单向认证配置"><a href="#Tomcat-单向认证配置" class="headerlink" title="Tomcat 单向认证配置"></a>Tomcat 单向认证配置</h4><p>修改 Tomcat 配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- cd tomcat/conf;    vim server.xml;    找到默认注释的一段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"443"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">SSLEnabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag"><span class="attr">maxThreads</span>=<span class="string">"150"</span> <span class="attr">scheme</span>=<span class="string">"https"</span> <span class="attr">secure</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag"><span class="attr">clientAuth</span>=<span class="string">"false"</span> <span class="attr">sslProtocol</span>=<span class="string">"TLS"</span></span></span><br><span class="line"><span class="tag"><span class="attr">keystoreFile</span>=<span class="string">"home/user/temp/testssl/server.keystore"</span></span></span><br><span class="line"><span class="tag"><span class="attr">keystorePass</span>=<span class="string">"123456"</span></span></span><br><span class="line"><span class="tag"><span class="attr">keystoreType</span>=<span class="string">"pkcs12"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>安装 authbind<br>配置443端口<br>重启 tomcat</p><h4 id="Tomcat-双向认证的配置"><a href="#Tomcat-双向认证的配置" class="headerlink" title="Tomcat 双向认证的配置"></a>Tomcat 双向认证的配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"443"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">SSLEnabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag"><span class="attr">maxThreads</span>=<span class="string">"150"</span> <span class="attr">scheme</span>=<span class="string">"https"</span> <span class="attr">secure</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag"><span class="attr">clientAuth</span>=<span class="string">"false"</span> <span class="attr">sslProtocol</span>=<span class="string">"TLS"</span></span></span><br><span class="line"><span class="tag"><span class="attr">keystoreFile</span>=<span class="string">"home/user/temp/testssl/server.keystore"</span></span></span><br><span class="line"><span class="tag"><span class="attr">keystorePass</span>=<span class="string">"123456"</span></span></span><br><span class="line"><span class="tag"><span class="attr">keystoreType</span>=<span class="string">"pkcs12"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">truststoreFile</span>=<span class="string">"home/user/temp/testssl/ca-trust.keystore"</span></span></span><br><span class="line"><span class="tag"><span class="attr">truststorePass</span>=<span class="string">"123456"</span></span></span><br><span class="line"><span class="tag"><span class="attr">truststoreType</span>=<span class="string">"jks"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="OAuth-协议"><a href="#OAuth-协议" class="headerlink" title="OAuth 协议"></a>OAuth 协议</h2><blockquote><p>随着互联网的深入发展，一些互联网巨头逐渐累积了海量的用户和数据。对于平台级的软件厂商来说，用户需求多种多样，变化万千，以一己之力予以充分满足，难免疲于奔命，因此，将数据以接口的形式下放给众多的第三方开发者，便成了必然趋势。第三方开发者经过二次开发，满足一小部分的用户的独特需求，即能够使自己获得利益，也能够让数据流动起来，在大平台周围形成一个良性的生态环境，最终达到用户、平台商、第三方开发者共赢。</p></blockquote><p>平台商必须保障对于用户私有数据的访问，均是经过用户授权的合法行为，且不会对第三方泄露类似用户名和密码这样的核心数据。</p><h3 id="OAuth-的介绍"><a href="#OAuth-的介绍" class="headerlink" title="OAuth 的介绍"></a>OAuth 的介绍</h3><p>旨在为用户资源的授权访问提供一个安全、开放的标准。</p><h3 id="Oauth-授权过程"><a href="#Oauth-授权过程" class="headerlink" title="Oauth 授权过程"></a>Oauth 授权过程</h3><p>要获得 OAuth 协议授权，首先需要第三方开发者向平台商申请应用 ID，即 appId，对自己的 APP 进行注册。一次 OAuth 授权涵盖了三个角色：普通用户(consumer)、第三方应用(ISV)、平台商(platform)。</p><p><em>OAuth授权是一个相对较复杂的体系，涵盖系统设计的方方面面，不仅包括之前所说的认证过程，还需要解决开发者入驻、权限粒度的控制、token 生成和校验、分布式 Session、公私钥管理等一系列问题。</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Structure Security" scheme="http://yeonsea.club/tags/Structure-Security/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch概览</title>
    <link href="http://yeonsea.club/2019/09/10/Elasticsearch%E6%A6%82%E8%A7%88/"/>
    <id>http://yeonsea.club/2019/09/10/Elasticsearch概览/</id>
    <published>2019-09-10T08:11:35.000Z</published>
    <updated>2019-09-10T08:13:02.399Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>全文搜索引擎<br>基于 Lucene 构建的开源、分布式、RESTful接口</p><p><a href="还是一个分布式文档数据库">^1</a></p><blockquote><p>Github 的搜索是基于 Elasticsearch 构建的，只索引项目主分支，但包括20亿个索引文档，30TB的索引文件</p></blockquote><p>Shay Banon  失业开发者  给妻子构建食谱搜索引擎  早期版本的 Lucene  为方便Java可以在应用中增加搜索功能  第一个开源项目“Compass”</p><p>重写 Compass 使其成为一个独立的项目，Elasticsearch  </p><ul><li>横向可扩展</li><li>分片机制提供更好的分布性：sharding，类似 HDFS 的块机制</li><li>高可用：replica</li><li>使用简单</li></ul><p>Lucene：最初由 Doug Cutting 开发</p><p><em>倒排索引</em></p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>术语概念</p><ul><li>索引词：term</li><li>文本：text</li><li>分析：Analysis</li><li>集群：Cluster</li><li>节点：node</li><li>路由：routing</li><li>分片：shard</li><li>主分片：primary shard</li><li>副本分片：replica shard</li><li>副本：replica</li><li>索引：index 索引是具有相同结构的文档集合</li><li>类型：type 类型是索引的逻辑分区</li><li>文档：document  存储的一个 JSON 格式的字符串</li><li>映射：mapping</li><li>字段：field</li><li>开源字段：source field</li><li>主键：ID</li></ul><blockquote><p>每个 Elasticsearch 分片是一个 Lucene 的索引，有文档存储数量限制</p></blockquote><p>JSON  轻量级数据交换格式</p><h3 id="对外接口"><a href="#对外接口" class="headerlink" title="对外接口"></a>对外接口</h3><p>curl<br>REST：REpresentational State Transfer  表述性状态传输    一种约定    简化沟通成本</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引管理</p><ul><li>创建</li><li>删除</li><li>获取</li><li>打开 关闭</li></ul><p>索引映射管理</p><ul><li>增加映射</li><li>获取索引</li></ul><p>索引别名</p><ul><li>过滤索引别名</li><li>删除别名</li><li>查询现有的别名</li></ul><p>索引配置</p><ul><li>更新索引配置</li><li>获取配置</li><li>索引分析</li></ul><p>索引模板</p><blockquote><p>索引模板就是创建好一个索引参数设置 settings 和 映射 mapping 的模板，在创建新索引的时候指定模板名称就可以使用模板定义好的参数设置和映射</p><ul><li>创建</li><li>删除</li><li>获取</li></ul></blockquote><p>复制配置</p><p>重建索引</p><h3 id="索引监控"><a href="#索引监控" class="headerlink" title="索引监控"></a>索引监控</h3><ul><li>索引统计</li><li>索引分片</li><li>索引恢复</li><li>索引分片存储</li></ul><h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><ul><li>清除缓存</li><li>索引刷新</li><li>冲洗</li><li>合并索引</li></ul><h3 id="文档管理"><a href="#文档管理" class="headerlink" title="文档管理"></a>文档管理</h3><ul><li>增加文档</li><li>更新删除</li><li>查询</li><li>多文档操作</li><li>索引词频率</li><li>查询更新接口</li></ul><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>映射是定义存储和索引文档以及字段的过程</p><ul><li>字段数据类型</li><li>元字段</li><li>映射参数</li><li>动态映射：在 Elasticsearch 中可以不事先建好索引结构，在使用的时候可以直接插入文档到索引。</li></ul><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="深入搜索"><a href="#深入搜索" class="headerlink" title="深入搜索"></a>深入搜索</h3><h4 id="搜索方式"><a href="#搜索方式" class="headerlink" title="搜索方式"></a>搜索方式</h4><ul><li>URL 搜索 GET方式</li><li>POST 请求参数搜索</li><li>排序 sort</li><li>数据列过滤</li><li>脚本支持<h4 id="重新评分"><a href="#重新评分" class="headerlink" title="重新评分"></a>重新评分</h4>对短语进行重新评分，然后再查询<h4 id="滚动查询请求"><a href="#滚动查询请求" class="headerlink" title="滚动查询请求"></a>滚动查询请求</h4>Elasticsearch 提供了滚动 API 来解决此问题，这有点像数据库中的游标<h4 id="隐藏内容查询"><a href="#隐藏内容查询" class="headerlink" title="隐藏内容查询"></a>隐藏内容查询</h4>inner hits    嵌套结构<h4 id="相关搜索函数"><a href="#相关搜索函数" class="headerlink" title="相关搜索函数"></a>相关搜索函数</h4></li><li>Preference  搜索分片副本执行偏好设置</li><li>索引加权  index_boost</li><li>最小分值  min_score</li><li>分值解释  explain  可以使每个命中的查询解释它的得分是如何计算出来的</li><li>分片情况查询  _search_shards</li><li>总分查询  _count</li><li>是否存在查询</li><li>验证接口<h4 id="搜索模板"><a href="#搜索模板" class="headerlink" title="搜索模板"></a>搜索模板</h4><h3 id="查询DSL"><a href="#查询DSL" class="headerlink" title="查询DSL"></a>查询DSL</h3>Domain-specific Language<br>Elasticsearch 提供了基于 JSON 的完整查询 DSL 来定义查询<h4 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h4></li><li>布尔查询</li><li>短语查询</li><li>短语前缀查询</li><li>多字段查询</li><li>Lucene 语法查询</li><li>简化查询<h4 id="字段查询"><a href="#字段查询" class="headerlink" title="字段查询"></a>字段查询</h4></li><li>单字段查询</li><li>多字段查询</li><li>范围查询<h4 id="复合查询"><a href="#复合查询" class="headerlink" title="复合查询"></a>复合查询</h4></li><li>常数得分查询</li><li>布尔查询</li><li>最大值获取查询</li><li>boosting 查询</li><li>指定索引查询</li><li>过滤查询</li><li>限制查询<h4 id="连接查询"><a href="#连接查询" class="headerlink" title="- 连接查询"></a>- 连接查询</h4></li><li>嵌套查询</li><li>父子文档查询<h4 id="地理查询"><a href="#地理查询" class="headerlink" title="地理查询"></a>地理查询</h4>Elasticsearch 支持两种地理数据类型的字段：地理点类型，支持经度纬度对；地理形状类型，支持点、线、圈、多边形、多边形集合等。</li><li>地理形状查询</li><li>地理范围查询</li><li>地理距离查询</li><li>地理距离范围查询</li><li>多边形地理查询</li><li>地理散列单元查询<h4 id="跨度查询"><a href="#跨度查询" class="headerlink" title="跨度查询"></a>跨度查询</h4></li><li>索引词跨度查询</li><li>多索引词跨度查询</li><li>首跨度查询</li><li>接近跨度查询</li><li>或跨度查询</li><li>非跨度查询</li><li>包含跨度查询</li><li>内部跨度查询<h4 id="高亮显示"><a href="#高亮显示" class="headerlink" title="高亮显示"></a>高亮显示</h4>Elasticsearch 中的高亮显示是来源于 Lucene 的功能，允许一个或者多个字段上突出显示搜索内容<h3 id="简化查询"><a href="#简化查询" class="headerlink" title="简化查询"></a>简化查询</h3>catAPI<br>常用简化查询指标</li><li>indices</li><li>nodes</li><li>recovery</li><li>thread pool</li></ul><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><h3 id="聚合分类"><a href="#聚合分类" class="headerlink" title="聚合分类"></a>聚合分类</h3><h4 id="度量聚合"><a href="#度量聚合" class="headerlink" title="度量聚合"></a>度量聚合</h4><ul><li>平均值聚合</li><li>基数聚合</li><li>最大值聚合</li><li>最小值聚合</li><li>和聚合</li><li>值基数聚合</li><li>统计聚合</li><li>百分比聚合</li><li>百分比分级聚合</li><li>最高命中排行聚合</li><li>脚本度量聚合</li><li>地理边界聚合</li><li>地理重心聚合</li></ul><h3 id="分组聚合"><a href="#分组聚合" class="headerlink" title="分组聚合"></a>分组聚合</h3><ul><li>子聚合</li><li>直方图聚合</li><li>日期直方图聚合</li><li>时间范围聚合</li><li>范围聚合</li><li>过滤聚合</li><li>多重过滤聚合</li><li>空值聚合</li><li>嵌套聚合</li><li>采样聚合</li><li>重要索引词聚合</li><li>索引词聚合</li><li>总体聚合</li><li>地理点距离聚合</li><li>地理散列网格聚合</li><li>IPv4 范围聚合<h3 id="管道聚合"><a href="#管道聚合" class="headerlink" title="管道聚合"></a>管道聚合</h3></li><li>平均分组聚合</li><li>移动平均聚合</li><li>总和分组聚合</li><li>总和累计聚合</li><li>最大分组聚合</li><li>最小分组聚合</li><li>统计分组聚合</li><li>百分位分组聚合</li><li>差值聚合</li><li>分组脚本聚合</li><li>串行差分聚合</li><li>分组选择器聚合</li></ul><h2 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h2><h3 id="集群节点监控"><a href="#集群节点监控" class="headerlink" title="集群节点监控"></a>集群节点监控</h3><blockquote><p>对 Elasticsearch 监控的API 主要有三类：一类是集群相关的，以_cluster开头，第二类是监控节点相关的，以_nodes开头，第三类是任务相关的，以_tasks开头</p><ul><li>集群健康值</li><li>集群状态</li><li>集群统计</li><li>集群任务管理</li><li>待定集群任务</li><li>节点信息</li><li>节点统计</li></ul></blockquote><h3 id="集群分片迁移"><a href="#集群分片迁移" class="headerlink" title="集群分片迁移"></a>集群分片迁移</h3><ul><li>移动  remove</li><li>取消  cancel</li><li>分配  allocate</li><li>集群配置更新<h3 id="集群节点配置"><a href="#集群节点配置" class="headerlink" title="集群节点配置"></a>集群节点配置</h3></li><li>主节点  主要职责是和集群操作相关的内容，如创建或删除索引，跟踪哪些节点是集群的一部分，并决定哪些分片分配给相关的节点。</li><li>数据节点  主要是存储索引数据的节点，主要对文档进行增删改查、聚合操作等。</li><li>客户端节点  当主节点和数据节点配置都设置为 false 时，该节点只能处理路由请求，处理搜索，分发索引操作等，从本质上来说该客户端节点表现为智能负载平衡器。独立的客户端节点在一个比较大的集群中是非常有用的，它协调主节点和数据节点，客户端节点加入集群可以得到集群的状态，根据集群的状态可以直接发送路由请求。</li><li>部落节点  部落节点可以跨越多个集群，它可以接收每个集群的状态，然后合并成一个全局集群的状态，它可以读写所有节点上的数据。<h3 id="节点发现"><a href="#节点发现" class="headerlink" title="节点发现"></a>节点发现</h3></li><li>ping 模块</li><li>单播模块<h4 id="主节点选举"><a href="#主节点选举" class="headerlink" title="主节点选举"></a>主节点选举</h4>在集群中，系统会自动通过 ping 来进行选举节点或者加入主节点，这些都是自动完成的。<h4 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h4><h4 id="集群平衡配置"><a href="#集群平衡配置" class="headerlink" title="集群平衡配置"></a>集群平衡配置</h4></li><li>分片分配设置</li><li>基于磁盘的配置</li><li>分片智能分配</li><li>分片配置过滤</li><li>其他集群配置<h2 id="索引分词器"><a href="#索引分词器" class="headerlink" title="索引分词器"></a>索引分词器</h2><h3 id="分词器的概念"><a href="#分词器的概念" class="headerlink" title="分词器的概念"></a>分词器的概念</h3><em>分词器analyzer的作用是当一个文档被索引的时候，分词器从文档中提取出若干词元token来支持索引的存储和搜索。</em><blockquote><p>分词器 是由一个分解器 tokenizer、零个或多个词元过滤器 token filters 组成。</p></blockquote><h3 id="中文分词器"><a href="#中文分词器" class="headerlink" title="中文分词器"></a>中文分词器</h3></li><li>smartcn</li><li>IKAnanlyzer<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3></li><li>java 插件  jar</li><li>站点插件  js html css</li><li>混合插件<h4 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h4>正常情况下插件位于$ES_HOME/bin 下<br>通过rpm等安装的位置可能会不同<h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4></li><li>查询插件</li><li>删除插件</li><li>Silent/Verbose 参数  更多调试信息</li><li>自定义配置目录</li><li>超时设置</li><li>代理设置</li><li>自定义插件目录</li><li>强制插件</li></ul><h4 id="插件清单"><a href="#插件清单" class="headerlink" title="插件清单"></a>插件清单</h4><ul><li>API 插件</li><li>报警插件</li><li>分词插件</li><li>发现插件</li><li>管理和站点插件</li></ul><h2 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h2><blockquote><p>在Elasticsearch 的配置中，主要有两种配置方式，一种是静态配置，另一种是动态配置。静态配置的参数只能在配置文件中事先写好，动态配置的参数可以通过_cluster/settings进行设置。</p></blockquote><h3 id="网络相关配置"><a href="#网络相关配置" class="headerlink" title="网络相关配置"></a>网络相关配置</h3><ul><li>本地网关配置</li><li>HTTP 配置</li><li>网络配置  常用网络配置，高级网络配置，高级TCP配置，传输和HTTP协议</li><li>传输配置  TCP传输，本地传输，传输追踪<h3 id="脚本配置"><a href="#脚本配置" class="headerlink" title="脚本配置"></a>脚本配置</h3></li><li>脚本使用</li><li>脚本配置  索引脚本，启用动态脚本，脚本自动重载，本地java脚本，lucene表达式脚本，得分，文档字段，保存的字段，在脚本中访问文档的得分，源字段，Groovy内置方法<h3 id="快照和恢复配置"><a href="#快照和恢复配置" class="headerlink" title="快照和恢复配置"></a>快照和恢复配置</h3></li><li>只读仓库</li><li>快照</li><li>恢复</li><li>快照状态<h3 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h3><h4 id="线程池类型"><a href="#线程池类型" class="headerlink" title="线程池类型"></a>线程池类型</h4></li><li>cached 线程池是一个无限的线程池，如果存在挂起的请求时，就会产生一个线程。这个线程池用来防止提交的请求被阻塞或丢弃。</li><li>fixed 线程池拥有固定大小的线程来操作队列中的请求（任意界限）直到请求没有线程提供服务。size参数控制线程的数量，queue_size 参数可以控制没有线程执行的请求队列的大小。默认设置为-1，意味着无限大。当请求到达而且队列已经满了，请求会被终止。</li><li>scaling 线程池拥有动态数量的线程。线程的数量与工作量成正比，并且在1和size参数值之间变化。keep_alive参数决定一个线程的空闲时间。</li></ul><h4 id="处理器设置"><a href="#处理器设置" class="headerlink" title="处理器设置"></a>处理器设置</h4><p>处理器的数量是自动检测的，线程池的设置会基于结果自动设置。有时，处理器的数量会被错误检测，在这种情况下，处理器的数量可以使用 processes进行明确设置。</p><h3 id="索引配置"><a href="#索引配置" class="headerlink" title="索引配置"></a>索引配置</h3><blockquote><p>索引模块是控制每个索引指标的模块。索引模块包括分词、分片控制和分配、字段映射、索引相似性配置、慢查询记录、文件系统配置、控制事务和刷新模块。</p></blockquote><h4 id="缓存配置"><a href="#缓存配置" class="headerlink" title="缓存配置"></a>缓存配置</h4><ul><li>总内存控制</li><li>列数据内存控制</li><li>请求内存控制</li><li>数据缓存</li><li>节点查询缓存</li><li>索引缓冲区</li><li>分片请求缓存</li><li>索引恢复</li><li>TTL区间<h4 id="索引分片分配"><a href="#索引分片分配" class="headerlink" title="索引分片分配"></a>索引分片分配</h4></li><li>碎片分配过滤</li><li>延迟分配</li><li>每个节点的总碎片<h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><blockquote><p>一个 Elasticsearch 分片就是一个 Lucene 索引，Lucene索引被分解为分片。分片是索引的内部存储单元，存储索引数据并且是不变的。周期性合并(merge)小的分片为更大的分片来保持索引大小在范围内。</p></blockquote><h4 id="相似模块"><a href="#相似模块" class="headerlink" title="相似模块"></a>相似模块</h4></li><li>配置相似性</li><li>可用的相似性模块<h4 id="响应慢日志监控"><a href="#响应慢日志监控" class="headerlink" title="响应慢日志监控"></a>响应慢日志监控</h4></li><li>搜索慢日志</li><li>索引慢日志<h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4>支持存储类型</li><li>simplefs  简单文件系统类型</li><li>niofs  NIO 文件系统类型</li><li>mmapfs  MMap 文件系统类型在文件系统上通过映射文件到内存(mmap)存储分片索引</li><li>default_fs  默认类型是 NIO FS 和 MMapFS 的混合，对每个类型的文件选择最佳文件系统<h4 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h4></li><li>冲洗设置</li><li>事务日志设置</li></ul><h2 id="告警、监控和权限管理"><a href="#告警、监控和权限管理" class="headerlink" title="告警、监控和权限管理"></a>告警、监控和权限管理</h2><h3 id="告警"><a href="#告警" class="headerlink" title="告警"></a>告警</h3><p>Watcher 是进行警告和通知的插件，可以根据数据的变化采取行动。它的设计原理是在 Elasticsearch 中执行查询，满足条件的情况下，产生告警。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul><li>Trigger</li><li>Inputs</li><li>Condition</li><li>Transform</li><li>Action<h4 id="告警输出配置"><a href="#告警输出配置" class="headerlink" title="告警输出配置"></a>告警输出配置</h4>告警输出可以为邮件、Webhook、Logging、HipChat、Slack、PagerDuty<h4 id="告警管理"><a href="#告警管理" class="headerlink" title="告警管理"></a>告警管理</h4></li><li>列出警告</li><li>删除警告<h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><blockquote><p>Marvel 是商业监控方案，用来监控 Elasticsearch 集群历史状态的有力工具，便于性能优化以及故障诊断。监控主要分为六个层面，分别是集群层、节点层、索引层、分片层、事件层、Sense。</p></blockquote><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4></li><li>监控参数配置</li><li>监控索引配置</li><li>Kibana 配置相关</li><li>Tribe 部落节点监控配置<h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><blockquote><p>Shield 是商业权限管理插件，它可以保护 Elasticsearch 中的数据，采用加密的通信密码，基于角色的访问控制，IP过滤和审计等。</p></blockquote><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4>Shield 是 Elasticsearch 的一个插件，一旦安装完成，插件将会拦截所有 API 请求，然后对请求进行认证和授权的校验。该插件同时提供 SSL 安全协议来传输网络数据，该插件提供了审计日志记录的能力，用来进行验证和审计。</li><li>用户认证</li><li>授权</li><li>节点认证和信道加密</li><li>IP 过滤</li><li>审计<h4 id="用户认证"><a href="#用户认证" class="headerlink" title="用户认证"></a>用户认证</h4>用户认证方式</li><li>Native  一个内置的本地认证系统，默认可用</li><li>File  一种内置的基于文件的认证系统，默认可用</li><li>LDAP  通过外部轻量级目录协议进行身份验证</li><li>AD  通过外部活动目录服务的身份验证</li><li>PKI  通过使用可信的X.509证书的认证<br>匿名用户访问<h4 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a>角色管理</h4></li><li>增加角色</li><li>查看角色</li><li>删除角色</li></ul><h2 id="ELK-应用"><a href="#ELK-应用" class="headerlink" title="ELK 应用"></a>ELK 应用</h2><ul><li>Logstash  是一个灵活的开放源码的数据收集、处理、传输的工具。Logstash 可以处理日志、事件、非结构化的数据，并把它们输出出来，包括可以输出到 Elasticsearch 中。</li><li>Kibana  是一个开源的数据可视化平台，可以把数据以强大的图形化方式展示出来。从柱状图到地图等，它可以通过多个图表的组合来生成更为强大的仪表面板，帮助人们理解、分析和分享数据。</li></ul><h2 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h2><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><h4 id="配置文件的结构"><a href="#配置文件的结构" class="headerlink" title="配置文件的结构"></a>配置文件的结构</h4><p>配置文件由输入，过滤，输出三部分组成，每部分都是由插件构成的，这些插件负责处理日志的不同过程</p><h4 id="事件相关配置"><a href="#事件相关配置" class="headerlink" title="事件相关配置"></a>事件相关配置</h4><blockquote><p>每个事件都有不同的属性，比如 apache 的访问日志，可以包括状态码、协议、路径、客户端 IP等，在 Logstash 中这些属性叫做 fields。由于它们是事件属性，所以这些配置选项只会在过滤器和输出块中工作。</p></blockquote><h4 id="插件管理-1"><a href="#插件管理-1" class="headerlink" title="插件管理"></a>插件管理</h4><p>插件管理器通过 bin/logstash-plugin 的脚本来管理整个插件的生命周期，通过命令行接口(CLI)调用可以安装、卸载、升级插件。</p><ul><li>输入插件</li><li>过滤插件</li><li>输出插件</li><li>编解码插件<h3 id="Kibana-配置"><a href="#Kibana-配置" class="headerlink" title="Kibana 配置"></a>Kibana 配置</h3>安装比较简单，也是绿色的，解压后直接运行默认端口 5601。<h4 id="Discover"><a href="#Discover" class="headerlink" title="Discover"></a>Discover</h4></li><li>新的搜索</li><li>保存搜索加载保存的搜索</li><li>自动刷新</li><li>查看字段数据统计<h4 id="Visualize"><a href="#Visualize" class="headerlink" title="Visualize"></a>Visualize</h4>视图是定制可视化报表的地方</li></ul><ol><li>选择一个图标类型</li><li>选择一个数据源</li><li>可视化编辑器配置</li><li>保存编辑器<h4 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h4>仪表盘是用一组原始图标根据需要组合成一个丰富的图形报表</li></ol><ul><li>空仪表盘</li><li>创建仪表盘</li><li>保存仪表盘</li><li>加载仪表盘</li><li>共享仪表盘<h4 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h4></li><li>索引设置</li><li>管理字段</li><li>告警设置</li><li>Kibana 服务器配置</li><li>管理搜索，可视化仪表板<h2 id="Elasticsearch-5-0-的特性与改进"><a href="#Elasticsearch-5-0-的特性与改进" class="headerlink" title="Elasticsearch 5.0 的特性与改进"></a>Elasticsearch 5.0 的特性与改进</h2></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于分布式系统的稳定性</title>
    <link href="http://yeonsea.club/2019/08/25/%E5%85%B3%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    <id>http://yeonsea.club/2019/08/25/关于分布式系统的稳定性/</id>
    <published>2019-08-25T10:40:48.000Z</published>
    <updated>2019-09-10T08:05:36.131Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><h3 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h3><ul><li>堆栈信息</li><li>访问用户 IP、请求 URL、应用响应时间</li><li>内存回收信息</li><li>自定义信息</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>通过异常堆栈，可以定位到谁宕机了</li><li>产生问题的程序行，对异常进行修复</li><li>访问 IP 和请求参数，排查是否遭到攻击，以及攻击的形式</li><li>应用的响应时间、垃圾回收以及系统 load 来判断系统负载，是否要增加机器</li><li>线程 dump，判断是否死锁及线程阻塞的原因</li><li>应用的 GC 日志，对系统代码和 JVM 内存参数进行优化，减少 GC 次数与 stop the world 时间，优化应用响应时间</li></ul><h2 id="集群监控"><a href="#集群监控" class="headerlink" title="集群监控"></a>集群监控</h2><p>木桶原理</p><h3 id="监控指标"><a href="#监控指标" class="headerlink" title="监控指标"></a>监控指标</h3><ul><li>load：linux 中，可以通过 top,uptime来查看系统load值，系统load定义为特定时间间隔内运行队列中的平均线程数。</li><li>cpu 利用率</li><li>磁盘剩余空间</li><li>网络 traffic</li><li>磁盘 IO</li><li>内存使用</li><li>qps    query per second</li><li>rt    response time</li><li>select/ps</li><li>update/ps、delete/ps</li><li>GC    JVM 虚拟机开发团队一直致力于消除或者减少工作线程因内存回收而导致的停顿，用户线程的停顿时间在不断地缩短，但是仍然没办法完全消除</li></ul><h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><blockquote><p>对于自治的分布式系统而言，一般都有一整套的集群心跳检测机制，能够实时地移除掉宕机的 Slave，避免路由规则将任务分配给已宕机的机器来处理。<br>而如果是 Master 宕机，集群能够自动地进行 Master 的选举，从而避免由 Master 宕机而导致整个集群不能提供服务的情况发生，这一类系统，如 ZooKeeper，便是一个很好的典范。也有一部分系统可以通过外部干预，使备份机器 stand by，或者是双机互为备份，以实现故障切换，如 MySQL、Nginx等，以避免单点故障的发生。</p></blockquote><p>具体操作：</p><ul><li>ping</li><li>应用层检测    curl 定时访问应用中预留的自检 url</li><li>业务检测    可在 response 的 header 中约定一个值，来标识返回的结果是否正常</li></ul><h3 id="容量评估及应用水位"><a href="#容量评估及应用水位" class="headerlink" title="容量评估及应用水位"></a>容量评估及应用水位</h3><p>当前水位 = 当前总 qps / （单台机器极限 x 机器数）x 100%</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><h3 id="流量控制实施"><a href="#流量控制实施" class="headerlink" title="流量控制实施"></a>流量控制实施</h3><p>多个维度</p><ul><li>对系统的总并发请求数进行限制 - 可以很好地控制系统的负载，避免出现流量突增将系统压垮的情况</li><li>限制单位时间内的请求次数（如限制qps） - 限制调用频次，防止某个外部调用的流量突增影响到服务本身的稳定性</li><li>通过白名单机制来限制每一个接入系统调用的频率等</li></ul><p>超载的部分流量</p><ul><li>直接返回，显示系统繁忙</li><li>通过单机内存队列来进行有限的等待</li><li>通过分布式消息队列来将用户的请求异步化</li></ul><h3 id="服务稳定性"><a href="#服务稳定性" class="headerlink" title="服务稳定性"></a>服务稳定性</h3><h4 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h4><p>服务消费日志</p><h4 id="优雅降级"><a href="#优雅降级" class="headerlink" title="优雅降级"></a>优雅降级</h4><blockquote><p>对于调用超时的非核心服务，可以设定一个阈值，如果调用超时的次数超过这个阈值，便自动将该服务降级。此时服务调用者跳过对该服务的调用，并指定一个休眠的时间点，当时间点过了以后，再次对该服务进行重试，如果服务恢复，则取消降级，否则继续保持该服务的降级状态，直到所依赖的服务故障恢复。</p></blockquote><h4 id="服务分级"><a href="#服务分级" class="headerlink" title="服务分级"></a>服务分级</h4><h4 id="开关"><a href="#开关" class="headerlink" title="开关"></a>开关</h4><blockquote><p>当系统负载较高，即将突破警戒水位时，如何通过实时地屏蔽一些非核心链路的调用来降低系统的负载呢？这时需要系统预先定义一些开关控制程序的服务提供策略。开关通过修改一些预先定义好的全局变量，来控制系统的关键路径和逻辑。</p></blockquote><h4 id="应急预案"><a href="#应急预案" class="headerlink" title="应急预案"></a>应急预案</h4><h3 id="高并发系统设计"><a href="#高并发系统设计" class="headerlink" title="高并发系统设计"></a>高并发系统设计</h3><blockquote><p>高并发系统与普通系统设计的区别在于，既要保障系统的可用性和可扩展性，又要兼顾数据的一致性，还要处理多线程同步的问题。<br><em>任何细微问题，都有可能在高并发环境下被无限地放大，直至系统宕机</em></p></blockquote><h4 id="操作原子性"><a href="#操作原子性" class="headerlink" title="操作原子性"></a>操作原子性</h4><blockquote><p>原子操作指的是不可分割的操作，它要么执行成功，要么执行失败，不会产生中间状态。<br>原子操作也是一些常见的多线程程序bug的源头。<br>并发相关的问题对于测试来说，并不是每次都能重现，因此处理起来十分棘手。<br>JDK5.0 以后开始提供 Atomic Class，支持 CAS compare and set 等一系列原子操作，来帮助我们简化多线程程序设计。<br>数据count统计</p><ul><li>CountDownLatch是做减法，CyclicBarrier是做加法,Semaphor的临界资源可以反复使用</li><li>CountDownLatch不能重置计数，CycliBarrier提供的reset()方法可以重置计数，不过只能等到第一个计数结束。Semaphor可以重复使用。</li><li>CountDownLatch和CycliBarrier不能控制并发线程的数量，Semaphor可以实现控制并发线程的数量。<br>AtomicInteger compareAndSet 方法 调用 Unsafe 对象的 native 方法 compareAndSwapInt 方法，最终通过 Atomic::com::(x, addr, e)来实现原子操作</li></ul></blockquote><p>数据库的事务操作<br>数据库事务具有 ACID 属性<br>导致事务失败的原因有很多：</p><ul><li>修改不符合表的约束规则</li><li>网络异常</li><li>存储介质故障</li></ul><blockquote><p>为了实现数据库状态的恢复，DBMS 系统通常需要维护事务日志以追踪事务中所有影响数据库数据的操作，以便执行失败时进行事务的回滚。<br>事务日志可以提高事务执行的效率，存储引擎只需要将修改行为持久到事务日志当中，便可以只对该数据在内存中的拷贝进行修改，而不需要每次修改都将数据回写到磁盘。<br>日志写入是一小块区域的顺序IO，而数据库数据的磁盘回写则是随机IO，磁头需要不停地移动来寻找需要更新数据的位置。</p></blockquote><h4 id="多线程同步"><a href="#多线程同步" class="headerlink" title="多线程同步"></a>多线程同步</h4><p>多线程同步指的是线程之间执行的顺序，多个线程并发地访问和操作同一数据，并且执行的结果与访问或者操作的次序有关。</p><ul><li>synchronized</li><li>ReentrantLock<blockquote><p>ReentrantLock 的好处是，等待是可以中断的。通过 tryLock(timeout, unit)，可以尝试获得锁，并且指定等待时间。另一个特性是可以在构造 ReentrantLock 时使用公平锁，公平锁指的是多个线程在等待同一个锁时，必须按照申请锁的先后顺序依次获得锁。synchronized 中的锁是非公平的，默认情况下 ReentrantLock 也是非公平的，但是可以在构造函数中指定使用公平锁。<br>对于 ReentrantLock 来说，还有一个十分实用的特性，它可以同时绑定多个 condition 条件，以实现更精细化的同步控制。</p></blockquote></li></ul><h4 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h4><p>分布式系统常常通过复制数据来提高系统的可靠性和容错性，并且将数据的副本存放到不同的机器上。由于多个副本的存在，使得维护副本一致性的代价很高。因此，许多分布式系统都采用弱一致性或者最终一致性，来提高系统的性能和吞吐能力。</p><blockquote><p>最终一致性是弱一致性的一种特殊形式，这种情况下系统保证用户最终能够读取到某个操作对系统的更新，“不一致性窗口”的时间依赖于网络的延迟、系统的负载和副本的个数。<br>最终一致性举例：</p><ul><li>mysql 主从数据同步</li><li>zookeeper 的 leader election 和 atomic broadcas</li></ul></blockquote><h4 id="系统可扩展性"><a href="#系统可扩展性" class="headerlink" title="系统可扩展性"></a>系统可扩展性</h4><p>系统的可扩展性也成为可伸缩性，是一种对软件系统计算处理能力的评价指标。<br>只需要增加相应的机器，便能够使性能平滑地提升。<br><em>水平扩展相对于硬件的垂直扩展来说，对于软件设计的能力要求更高，系统设计更复杂，但却能够使系统处理能力几乎可以无限制扩展</em><br><em>系统的可扩展性也会受到一些因素的制约，CAP理论指出，系统的一致性、可用性和可扩展性三个要素对于分布式系统来说，很难同时满足。因此，在系统设计时，往往得做一些取舍。</em></p><h4 id="并发减库存"><a href="#并发减库存" class="headerlink" title="并发减库存"></a>并发减库存</h4><p>秒杀活动杜绝网络投机者使用工具导致不公平竞争：加速验证码，复杂验证码。</p><p>数据一致性问题：</p><blockquote><p>对于高并发访问的浏览型系统来说，单机数据库如不进行扩展，往往很难支撑。因此常常会采用分库技术来提高数据库的并发能力，并且通过使用分布式缓存技术，将磁盘磁头的机械运动化为内存的高低电平，以降低数据库的压力，加快后端的响应速度。响应的越快，线程释放的也越快，能够支持的单位时间内的查询数qps也越高，并发处理能力就越强。<br><em>带来的问题是跨数据库或者是分布式缓存与数据库之间难以进行事务操作。</em><br>为了避免数据不一致的情况发生，并且保证前端页面能够在高并发情况下正常浏览，可以采用实际库存和浏览库存分离的方式。<br>mysql 中 myisam 是表锁策略，innodb 是行锁策略，innodb 更适合高并发写入的场景</p></blockquote><p>一个线程获得行锁以后，其他并发线程就需要等待它处理完成，这样系统将无法利用多线程并发执行的优势，并且随着并发数的增加，等待的线程会越来越多，rt 急剧飙升，最终导致可用连接数被占满，数据库拒绝服务。</p><p>可以通过将一行库存拆分成多行，便可以解除行锁导致的并发资源利用的问题。<br>路由策略：id取模，随机。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="如何寻找性能的瓶颈"><a href="#如何寻找性能的瓶颈" class="headerlink" title="如何寻找性能的瓶颈"></a>如何寻找性能的瓶颈</h3><blockquote><p>Web 性能优化涉及前端优化、服务端优化、操作系统优化、数据库查询优化、JVM调优等众多领域的知识<br><em>寻找可优化的点是第一步也是最重要的一步，也就是所谓的性能瓶颈，性能瓶颈实际上就是木桶原理中最短的那一块木板</em></p></blockquote><h4 id="前端优化工具-YSlow"><a href="#前端优化工具-YSlow" class="headerlink" title="前端优化工具 YSlow"></a>前端优化工具 YSlow</h4><h4 id="页面响应时间"><a href="#页面响应时间" class="headerlink" title="页面响应时间"></a>页面响应时间</h4><h4 id="方法响应时间"><a href="#方法响应时间" class="headerlink" title="方法响应时间"></a>方法响应时间</h4><p><strong>Java 环境下有一个十分有效的动态跟踪工具，btrace</strong></p><h4 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h4><blockquote><p>GC 日志能够反应出 Java 应用执行内存回收详细情况，如 Minor GC 的频繁程度、Full GC 的频繁程度、GC 所导致应用停止响应的时间、引起 GC 的原因等。<br>在 JVM 启动时加上几个参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-verbose:gc -Xloggc:/gc.log -XX:+PrintGCDetails -XX:+PrintGCDataStamps</span><br></pre></td></tr></table></figure></p></blockquote><p>分别表示日志存放位置，输出 GC 详情，输出 GC 时间戳</p><blockquote><p>CMS 收集器是一款以获取最短回收停顿时间为目的的收集器，它是基于标记清除算法实现的，整个过程大致分为四个步骤： CMS initial mark, CMS concurrent mark, CMS remark, CMS concurrent sweep</p></blockquote><h4 id="数据库查询"><a href="#数据库查询" class="headerlink" title="数据库查询"></a>数据库查询</h4><p>low_slow_query<br>low_query_time<br>通过 MySQL 的配置文件 my.cnf ，可以修改慢查询日志的相关配置</p><h4 id="系统资源使用"><a href="#系统资源使用" class="headerlink" title="系统资源使用"></a>系统资源使用</h4><h3 id="性能测试工具"><a href="#性能测试工具" class="headerlink" title="性能测试工具"></a>性能测试工具</h3><p>性能测试指的是通过一些自动化的测试工具模拟多种正常、峰值，以及异常负载对系统的各项性能指标进行测试。</p><h4 id="ab"><a href="#ab" class="headerlink" title="ab"></a>ab</h4><p>全称为 ApacheBench，专门针对 HTTP 服务器进行性能测试的小工具，可以模拟多个并发请求来对服务器进行压力测试，得出服务器在高负载下能够支持的qps及应用的响应时间，为系统设计者提供参考依据。</p><h4 id="Apache-JMeter"><a href="#Apache-JMeter" class="headerlink" title="Apache JMeter"></a>Apache JMeter</h4><p>开源性能测试工具，比 ab 更为强大，采用纯 Java 实现，支持多种协议的性能基准测试，如HTTP,SOAP,FTP,TCP,SMTP,POP3等。<br>提供了图形化界面</p><p>Tomcat 在启动脚本中加入如下配置，便能通过jconsole,VisualVM等工具查看系统相关信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CATALINA\_OPTS=&quot;$CATALINA_OPTS -Djava.rmi.server.hostname=***.***.***.*** -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=**** -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false&quot;</span><br></pre></td></tr></table></figure></p><h4 id="HP-LoadRunner"><a href="#HP-LoadRunner" class="headerlink" title="HP LoadRunner"></a>HP LoadRunner</h4><p>商业付费，更成熟，更强大，支持的协议更为广泛，用户体验更高。</p><h4 id="反向代理引流"><a href="#反向代理引流" class="headerlink" title="反向代理引流"></a>反向代理引流</h4><blockquote><p>在分布式环境下，流量真正到达服务器之前，一般会经过负载均衡设备进行转发，通过修改负载均衡的策略，可以改变后端服务器所承受的压力。</p></blockquote><p>Nginx 配置权重，新版本灰度发布。</p><h4 id="TCPCopy"><a href="#TCPCopy" class="headerlink" title="TCPCopy"></a>TCPCopy</h4><p>网易技术部2011年9月开源的一个项目，请求复制工具，能够将在线请求复制到测试机器，模拟真实环境，达到程序在不上线的情况下承担线上真实流量的效果。</p><h3 id="性能优化措施"><a href="#性能优化措施" class="headerlink" title="性能优化措施"></a>性能优化措施</h3><h4 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h4><ol><li>页面的 HTTP 请求数量<blockquote><p>新建一个到服务器的HTTP连接需要重新经历TCP协议握手建立连接状态等过程，并且大部分请求和响应都包含了很多相同 header 与 cookie 内容，增加了网络带宽消耗。因此，减少 HTTP 请求的数量能够加速页面的加载，在不改变页面外观的情况下，可以通过采取合并样式和脚本文件等措施，来减少页面加载所需要请求数。</p></blockquote></li><li>是否使用 CDN 网络<blockquote><p>CDN 网络使得用户能够就近取得所需要的资源，降低静态资源传输的网络延迟。可以将图片、样式文件、脚本文件、页面框架等不需要频繁变动的内容推送到 CDN网络，可以提高页面加载的速度。</p></blockquote></li><li>是否使用压缩<blockquote><p>对于前端样式文件与脚本文件，可以将其中空格、注释等不必要的字符去掉，并且通过使用 gzip 压缩来减少网络上传输的字节数。当然，压缩也是有成本的，它会消耗一定的 CPU 资源，但通常情况下来说这种开销都是值得的。</p></blockquote></li></ol><h4 id="Java-程序优化"><a href="#Java-程序优化" class="headerlink" title="Java 程序优化"></a>Java 程序优化</h4><h5 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h5><p>对于 IO 处理、数据库连接、配置文件解析加载等一些非常耗费系统资源的操作，我们必须对这些实例的创建进行限制，或者始终使用一个公用的实例，以节约系统开销，这种情况下就需要用到单例模式。</p><h5 id="Future-模式"><a href="#Future-模式" class="headerlink" title="Future 模式"></a>Future 模式</h5><p>假设一个任务执行起来需要花费一些时间，为了省去不必要的等待时间，可以先获取一个提货单，即 Future ，然后继续处理别的任务，直到货物到达，即任务执行完得到结果，此时便可以用提货单进行提货，即通过 Future 对象得到返回值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class TestFuture &#123;</span><br><span class="line">static class Job&lt;Object&gt; implements Callable&lt;Object&gt; &#123;</span><br><span class="line">@Override</span><br><span class="line">public Object call() throws Exception &#123;</span><br><span class="line">return loadData();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">FutureTask future = new FutureTask(new Job&lt;Object&gt;());</span><br><span class="line">new Thread(future).start();</span><br><span class="line"></span><br><span class="line">// do something else</span><br><span class="line"></span><br><span class="line">Object result = (Object) future.get();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>FutureTask 类实现了 Future 和 Runnable 接口，FutureTask 开始后，loadData()执行时间可能较长，因此可以先处理其他事情，等其他事情处理好以后，再通过 future.get() 来获取结果，如果 loadData() 还未执行完毕，则此线程会阻塞等待。</p></blockquote><h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5><p>使用线程池将互不依赖的几个动作切分，通过多线程对串行工作进行改进，将成倍地提高工作效率。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class TestExecutorService &#123;</span><br><span class="line">static class Job implements Runnable &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">doWork();// 具体工作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void doWork() &#123;</span><br><span class="line">System.out.println(&quot;doing...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ExecutorService exec = Executors.newFixedThreadPool(5);</span><br><span class="line">for (int i = 0; i &lt; 10; i ++) &#123;</span><br><span class="line">exec.execute(new Job());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="选择就绪"><a href="#选择就绪" class="headerlink" title="选择就绪"></a>选择就绪</h5><blockquote><p>JDK自1.4起开始提供全新的 IO 编程类库，简称 NIO，其不但引入了全新高效的 Buffer 和 Channel ，同时还引入了基于 Selector 的非阻塞 IO 机制，将多个异步的 IO 操作集中到一个或几个线程当中进行处理。使用 NIO 代替阻塞 IO 能提高程序的并发吞吐能力，降低系统的开销。</p></blockquote><p><em>对于每一个请求，单独开一个线程进行响应的逻辑处理，如果客户端的数据传递并不是一直进行，而是断断续续的，则相应线程需要 IO 等待，并进行上下文切换。</em></p><p>Selector 机制使得线程不必等待客户端的 IO 就绪，当客户端还没就绪时，可以处理其他请求，提高了服务器的并发吞吐能力，降低了资源消耗。</p><h5 id="减少上下文切换"><a href="#减少上下文切换" class="headerlink" title="减少上下文切换"></a>减少上下文切换</h5><p>进程上下文切换会有一定的调度开销，这个过程中操作系统和JVM会消耗一定的CPU周期，并且由于CPU处理器会缓存一部分数据，当新线程被切换进来时，它所需要的数据可能不在CPU缓存中，因此还会导致CPU缓存的命中率下降。</p><h5 id="降低锁竞争"><a href="#降低锁竞争" class="headerlink" title="降低锁竞争"></a>降低锁竞争</h5><p>降低锁竞争的一种有效的方式是尽可能地缩短锁持有的时间，比如可以将一部分与锁无关的代码移出同步代码块，特别是执行起来开销较大的操作，以及可能使当前线程被阻塞的操作。<br>另一种减小锁持有时间的方式是减小锁的粒度，将原先使用单独锁来保护的多个变量变为采用多个相互独立的锁分别进行保护，这样就能够降低线程请求锁的几率，从而减少竞争发生的可能性。<strong>当然，使用的锁越多，发生死锁的风险也就越高。</strong><br>第三种降低锁竞争的方式就是放弃使用独占锁，而使用其他更友好的并发方式来保障数据的同步，原子变量就是使用读写锁。<br><em>对于多读少写的情况，使用读写锁能够比使用独占锁提供更高的并发数量。</em></p><h4 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h4><p>在进行数据传输之前，可以先将数据进行压缩，以减少网络传输的字节数，提升数据传输的速度。接收端可以将数据进行解压，以还原出传递的数据，并且经过压缩的数据还可以节约所耗费的存储介质(磁盘或内存)的空间与网络带宽，降低成本。<br>当然，压缩需要大量的CPU计算，并且根据压缩算法的不同，计算的复杂度和数据的压缩比也存在较大差异。</p><h4 id="结果缓存"><a href="#结果缓存" class="headerlink" title="结果缓存"></a>结果缓存</h4><p>本地缓存，分布式缓存</p><h4 id="数据库查询性能优化"><a href="#数据库查询性能优化" class="headerlink" title="数据库查询性能优化"></a>数据库查询性能优化</h4><p>以mysql为例</p><h5 id="合理使用索引"><a href="#合理使用索引" class="headerlink" title="合理使用索引"></a>合理使用索引</h5><blockquote><p>对于使用B树或B+树存储的组合索引来说，有一个最基本的原则，即“最左前缀”的原则，如果查询不是按照索引的最左列来开始查询，则无法使用到组合索引。</p></blockquote><h5 id="反范式设计"><a href="#反范式设计" class="headerlink" title="反范式设计"></a>反范式设计</h5><p>范式设计好处:</p><ul><li>冗余数据的减少，无疑节约了存储空间，而且保证了关系的一致性;</li><li>由于冗余数据的减少，当数据需要进行更新时，要修改的数据则变少了，这样会提升更新操作的速度;</li><li>范式化的表通常更小，可以更好地利用表的查询缓存来提高查询速度。<br><em>但是，对于大多数复杂的业务场景来说，数据表现的纬度不可能是单表的。因此在进行查询操作时，需要进行表的关联。这不仅代价高昂，由于查询条件指定的列可能并不在同一个表中，因此也无法使用到索引，这将导致数据库的性能严重下降。</em><blockquote><p>为了尽可能地避免关联查询带来的性能损耗，有人提出了反范式设计，即将一些常用的需要关联查询的列进行冗余存储，以便减少表关联带来的随机IO和全盘扫描。</p></blockquote></li></ul><h5 id="使用查询缓存"><a href="#使用查询缓存" class="headerlink" title="使用查询缓存"></a>使用查询缓存</h5><ul><li>query_cache_type</li><li>query_cache_size</li><li>query_cache_limit</li></ul><h5 id="使用搜索引擎"><a href="#使用搜索引擎" class="headerlink" title="使用搜索引擎"></a>使用搜索引擎</h5><blockquote><p>在分布式环境下，为了便于数据库扩展，提高并发处理能力，相关联的表可能并不在同一个数据库当中，而是分布在多个库当中，并且表也可能已经进行了切分，无法进行复杂的条件查询。这时候就需要搭建搜索引擎，将需要进行查询和展现的列通过一定的规则都建到索引当中，以提供复杂的垮表查询与分组操作。</p></blockquote><h5 id="使用-key-value-数据库"><a href="#使用-key-value-数据库" class="headerlink" title="使用 key-value 数据库"></a>使用 key-value 数据库</h5><blockquote><p>对于保有海量数据的互联网企业来说，多表的关联查询是非常忌讳的。出于性能的考虑，更多时候往往根据表的主键来进行查询，或者进行简单的条件查询。因此，SQL的功能被很大程度地弱化了。</p></blockquote><h5 id="GC-优化"><a href="#GC-优化" class="headerlink" title="GC 优化"></a>GC 优化</h5><p>Parallel Scavenge 垃圾收集器是悲观策略，每次晋升到 OldGen 的平均大小如果大于当前OldGen的剩余空间，则触发一次FullGC。如果频繁发生，可以通过-Xmx与-Xms参数来调整整个堆的大小，以增加OldGen的大小，YoungGen对应的-Xmn保持不变。<br>默认情况下，CMS收集器的垃圾回收会在OldGen使用了68%空间时被激活，可以调大。但如果预留的内存无法满足程序需要，则会出现 concurrent mode failure。</p><p><em>堆设置：</em></p><ul><li>Xms 是指程序启动时初始内存大小（此值可以设置成与-Xmx相同，以避免每次GC完成后 JVM 内存重新分配）。</li><li>Xmx 指程序运行时最大可用内存大小，程序运行中内存大于这个值会 OutOfMemory。</li><li>Xmn 年轻代大小（整个JVM内存大小 = 年轻代 + 年老代 + 永久代）。</li><li>XX:NewRatio 年轻代与年老代的大小比例，-XX:NewRatio=4 设置为4，则年轻代与年老代所占比值为1：4。</li><li>XX:SurvivorRatio 年轻代中Eden区与Survivor区的大小比值，-XX:SurvivorRatio=4，设置为4，则两个Survivor区与一个Eden区的比值为 2:4</li><li>XX:MaxPermSize 设置永久代大小。</li><li>XX:MaxTenuringThreshold 设置垃圾最大年龄。<br>如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</li><li>Xss 设置每个线程的堆栈大小。</li></ul><h5 id="硬件提升性能"><a href="#硬件提升性能" class="headerlink" title="硬件提升性能"></a>硬件提升性能</h5><p>内存越大越好，硬盘读写，避免网卡成为系统吞吐的瓶颈，CPU核数。</p><h2 id="Java-应用故障排查"><a href="#Java-应用故障排查" class="headerlink" title="Java 应用故障排查"></a>Java 应用故障排查</h2><h4 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h4><ul><li>jps  类似 linux 的 ps</li><li>jstat  对虚拟机各种运营状态进行监控的工具，通过它可以查看虚拟机的类加载与卸载情况，管理内存使用和垃圾收集等信息，监视JIT即时编译器的运行情况等。</li><li>jinfo  用于查看应用程序的配置参数，以及打印运行JVM时所指定的JVM参数。</li><li>jstack  用来生成虚拟机当前的线程快照信息，线程快照就是当前虚拟机每一个线程正在执行的方法堆栈的集合。</li><li>jmap  查看等待回收对象的队列，查看堆的概要信息，包括采用的是哪种GC收集器，堆空间的使用情况，以及通过JVM参数指定的各个内存空间的大小。</li><li>BTrace  是一个开源的 Java 程序动态跟踪工具。基本原理是通过Hotspot虚拟机的HotSwap技术将跟踪的代码动态替换到被跟踪的Java程序内，以观察程序运行的细节。通过BTrace脚本，可以在方法执行时，输出传递给方法的参数与方法的返回值。</li><li>JConsole  是一款JDK内置的图形化性能分析工具，它可以用来连接本地或者远程正在运行的JVM，对运行的Java应用程序的性能及资源消耗情况进行分析和监控，并提供可视化的图表对相关数据进行展现。</li><li>Memory Analyzer      Eclipse 插件</li><li>VisualVM  功能强大的 all-in-one 工具</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="调优" scheme="http://yeonsea.club/tags/%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>Writing &amp; Publishing your First NPM Package</title>
    <link href="http://yeonsea.club/2019/08/23/Writing&amp;Publishing_your_First_NPM_Package/"/>
    <id>http://yeonsea.club/2019/08/23/Writing&amp;Publishing_your_First_NPM_Package/</id>
    <published>2019-08-23T05:54:11.000Z</published>
    <updated>2019-08-24T12:16:00.779Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Just-do-it"><a href="#Just-do-it" class="headerlink" title="Just do it"></a>Just do it</h1><h2 id="NPM-account"><a href="#NPM-account" class="headerlink" title="NPM account"></a>NPM account</h2><ol><li><p>Create an NPM account if you don’t yet have one<br><a href="https://www.npmjs.com/" title="npm js" target="_blank" rel="noopener">npm js</a>. </p></li><li><p>Open terminal and …</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm adduser</span><br></pre></td></tr></table></figure></li></ol><p>** If you use taobao mirror, it will show 403 Forbidden. Then …<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry # show the current login source</span><br><span class="line">npm config set registry=http://registry.npmjs.org # change to the npmjs</span><br><span class="line">npm login # relogin</span><br></pre></td></tr></table></figure></p><h2 id="Create-a-component"><a href="#Create-a-component" class="headerlink" title="Create a component"></a>Create a component</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.exports.*** = ***</span><br></pre></td></tr></table></figure><h2 id="Create-a-new-repository-on-GitHub"><a href="#Create-a-new-repository-on-GitHub" class="headerlink" title="Create a new repository on GitHub"></a>Create a new repository on GitHub</h2><h2 id="Init-and-publish"><a href="#Init-and-publish" class="headerlink" title="Init and publish"></a>Init and publish</h2><p>Under the component, open the terminal</p><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">code .</span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin https://github.com/***/***.git</span><br><span class="line">git push -u origin master</span><br><span class="line">sudo git push -u origin master</span><br></pre></td></tr></table></figure><h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure><h2 id="Use-it"><a href="#Use-it" class="headerlink" title="Use it!"></a>Use it!</h2><p>create a new project<br>import<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i ** --save</span><br><span class="line">parser index.html</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Front-end" scheme="http://yeonsea.club/tags/Front-end/"/>
    
  </entry>
  
  <entry>
    <title>西尔维斯特-矩阵</title>
    <link href="http://yeonsea.club/2019/08/19/%E8%A5%BF%E5%B0%94%E7%BB%B4%E6%96%AF%E7%89%B9-%E7%9F%A9%E9%98%B5/"/>
    <id>http://yeonsea.club/2019/08/19/西尔维斯特-矩阵/</id>
    <published>2019-08-19T09:56:10.000Z</published>
    <updated>2019-08-20T09:38:57.123Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>西尔维斯特（James Joseph Sylvester, 1814~1897）</p><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>数量可以用二维数据表格来展示  </p><p>打猎得到的各种猎物和税金之间的关系可以用两个二维数据表格来表示  </p><table><thead><tr><th>00</th><th>兔子</th><th>鹿</th><th>野猪</th></tr></thead><tbody><tr><td>西尔维斯特</td><td>5只</td><td>1只</td><td>0只</td></tr><tr><td>东健</td><td>2只</td><td>0只</td><td>1只</td></tr><tr><td>小彬</td><td>0只</td><td>0只</td><td>2只</td></tr></tbody></table><table><thead><tr><th>猎物</th><th>税金</th></tr></thead><tbody><tr><td>兔子</td><td>20韩元</td></tr><tr><td>鹿</td><td>50韩元</td></tr><tr><td>野猪</td><td>100韩元</td></tr></tbody></table><p>运动器械和自行车的价格与需要购买的数量之间的关系可以用两个二维数据表格来表示  </p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>把数字或字母在括号内排列成二维数据表格就叫作矩阵。矩阵的各个数字或字母叫作元素。横向叫作行，纵向叫作列。  </p><p>矩阵的行数为m，列数为n时，矩阵的大小为m*n，行数和列数数目相等的矩阵叫作方块矩阵。  </p><p>元素都为0的矩阵叫作零矩阵；主对角线元素都为1，其余元素都是0的矩阵叫作单位矩阵。  </p><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>把方程组变成矩阵来解，可以进行一下运算：  </p><ol><li>某一行可以乘以一个常数：相当于一个方程的两边同时乘以一个常数。</li><li>某一行乘以一个常数后可以与另一行相加：相当于一个方程的两边同时乘以一个常数后再与另一个方程相加。</li><li>行与行可以对调：方程的顺序对调后，解不变。</li></ol><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>方程组<br>$$<br>\begin{cases}<br>   ax+by=p \\<br>   cx+dy=q<br>\end{cases}<br>$$<br>用矩阵表达式如下<br>$$<br>\begin{pmatrix}<br>   a &amp; b \\<br>   c &amp; d<br>\end{pmatrix}<br>\begin{pmatrix}<br>   x \\<br>   y<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>   p \\<br>   q<br>\end{pmatrix}<br>$$<br>可以简单表示为<br>$$<br>\begin{pmatrix}<br>   a &amp; b &amp;: &amp;p  \\<br>   c &amp; d &amp;: &amp;q<br>\end{pmatrix}<br>$$</p><hr><p>矩阵的某一行乘以一个常数后形成的新矩阵，求出的解是同一个方程组的解。  </p><p>矩阵的某一行乘以一个常数后与另一行相加形成的新矩阵，求出的解是同一个方程组的解。  </p><p>方程组构成的矩阵，行与行可以对调，对调后方程组的解不变。  </p><h1 id="5"><a href="#5" class="headerlink" title="5"></a>5</h1><p>可以将下面的三元一次方程组变成矩阵来解<br>$$<br>\begin{cases}<br>   a_{11}x+a_{12}y+a_{13}z=p \\<br>   a_{21}x+a_{22}y+a_{23}z=q \\<br>   a_{31}x+a_{32}y+a_{33}z=r<br>\end{cases}<br>$$</p><p>$$<br>\begin{pmatrix}<br>   a_{11} &amp; a_{12} &amp; a_{13} &amp;: &amp;p  \\<br>   a_{21} &amp; a_{22} &amp; a_{23} &amp;: &amp;q  \\<br>   a_{31} &amp; a_{32} &amp; a_{33} &amp;: &amp;r<br>\end{pmatrix}<br>$$</p><h1 id="6"><a href="#6" class="headerlink" title="6"></a>6</h1><p>两个矩阵相等是指两个矩阵中所有的元素对应相等。  </p><p>两个矩阵之间对应的元素相加，可以实现两个矩阵之间的加法运算。</p><p>一个矩阵的各元素可以乘以某个常数。  </p><p>两个矩阵之间对应的元素相减，可以实现两个矩阵之间的减法运算。</p><h1 id="7"><a href="#7" class="headerlink" title="7"></a>7</h1><p>两个矩阵相乘，前面矩阵的列数要与后面矩阵的行数相等。这时乘积的大小由前面矩阵的行数和后面矩阵的列数决定。即<br>$$<br>A_{m×n}B_{n×t}=C_{m×t}<br>$$</p><hr><p>前面矩阵的第i行和后面矩阵的第j列的各对应元素的乘积之和，构成乘积矩阵中的(i, j)元素。  </p><p>寻找日常生活中可以用矩阵乘积表示的问题。</p><h1 id="8"><a href="#8" class="headerlink" title="8"></a>8</h1><p>可求出方块矩阵<br>$$<br>\begin{pmatrix}<br>   a &amp; b \\<br>   c &amp; d<br>\end{pmatrix}<br>$$<br>的逆矩阵  </p><p>$$<br>{\begin{pmatrix}<br>   a &amp; b \\<br>   c &amp; d<br>\end{pmatrix}}^{-1}<br>= {1 \over ad - bc}<br>\begin{pmatrix}<br>   d &amp; -b \\<br>   -c &amp; a<br>\end{pmatrix}<br>(ad-bc \ne 0)<br>$$</p><hr><p>利用逆矩阵求二元一次方程组<br>$$<br>\begin{cases}<br>   ax+by=p \\<br>   cx+dy=q<br>\end{cases}<br>$$<br>的解。首先像下面这样用矩阵表示方程：<br>$$<br>\begin{pmatrix}<br>   a &amp; b \\<br>   c &amp; d<br>\end{pmatrix}<br>\begin{pmatrix}<br>   x \\<br>   y<br>\end{pmatrix}<br>=<br>\begin{pmatrix}<br>   p \\<br>   q<br>\end{pmatrix}<br>$$<br>然后式子两边靠左的位置写上<br>$$<br>\begin{pmatrix}<br>   a &amp; b \\<br>   c &amp; d<br>\end{pmatrix}<br>$$<br>的逆矩阵，再做乘法运算。<br>$$<br>\begin{pmatrix}<br>   x \\<br>   y<br>\end{pmatrix}<br>=<br>{\begin{pmatrix}<br>   a &amp; b \\<br>   c &amp; d<br>\end{pmatrix}}^{-1}<br>\begin{pmatrix}<br>   p \\<br>   q<br>\end{pmatrix}<br>$$<br>--</p><p>$$<br>\begin{pmatrix}<br>   x \\<br>   y<br>\end{pmatrix}<br>=<br>{1 \over ad - bc}<br>\begin{pmatrix}<br>   d &amp; -b \\<br>   -c &amp; a<br>\end{pmatrix}<br>\begin{pmatrix}<br>   p \\<br>   q<br>\end{pmatrix}<br>=<br>{1 \over ad - bc}<br>\begin{pmatrix}<br>   dp-bq \\<br>   -cp+aq<br>\end{pmatrix}<br>(ad-bc \ne 0)<br>$$<br>--</p><p>$$<br>x={dp-bq \over ad-bc}, y={-cp+aq \over ad-bc}<br>$$</p><h1 id="9"><a href="#9" class="headerlink" title="9"></a>9</h1><p>研究是否可以用矩阵表示身边的实际问题。思考如何确定一个矩阵的各个元素。  </p><p>利用矩阵解决问题，预测未来</p><p><strong>各列元素的和等于1的矩阵用俄国数学家马尔可夫的名字命名为马尔可夫转移矩阵。</strong><br>这个矩阵经常用来表示某种变化的概率，某个地区的人口变化、市场经济的版图变化等，我们周围的各种变化都可以用这样的矩阵表示，帮助我们有效地解决问题。  </p><p>老鼠房间概率<br>城市邻接矩阵  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Math" scheme="http://yeonsea.club/categories/Math/"/>
    
    
      <category term="Basic" scheme="http://yeonsea.club/tags/Basic/"/>
    
  </entry>
  
  <entry>
    <title>布隆过滤器</title>
    <link href="http://yeonsea.club/2019/03/12/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>http://yeonsea.club/2019/03/12/布隆过滤器/</id>
    <published>2019-03-12T01:17:12.000Z</published>
    <updated>2019-08-20T10:11:51.564Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><h2 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器"></a>什么是布隆过滤器</h2><p>布隆过滤器是一种基于概率进行验重的数据结构。它的基本原理是：小概率事件不容易同时发生。</p><p>布隆过滤器使用多个哈希函数把同一个字符串转换成多个不同的哈希值，并记录这些哈希值的特征。下次再面对一个字符串时，布隆过滤器再次使用这些哈希函数把这个字符串转换为多个哈希值。如果这个哈希值全部符合原先那个字符串对应的各个哈希值的特征，则认为这两个字符串是相同的。</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希算法不是一种加密算法，而是一种不可逆的摘要算法。<br>不同的哈希函数可实现不同的哈希算法。<br>使用同一个哈希算法，能够把同一个字符串转成同一个哈希值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">code = <span class="string">'hello'</span></span><br><span class="line">result = hashlib.sha256(code.encode()).hexdigest()</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>结果是一个十六进制的_数_</p><h2 id="布隆过滤器的原理"><a href="#布隆过滤器的原理" class="headerlink" title="布隆过滤器的原理"></a>布隆过滤器的原理</h2><ol><li>假设K个哈希函数，对同一个字符串计算哈希值，得到K个完全不同的哈希值。</li><li>让这K个哈希值同时除以一个数M，就可以得到K个余数。</li><li>对于一个新的字符串，重复这个过程，如果新字符串获得的K个余数与原来的字符串对应的K个余数完全相同，那么就可以说，这两个字符串”很有可能”是同一个字符串。</li></ol><p>$$<br>1-(1-e^{\frac{-KN}{M}})^{K}<br>$$</p><h2 id="如何压缩数据容量"><a href="#如何压缩数据容量" class="headerlink" title="如何压缩数据容量"></a>如何压缩数据容量</h2><p>采用二进制保存数字</p><h2 id="布隆过滤器与Redis结合"><a href="#布隆过滤器与Redis结合" class="headerlink" title="布隆过滤器与Redis结合"></a>布隆过滤器与Redis结合</h2><p>使用Redis字符串的位操作，记录K个余数的位置即可。</p><h2 id="布隆过滤器的弊端"><a href="#布隆过滤器的弊端" class="headerlink" title="布隆过滤器的弊端"></a>布隆过滤器的弊端</h2><p>布隆过滤器只能单向验证重复。<br>随着Redis字符串对应的二进制位越来越多的为被设置为1，布隆过滤器误报的概率越来越大，因为可能其它多个字符串对应的二进制位中越来越多的位被设置为1，其中K个值刚好和一个新来的字符串的K个余数重合。<br>提前规划好数据规模与容忍的误报率。  </p><blockquote><p>最多需要对 n 个字符串进行验证重复操作，能够容忍的最大误报率为 p，那么，布隆过滤器将会使用到的二进制位的数量为：</p></blockquote><p>$$<br>m = -\frac{n\ln{p}}{\ln{2}^{2}}<br>$$</p><blockquote><p>哈希函数的个数为：</p></blockquote><p>$$<br>k = \frac{m}{n}\ln{2}<br>$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Web" scheme="http://yeonsea.club/categories/Web/"/>
    
    
      <category term="Web" scheme="http://yeonsea.club/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>用 Spring Boot 编写 RESTful API</title>
    <link href="http://yeonsea.club/2018/12/23/%E7%94%A8SpringBoot%E7%BC%96%E5%86%99RESTfulAPI/"/>
    <id>http://yeonsea.club/2018/12/23/用SpringBoot编写RESTfulAPI/</id>
    <published>2018-12-23T12:17:58.000Z</published>
    <updated>2018-12-23T12:31:19.484Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2018/12/23/用SpringBoot编写RESTfulAPI/../用SpringBoot编写RESTfulAPI/spring-boot-project-logo.png"></p><h2 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h2><p><a href="https://study.163.com/course/courseMain.htm?courseId=1005213034" target="_blank" rel="noopener">课程</a></p><h2 id="开始一个最简单的RESTFul-API项目"><a href="#开始一个最简单的RESTFul-API项目" class="headerlink" title="开始一个最简单的RESTFul API项目"></a>开始一个最简单的RESTFul API项目</h2><h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><p>Representational State Transfer</p><p>所有的东西都是资源，所有的操作都是通过对资源的增删改查（CRUD）实现</p><p>对资源的增删改查对应对URL的操作（POST,DELETE,PUT,GET）</p><p>无状态的</p><h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><p>大量使用注解，减少配置，无需配置XML<br>自带嵌入式web服务器</p><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><p>pom.xml文件是Maven项目的配置文件<br>几个常用的Maven命令（在pom.xml同级目录下运行）<br>mvn test 编译并运行测试用例<br>mvn spring-boot:run 运行spring-boot项目<br>mvn package 打包项目<br>mvn clean 可以和其它命令一起使用，例如mvn clean package</p><h3 id="日期型转JSON格式"><a href="#日期型转JSON格式" class="headerlink" title="日期型转JSON格式"></a>日期型转JSON格式</h3><p>可以在属性上增加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@JsonFormat(timezone=&quot;GMT+8&quot;, pattern=&quot;yyyy-MM-dd&quot;)</span><br></pre></td></tr></table></figure></p><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@JsonFormat（shape=JsonFormat.Shape.NUMBER）</span><br></pre></td></tr></table></figure><p>全局修改可以在application.yml  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:  </span><br><span class="line">  jackson:  </span><br><span class="line">    date-format: yyyy-MM-dd #如果使用字符串表示，用这行设置格式  </span><br><span class="line">    timezone: GMT+8  </span><br><span class="line">    serialization:   </span><br><span class="line">      write-dates-as-timestamps: true #使用数值timestamp表示日期</span><br></pre></td></tr></table></figure><h2 id="RestController详解"><a href="#RestController详解" class="headerlink" title="RestController详解"></a>RestController详解</h2><h3 id="热部署（Hot-Swapping）"><a href="#热部署（Hot-Swapping）" class="headerlink" title="热部署（Hot Swapping）"></a>热部署（Hot Swapping）</h3><p>pom中加入devtools</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h3><p>Commons-logging or SLF4j</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private static final Log log = LogFactory.getLog(Xxx.class);</span><br><span class="line">private static final Logger log = LoggerFactory.getLogger(Xxx.class);</span><br></pre></td></tr></table></figure><p>日志级别：TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL<br>application.yml配置日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  file: target/app.log</span><br><span class="line">  level: </span><br><span class="line">    ROOT: WARN</span><br><span class="line">    cn.devmgr: TRACE</span><br></pre></td></tr></table></figure></p><h3 id="命令行工具CURL"><a href="#命令行工具CURL" class="headerlink" title="命令行工具CURL"></a>命令行工具CURL</h3><p>测试工具<br><a href="https://www.getpostman.com/" target="_blank" rel="noopener">postman</a></p><h3 id="在RestController中获取各种相关信息的方法"><a href="#在RestController中获取各种相关信息的方法" class="headerlink" title="在RestController中获取各种相关信息的方法"></a>在RestController中获取各种相关信息的方法</h3><table><thead><tr><th>内容</th><th>获取方法</th></tr></thead><tbody><tr><td>URL中路径的一部分</td><td>首先需要在RequestMapping做映射，之后在方法中可以通过注解使用映射的变量。可以写多个，@PutMapping(“/{id}/characters/{cId}”)，还可以使用正则表达式限制类型（不符合要求会返回4xx的错误信息，表示请求参数有问题）此例子表示id必须是数字：@PutMapping(“/{id:\\d+}”)</td></tr><tr><td>POST方法传递过来的JSON</td><td>给参数前增加@RequestBody注解，Spring会自动把POST的Request Body部分的JSON转换成方法声明的类。如果转化失败会返回4xx错误，表示请求参数有问题。</td></tr><tr><td>POST方法传递的是表单数据</td><td>首先声明传入的是application/x-wwww-form-urlencoded的格式，可在RequestMapping增加consumes参数，@PostMapping(value=”/tvseries”, consumes=MediaType.APPLICATION_FORM_URLENCODED_VALUE)，在方法上增加参数，参数使用@RequestParam注解即可，public Object insert(@RequestParam(value=”name”, required=false) String name)，凡是可以通过HttpServletRequest.getParameter(String)方法取到的值，含表单提交的、QueryString附带的，都可以使用@RequestParam注解得到。默认是request=true。</td></tr><tr><td>QueryString的参数</td><td>使用@RequestParam注解，通过参数获得,例如：public Object query(@RequestParam(value=”page”, required=false) Integer page)</td></tr><tr><td>Request Header</td><td>可以使用@Requestheader注解获取Request的头信息,例如public ResultJSON editCompany(@RequestHeader(“user-agent”) String userAgent) 注意：@RequestHeader后面的头名字不区分大小写，但RequestParam, PathVariable等是区分的。如果RequestHeader后面不写参数，会用后面的变量名替代。</td></tr><tr><td>获取cookie值</td><td>使用cookieValue注解，和其它类似，除非为了兼容老现有客户端，新API里不建议用cookie。</td></tr><tr><td>获取当前的Request Response</td><td>直接写参数，例如：public Object doSomething(HttpServletRequest request, HttpServletResponse response)</td></tr><tr><td>获取当前用户</td><td>直接在方法上增加参数，类型为org.springframework.security.core.Authentication, 例如：public TvSeries deleteOne(Authentication auth)，参数auth内会存储有当前的用户信息。</td></tr><tr><td>文件上传</td><td>首先要设置consumes为multipart/form-data，@PostMapping(value=”/files”, consumes=MediaType.MULTIPART_FORM_DATA_VALUE),在方法中写参数 public Map&lt;String, Object&gt; uploadFile(@RequestParam(“file”) MultipartFile file)。在方法中可以直接使用MultipartFile中的流保存文件了。</td></tr></tbody></table><h3 id="对客户端传入数据的校验"><a href="#对客户端传入数据的校验" class="headerlink" title="对客户端传入数据的校验"></a>对客户端传入数据的校验</h3><p>原则：不要相信前端传过来的数据；尽量要前端少传递数据</p><p>Bean Validation: JSR303, Hibernate Validator</p><p>Bean Validation 注解：<br>@Null<br>@NotNull<br>@Min<br>@Max<br>@Size<br>@Past  验证Date<br>@Future<br>@AssertTrue  验证Boolean<br>@AssertFalse<br>@Valid 级联验证注解</p><table><thead><tr><th>类型</th><th>注解</th></tr></thead><tbody><tr><td>任何类型</td><td>NULL, NotNull</td></tr><tr><td>布尔型</td><td>AssertTrue, AssertFalse</td></tr><tr><td>字符串</td><td>NotBlank, Pattern, Size, Email, DecimalMin, Digits</td></tr><tr><td>数值</td><td>DecimalMax, DecimalMin, Digits, Max, Min, NegativeOrZero, Positive, PositiveOrZero</td></tr><tr><td>集合、Map、List</td><td>NotEmpty, Size</td></tr><tr><td>日期</td><td>Future, Past, FutureOrPresent, PastOrPresent</td></tr></tbody></table><blockquote><p>以上注解都指Bean Validation 2.0 定义的注解，在javax.validation.constraints包下。Hibernate有些非JSR标准注解和上面的同名但package不同，功能会和上面这些有些细微差异。</p></blockquote><p>约束规则对子类依旧有效<br>groups参数  </p><ul><li>每个约束用注解都有一个groups参数</li><li>可接收多个class类型（必须是接口）</li><li>不声明groups参数是默认组javax.validation.groups.Default</li><li>声明了groups参数的会从Default组移除，如需加入Default组需要显示声明，例如@Null(groups={Default.class, Step1.class})</li></ul><p>@Valid vs @Validated</p><ul><li>@Valid是JSR标准定义的注解，只验证Default组的约束</li><li>@Validated是Spring定义的注解，可以通过参数来指定验证的组，例如：@Validation({Step1.class,Default.class})表示验证Step1和Default两个组的约束</li><li>@Valid可用在成员变量上，进行级联验证；@Validated只能用在参数上，表示这个参数需要验证<blockquote><p>参数中只用@Validated，通不过校验的参数，不会执行这个方法，加上BindingResult result ，参数通不过校验也会进入方法执行，校验结果会通过result参数传递进来。</p></blockquote></li></ul><p>手动验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 装载验证器</span><br><span class="line">@Autowired Validator validator;</span><br><span class="line">// 验证某个类，下面是执行默认的验证组，如果需要指定验证组，多传一个class参数</span><br><span class="line">Set&lt;ConstraintViolation&lt;?&gt;&gt; result = validator.validate(obj);</span><br><span class="line">// 通不过校验result的集合会有值，可以通过size()判断</span><br></pre></td></tr></table></figure><h2 id="在Spring-Boot项目中使用Mybatis"><a href="#在Spring-Boot项目中使用Mybatis" class="headerlink" title="在Spring Boot项目中使用Mybatis"></a>在Spring Boot项目中使用Mybatis</h2><h3 id="程序的层次结构"><a href="#程序的层次结构" class="headerlink" title="程序的层次结构"></a>程序的层次结构</h3><p>Web前端、App、小程序、其它系统等<br>Web控制层：@RestController @Controller<br>业务逻辑层：@Service<br>数据访问层：@Repository<br>@Component<br>数据库</p><p>PBF: Package by Feature 按功能划分<br>PBL: Package by Layer 按层次划分  </p><h3 id="相邻层次的数据传输"><a href="#相邻层次的数据传输" class="headerlink" title="相邻层次的数据传输"></a>相邻层次的数据传输</h3><ul><li>PO：Persistant Object 持久对象</li><li>DTO：Data Transfer Object 数据传输对象</li><li>VO：Value Object 或 View Object</li><li>POJO：Pure Old Java Object 或 Plain Ordinary Java Object</li><li>DO：Domain Object</li><li>BO：Business Object 处理业务逻辑</li><li>DAO：Data Access Object</li></ul><p>JavaBean:  </p><ul><li>有一个public的无参构造方法</li><li>属性private，且可以通过get、set、is（可以替代get，用在布尔型属性上）方法或遵循特定命名规范的其它方法访问</li><li>可序列化，实现Serializable接口</li></ul><p>POJO vs JavaBean:</p><ul><li>POJO比javabean更简单。POJO严格的遵守简单对象的概念，而一些JavaBean中往往会封装一些简单逻辑。</li><li>POJO主要用于数据的临时传递，它只能装载数据，作为数据存储的载体，不具有业务逻辑处理能力。</li><li>JavaBean虽然数据的获取与POJO一样，但是javabean当中可以有其他方法。</li></ul><p>几种简化方案：  </p><ul><li>一种POJO从web控制层到数据访问层</li><li>用JavaBean代替POJO</li><li>POJO的get,set写起来也麻烦，用public的field代替</li></ul><h3 id="添加Mybatis支持步骤"><a href="#添加Mybatis支持步骤" class="headerlink" title="添加Mybatis支持步骤"></a>添加Mybatis支持步骤</h3><ol><li>修改pom.xml，添加mybatis支持</li><li>修改application.yml添加数据库连接</li><li>修改启动类，增加@MappingScan(“package-of-mapping”)注解</li><li>添加Mybatis Mapping接口</li><li>添加Mapping对应的XML（可选）</li></ol><p>pom.xml中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.postgresql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>application.yml中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    dbcp2.validation-query: select 1</span><br><span class="line">    driverClassName: org.postgresql.Driver</span><br><span class="line">    url: jdbc:postgresql://127.0.0.1:5432/thedb?stringtype=unspecified</span><br><span class="line">    username: </span><br><span class="line">    password:</span><br></pre></td></tr></table></figure><h2 id="Spring-Boot-项目的单元测试"><a href="#Spring-Boot-项目的单元测试" class="headerlink" title="Spring Boot 项目的单元测试"></a>Spring Boot 项目的单元测试</h2><h3 id="Assert-JUnit的断言"><a href="#Assert-JUnit的断言" class="headerlink" title="Assert-JUnit的断言"></a>Assert-JUnit的断言</h3><ul><li>判断某条件是否为真 Assert.assertTrue(条件表达式)；</li><li>判断某条件是否为假 Assert.assertFalse(条件表达式)；</li><li>判断两个变量值是否相同 Assert.assertEquals(val1, val2);</li><li>判断两个变量值是否不相同 Assert.assertNotEquals(val1, val2);</li><li>判断两个数组是否相同 Assert.assertArrayEquals(数组1, 数组2)；</li><li>直接测试失败 Assert.fail()  Assert.fail(message)</li></ul><h3 id="Assert-vs-assert"><a href="#Assert-vs-assert" class="headerlink" title="Assert vs assert"></a>Assert vs assert</h3><ul><li>Assert是JUnit的断言类，全名是org.junit.Assert</li><li>Assert提供了很多静态方法，例如…</li><li>assert是java关键字，使用方法有两种，表达式为false时，jvm会退出；</li><li>assert关键字内表达式是否被检查成立依赖jvm的参数，默认是关闭的<blockquote><p>Java命令行参数：-ea (enableassertions)  -da (disableassertions 默认)</p></blockquote></li></ul><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>驱动模块</li><li>被测模块</li><li>桩模块 使用场景：替代尚未开发完毕的子模块；替代对环境依赖较大的子模块（例如数据访问层）；</li></ul><h3 id="mockito"><a href="#mockito" class="headerlink" title="mockito"></a>mockito</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mockito&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mockito-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="TDD"><a href="#TDD" class="headerlink" title="TDD"></a>TDD</h3><ul><li>Test Driven Development (测试驱动开发)</li><li>先写测试用例，后写实现代码</li><li>重构现有代码时特别好用<blockquote><p>RDD: Resume Driven Development</p></blockquote></li></ul><h2 id="在-Spring-中管理数据库事务"><a href="#在-Spring-中管理数据库事务" class="headerlink" title="在 Spring 中管理数据库事务"></a>在 Spring 中管理数据库事务</h2><h3 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h3><ul><li>name 当在配置文件中有多个TransactionManager,可以用该属性指定选择哪个事务管理器。</li><li>propagation 事务的传播行为，默认值为REQUIRED。</li><li>isolation 事务的隔离度，默认采用DEFAULT。</li><li>timeout 事务的超时时间，默认值为-1,。如果超过该时间限制但事务还没有完成，则自动回滚事务。</li><li>readOnly 指定事务是否为只读事务，默认值为false；为了忽略那些不需要事务的方法，比如读取数据，可以设置readOnly为true。</li><li>rollbackFor 指定能够触发事务回滚的异常类型。</li><li>noRollbackFor 指定的异常类型，不回滚事务<blockquote><p>1.noRollbackFor或子类；2.rollbackFor或子类；3.throws定义的异常或子类；4.其它异常；5.无异常</p></blockquote></li></ul><h3 id="Transactional-propagation-xx"><a href="#Transactional-propagation-xx" class="headerlink" title="@Transactional(propagation=xx)"></a>@Transactional(propagation=xx)</h3><ol><li>propagation.REQUIRED 如果有事务，那么加入事务，没有的话新建一个（默认）</li><li>propagation.NOT_SUPPORTED 容器不为这个方法开启事务</li><li>propagation.REQUIRED_NEW 不管是否存在事务，都创建一个新的事务，原来的挂起，新的执行完毕，继续执行老的事务</li><li>propagation.MANDATORY 必须在一个已有的事务中执行，否则抛出异常</li><li>propagation.NEVER 必须在一个没有的事务中执行，否则抛出异常（与propagation.MANDATORY相反）</li><li>propagation.SUPPORTS 如果其它bean调用这个方法，在其它bean中声明事务，那就用事务，如果其它bean没有声明事务那就不用事务</li><li>propagation.NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与propagation.REQUIRED类似的操作</li></ol><h3 id="Transactional-isolation-xx"><a href="#Transactional-isolation-xx" class="headerlink" title="@Transactional(isolation=xx)"></a>@Transactional(isolation=xx)</h3><ol><li>Isolation.READ_UNCOMMITTED 读未提交数据 （脏读、不可重复读、幻读）</li><li>Isolation.READ_COMMITTED 读已提交数据（不可重复读、幻读）</li><li>Isolation.REPEATABLE_READ 可重复读 （幻读）</li><li>Isolation.SERIALIZATION 串行化 </li><li>Isolation.DEFAULT 使用数据库默认</li></ol><h3 id="Isolation-vs-Lock"><a href="#Isolation-vs-Lock" class="headerlink" title="Isolation vs Lock"></a>Isolation vs Lock</h3><ul><li>两个不同的东西，隔离不是靠锁实现的，是靠对数据的监控实现的。</li><li>锁：表加好锁了，除非出现死锁等特殊情况，事务是不会被数据库主动回滚的。</li><li>隔离：如果发现数据不符合数据库隔离级别，当前事务会出错并回滚。相比锁被回滚可能性较大，需要程序有出错重试的步骤。</li></ul><h3 id="Transactional注解的timeout参数"><a href="#Transactional注解的timeout参数" class="headerlink" title="@Transactional注解的timeout参数"></a>@Transactional注解的timeout参数</h3><ul><li>timeout事务的超时时间，默认值为-1,。如果超过该时间限制但事务还没有完成，则自动回滚事务。</li><li>方法抛出异常，事务被回滚，可能是SQL执行时间过长的异常，也可能是TransactionTimedOutException</li><li>从方法执行开始计算，每个SQL执行前检查一次是否超时，方法全部执行完毕后不检查是否超时</li></ul><h2 id="Mybatis进阶"><a href="#Mybatis进阶" class="headerlink" title="Mybatis进阶"></a>Mybatis进阶</h2><h3 id="复杂类的ORMapping和主子表的同时数据插入"><a href="#复杂类的ORMapping和主子表的同时数据插入" class="headerlink" title="复杂类的ORMapping和主子表的同时数据插入"></a>复杂类的ORMapping和主子表的同时数据插入</h3><p>#{}可转义 ${} 不可转义（可能导致sql注入）  </p><h3 id="使用TypeHandler处理枚举、数组、JSON等特殊类型"><a href="#使用TypeHandler处理枚举、数组、JSON等特殊类型" class="headerlink" title="使用TypeHandler处理枚举、数组、JSON等特殊类型"></a>使用TypeHandler处理枚举、数组、JSON等特殊类型</h3><p>EnumTypeHandler vs EnumOrdinalTypeHandler</p><ul><li>EnumTypeHandler存储的是对应类的名字，可以存储成一个字符串</li><li>EnumOrdinalTypeHandler存储的是枚举类型的顺序</li></ul><p>ArrayTypeHandler<br>自定义JsonTypeHandler</p><h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2><h3 id="安全控制的层级"><a href="#安全控制的层级" class="headerlink" title="安全控制的层级"></a>安全控制的层级</h3><ul><li>基于URL的控制</li><li>基于方法的控制</li><li>程序内</li></ul><h3 id="配置Spring-Security"><a href="#配置Spring-Security" class="headerlink" title="配置Spring Security"></a>配置Spring Security</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSecurity</span><br><span class="line">@EnableGlobalMethodSecurity(prePostEnabled = true, jsr250Enabled = false)</span><br><span class="line">public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    private final static Log log = LogFactory.getLog(WebSecurityConfig.class);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity httpSecurity) throws Exception &#123;</span><br><span class="line">        if (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(&quot;configure httpSecurity...&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //默认的spring-security配置会让所有的请求都必须在已登录的状况下访问；下面这段代码禁止了这种操作。</span><br><span class="line">        httpSecurity.csrf().disable()</span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()</span><br><span class="line">                .authorizeRequests().anyRequest().permitAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-Security-注解"><a href="#Spring-Security-注解" class="headerlink" title="Spring Security 注解"></a>Spring Security 注解</h3><p>@EnableGlobalMethodSecurity(prePostEnable=true, securedEnable=true, jsr250Enabled=true)<br>prePostEnable=true: @PreAuthorize @PostAuthorize @PreFilter @PostFilter<br>securedEnable=true: @Secured<br>jsr250Enable: @RolesRequied (JSR250)  </p><h3 id="PreAuthorize-PostAuthorize-中常用的表达式"><a href="#PreAuthorize-PostAuthorize-中常用的表达式" class="headerlink" title="@PreAuthorize @PostAuthorize 中常用的表达式"></a>@PreAuthorize @PostAuthorize 中常用的表达式</h3><ul><li>hasRole(‘user’, ‘admin’)  hasAnyRole(‘user’, ‘admin’)</li><li>hasAuthority(‘query’, ‘update’)   hasAnyAuthority(‘query’, ‘update’)</li><li>permitAll denyAll</li><li>principal, authentication 当前用户</li></ul><h3 id="Role-vs-Authorization"><a href="#Role-vs-Authorization" class="headerlink" title="Role vs Authorization"></a>Role vs Authorization</h3><ul><li>ROLE_开头则是role</li><li>JSR250 RolesAllowed全部要求是role</li><li>Spring EL中hasRole也要求是role hasAuthority则不用ROLE_开头</li></ul><h3 id="Controller内获取当前用户"><a href="#Controller内获取当前用户" class="headerlink" title="Controller内获取当前用户"></a>Controller内获取当前用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Object doSomething(Authentication auth)&#123;</span><br><span class="line">    User u = (User) auth.getPrincipal();</span><br><span class="line">&#125;</span><br><span class="line">或  </span><br><span class="line">Authentication auth = SecurityContextHolder.getContext().getAuthentication();</span><br></pre></td></tr></table></figure><h3 id="启用Spring-Security"><a href="#启用Spring-Security" class="headerlink" title="启用Spring Security"></a>启用Spring Security</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="OpenId"><a href="#OpenId" class="headerlink" title="OpenId"></a>OpenId</h3><ul><li>提供用户追踪方式</li><li>无需使用用户名密码登录</li><li>协议2.0版提供属性交换功能</li><li>目前已经很少使用</li></ul><h3 id="OAuth开放授权"><a href="#OAuth开放授权" class="headerlink" title="OAuth开放授权"></a>OAuth开放授权</h3><ul><li>目前是OAuth2.0</li><li>2.0不兼容1.0</li><li>密码无需告诉第三方</li><li>为用户提供一个令牌，允许通过令牌访问资源</li></ul><h3 id="OAuth-2-0-Grant-Types"><a href="#OAuth-2-0-Grant-Types" class="headerlink" title="OAuth 2.0 Grant Types"></a>OAuth 2.0 Grant Types</h3><ul><li>授权码模式 Authorization Code</li><li>简化模式 Implicit</li><li>密码模式 Password</li><li>客户端模式 Client Credentials</li><li>Refresh Token</li></ul><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><ul><li>JSON Web Token</li><li>三部分：Header、Playload、Verify Signature</li><li>Header：头部信息，声明类型和加密算法</li><li>Playload：载荷</li><li>Verify Signature：签名，用于验证头部和载荷部分是否被修改过</li></ul><h3 id="JWT的加密方式"><a href="#JWT的加密方式" class="headerlink" title="JWT的加密方式"></a>JWT的加密方式</h3><ul><li>HMAC  共用一个秘钥</li><li>SHA256    公钥私钥分开</li></ul><h3 id="生成JWT和验证JWT的jar"><a href="#生成JWT和验证JWT的jar" class="headerlink" title="生成JWT和验证JWT的jar"></a>生成JWT和验证JWT的jar</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.auth0&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>网站：<a href="https://github.com/auth0/java-jwt" target="_blank" rel="noopener">https://github.com/auth0/java-jwt</a>  </p><h2 id="Spring-Async-Scheduling-amp-Cache"><a href="#Spring-Async-Scheduling-amp-Cache" class="headerlink" title="Spring Async, Scheduling &amp; Cache"></a>Spring Async, Scheduling &amp; Cache</h2><h3 id="Spring-Async-异步执行"><a href="#Spring-Async-异步执行" class="headerlink" title="Spring Async 异步执行"></a>Spring Async 异步执行</h3><p>配置：@EnableAsync (@SpringBootApplication 那里)<br>使用：@Async （方法上）<br>@Async方法返回值：  </p><ul><li>void</li><li>Future<t></t></li><li>其他类型一律返回null；遇到int/double/float/boolean基本类型，执行时会抛出异常：AopInvocationException;</li></ul><h3 id="Spring-Scheduling"><a href="#Spring-Scheduling" class="headerlink" title="Spring Scheduling"></a>Spring Scheduling</h3><p>使用：</p><ul><li>@EnableScheduling 注解启用Scheduling</li><li>方法上加@Scheduled注解，方法会按照参数定期执行<br>@Scheduled 参数：</li><li>cron 值为字符串</li><li>zone 设置时区</li><li>fixedDelay (单位毫秒)，每次方法执行完毕后，休息固定时间后再次启动</li><li>fixedRate (单位毫秒)按照固定频率启动执行<br>-initialDelay (单位毫秒)，和上面三个参数搭配使用，首次执行延时 </li></ul><p>集群/负载均衡环境</p><ul><li>独立出来一个application运行scheduling task</li><li>使用：Quartz Scheduler</li></ul><h3 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h3><p>缓存：  </p><ul><li>利用java程序中的变量（简单；集群环境中多个实例无法同步）</li><li>缓存服务器（Memcached，Redis）<br>Spring中通过注解使用缓存  </li><li>@EnableCaching启用缓存注解</li><li>@Cacheable</li><li>@CacheEvict</li><li>@CachePut</li><li>@CacheConfig</li></ul><h3 id="使用-Redis-缓存服务"><a href="#使用-Redis-缓存服务" class="headerlink" title="使用 Redis 缓存服务"></a>使用 Redis 缓存服务</h3><p>POM中加入依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependecy&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>application.yml 中加入配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cache:</span><br><span class="line">    redis:</span><br><span class="line">      time-to-live: 3306</span><br><span class="line">  redis:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 6379</span><br><span class="line">    pool:</span><br><span class="line">      max-active: 5</span><br><span class="line">      max-idle: 10</span><br><span class="line">      max-wait: 10000</span><br></pre></td></tr></table></figure><h2 id="Websocket-amp-JMS"><a href="#Websocket-amp-JMS" class="headerlink" title="Websocket &amp; JMS"></a>Websocket &amp; JMS</h2><p>Websocket</p><ul><li>全双工通道，数据双向传输</li><li>浏览器和服务器之间的持久性的连接</li><li>比轮询/长轮询大幅节省资源</li><li>使用80/443等HTTP端口</li><li>ws://example.com/wsapi wss://secure.example.com/</li><li>IE10以上浏览器支持</li></ul><p>JMS  </p><ul><li>Java Message Service – Java消息服务</li><li>在两个应用程序或者分布式服务之间提供异步消息通讯</li><li>应用间解耦</li><li>企业应用集成中应用较多</li><li>消息服务器很多，Apache ActiveMQ是比较常见的一个</li></ul><p>JMS消息模式</p><ul><li>点对点（P2P）：每个消息有一个生产者一个消费者</li><li>发布者/订阅者（Pub/Sub）:每个消息一个生产者、多个消费者</li></ul><p>安装ActiveMQ<br>  配置pom文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>  配置application.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  activemq:</span><br><span class="line">    broker-url: tcp://127.0.0.1:61616</span><br></pre></td></tr></table></figure><p>  @EnableJms 注解</p><h2 id="部署Spring-Boot项目"><a href="#部署Spring-Boot项目" class="headerlink" title="部署Spring Boot项目"></a>部署Spring Boot项目</h2><h3 id="Spring-Profile-和配置日志记录框架"><a href="#Spring-Profile-和配置日志记录框架" class="headerlink" title="Spring Profile 和配置日志记录框架"></a>Spring Profile 和配置日志记录框架</h3><ul><li>可以设置不同的配置参数</li><li>可以设置不同的bean的装载</li></ul><p>Active Profile</p><ul><li>同时可以有多个被激活的profile</li><li>有active和default两个概念</li><li>如果没有设置active，则spring使用设置的default，如果没有声明default，则使用那些无显示指定的作为default</li></ul><h3 id="生产环境架构"><a href="#生产环境架构" class="headerlink" title="生产环境架构"></a>生产环境架构</h3><p>性能调优</p><ul><li>前端：数据缓存；加载顺序；显示顺序；预先加载；</li><li>NGINX: 设置客户端缓存；数据压缩传输；HTTP2.0</li><li>应用：优化算法；优化SQL（慢SQL）；避免N+1查询；异步操作；使用缓存；不常修改数据的静态化；集群；</li><li>数据库：索引和统计信息；优化表结构；冗余列和计算列；表拆分；分区表；统计慢SQL（提供程序）；SQL优化建议；升级硬件；</li></ul><h3 id="以服务程序运行（ubuntu）"><a href="#以服务程序运行（ubuntu）" class="headerlink" title="以服务程序运行（ubuntu）"></a>以服务程序运行（ubuntu）</h3><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="在-Spring-Boot-项目中使用Servlet-Filter-Listener等"><a href="#在-Spring-Boot-项目中使用Servlet-Filter-Listener等" class="headerlink" title="在 Spring Boot 项目中使用Servlet,Filter,Listener等"></a>在 Spring Boot 项目中使用Servlet,Filter,Listener等</h3><p>Servlet  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(name=&quot;QrcodeServlet&quot;, urlPatterns=&quot;/servlet/qrcode&quot;)</span><br><span class="line">public class QrcodeServlet extends HttpServlet implements Serializable&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Filter  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@WebFilter</span><br><span class="line">public class LogFilter implements Filter &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@ServletComponentScan 注解<br>@ComponentScan  </p><h3 id="Autowired-的加载规则"><a href="#Autowired-的加载规则" class="headerlink" title="Autowired 的加载规则"></a>Autowired 的加载规则</h3><p>@Autowired</p><ul><li>查找被注解的变量类型，找到所有此类型的构建或此类型子类的构建。</li><li>如果一个也没有找到，看required参数，false则用null，true则失败（默认）。</li><li>如果仅找到一个，则装载这个构件。</li><li>如果找到多个，且只有一个有@Primary注解，使用Primary的。</li><li>如果不符合上述条件，失败。</li></ul><p>@Autowired @Qualifier</p><ul><li>如果属性既有Autowired注解又有Qualifier注解</li><li>在构件中查找名字为Qualifier中指定的名字的注解。</li><li>在构件上指定名字的方法有两个，@Service(“这里写名字”)，@Qualifier(“这里写名字”)。</li></ul><h3 id="API-的版本"><a href="#API-的版本" class="headerlink" title="API 的版本"></a>API 的版本</h3><p>客户端传递版本信息方式</p><ul><li>URL</li><li>RequestHeader</li></ul><p>URL</p><ul><li>部署，通过修改NGINX配置，不同域名，不同前缀。</li><li>修改application.yml中的contextPath，server.servlet.contextPath:/tutorial-v2</li><li>修改@RequestMapping中的参数，例如，@RequestMapping(“/v1/tvseries”)</li><li>增加request的参数，例如：/tvseries?version=2</li></ul><p>Request Header  </p><ul><li>自定义request header，例如：Version:2</li><li>使用Accept  Accept:application/vnd.tutorial.v2 + json</li></ul><p>自定义 RequestMappingHandlerMapping  </p><ul><li>自定义ApiVersion注解</li><li>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</li></ul><h3 id="定制Spring-REST的错误返回信息"><a href="#定制Spring-REST的错误返回信息" class="headerlink" title="定制Spring REST的错误返回信息"></a>定制Spring REST的错误返回信息</h3><p>Controller中单独处理</p><ul><li>把返回值改成ResponseEntity<t></t></li><li>T为要返回的内容</li><li>通过ResponseEntity来设置返回的HttpResponse状态码</li></ul><p>全局的异常处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">public class ExceptionHandler &#123;</span><br><span class="line">    @ExceptionHandler(Throwable.class)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    ResponseEntity&lt;Object&gt; handleControllerException(Throwable ex, WebRequest request) &#123;</span><br><span class="line">        //处理异常，并设置给客户端反馈的信息</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Spring" scheme="http://yeonsea.club/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yeonsea.club/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>赠药山高僧惟俨二首</title>
    <link href="http://yeonsea.club/2018/12/23/%E8%B5%A0%E8%8D%AF%E5%B1%B1%E9%AB%98%E5%83%A7%E6%83%9F%E4%BF%A8%E4%BA%8C%E9%A6%96/"/>
    <id>http://yeonsea.club/2018/12/23/赠药山高僧惟俨二首/</id>
    <published>2018-12-23T11:11:58.000Z</published>
    <updated>2018-12-23T12:11:43.069Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2018/12/23/赠药山高僧惟俨二首/../赠药山高僧惟俨二首/赠药山高僧惟俨二首.jpeg"></p><blockquote><p>练得身形如鹤形，千株松下两函经。我来问道无馀说，云在青霄水在瓶。</p></blockquote><blockquote><p>选得幽居惬野情，终年无送亦无迎。有时直上孤峰顶，月下披云啸一声。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Tao" scheme="http://yeonsea.club/categories/Tao/"/>
    
    
      <category term="Tao" scheme="http://yeonsea.club/tags/Tao/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yeonsea.club/2018/12/22/hello-world/"/>
    <id>http://yeonsea.club/2018/12/22/hello-world/</id>
    <published>2018-12-22T15:53:34.885Z</published>
    <updated>2018-12-23T12:12:50.552Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2018/12/22/hello-world/../hello-world/hello-world.jpg"></p><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
</feed>
